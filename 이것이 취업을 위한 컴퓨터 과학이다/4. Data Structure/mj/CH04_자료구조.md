# CH04. 자료 구조

## 📌 핵심 개념 요약

- 시간복잡도와 공간복잡도
- 배열과 연결 리스트
    - 연결 리스트 종류(싱글 연결, 이중 연결, 환형 연결)
- 스택과 큐
    - 스택과 큐 구현해보기
    - 큐의 종류 (원형 큐, 양방향 큐, 우선순위 큐)
- 해시테이블
    - 해시함수, 해시 알고리즘, 버킷, 로드 팩터
    - 해시 충돌과 해결법 (체이닝, 개방 주소법, 이중 해싱)
    - 해시 테이블을 사용하는 이유
- 트리
    - 노드, 간선, 부모/자식/루트/리프 노드, 차수, 레벨, 서브트리
    - 트리의 순회 (전위 / 중위 / 후위)
        - 구현해보기
    - 이진 트리 종류 (편향된 이진트리, 정 이진 트리, 포화 이진 트리, 완전 이진 트리)
    - 이진 탐색 트리와 힙
        - 최대 힙, 최소 힙
        - 자가 균형 이진 탐색 트리 (AVL트리, RB트리)
    - B트리와 B+트리
- 그래프
    - 연결-비연결 / 방향-무방향 / 가중치 / 서브 그래프
    - 그래프 표현 (인접행렬, 인접리스트)
    - 깊이 우선 탐색 (DFS), 너비 우선 탐색(BFS)
    - 최단 경로 알고리즘 (다익스트라 알고리즘)

## 💡 면접 예상 질문

- 배열과 연결 리스트의 차이는?
- 스택 / 큐 구현하기
- 트리의 순회 구현하기
- 해시 테이블을 사용하는 이유와 해시 충돌이 생겼을 때 해결방법은?
- B트리와 B+트리를 설명해주세요.

## ❓스터디에서 논의하고 싶은 질문
- 

## 🔗 참고 자료

- **[책]** 이것이 취업을 위한 컴퓨터 과학이다 with CS 기술 면접
- **[책]** 좌충우돌, 파이썬으로 자료구조 구현하기 https://wikidocs.net/book/9059

---

## 1️⃣ 자료구조의 큰 그림

- 알고리즘: 어떠한 목적을 이루기 위해 효율적인 연산 방법에 대해 다룸
- 시간복잡도와 공간복잡도
    - 시간복잡도
        - 입력의 크기에 따른 프로그램 실행 시간의 관계 (입력 크기에 따른 연산 횟수)
        - 표기법
            - 빅 오 표기법: 입력에 대한 실행 시간의 점근적 상한
            - 빅 세타 표기법: 입력에 대한 ‘평균적인 실행 시간’
            - 빅 오메가 표기법: 입력에 대한 실행시간의 ‘점근적 하한’
    - 공간복잡도
        - 프로그램이 실행되었을 때 필요한 메모리 자원의 양
        - 모든 프로그램은 실행을 위해 메모리에 적재되어야함

## 2️⃣ 배열과 연결 리스트

### 배열

- 일정한 메모리 공간을 차지하는 여러 요소들이 순차적으로 나열된 자료구조
- 고유한 순서 번호인 인덱스가 매겨짐
- 시간복잡도
    - 인덱스를 통해 요소에 **접근**/**수정**하는 시간은 요소의 개수와 무관하게 일정: `O(1)`
    - 순차적 **탐색**/ **추가**/ **삭제** : `O(n)`
        - 중간에 추가/삭제된 요소로 인해 이후의 요소들이 이동되어야 하기 때문
- 이차원, 삼차원 배열으로 확장 가능

### 연결 리스트

| 데이터 | 다음 노드 |
| --- | --- |
- 헤드 | 꼬리로 구성
    - 데이터 | 다음 노드의 위치 (메모리 상의 주소)
- 연결 리스트를 구성하는 모든 노드는 반드시 메모리 내에 순차적으로 저장되어 있을 필요가 없음 → 연속적으로 구성되어 있는 데이터를 불연속적으로 저장할 때 유용하다!
- 시간복잡도
    - 접근: 앞에서부터 순차적으로 접근할 수 밖에 없기 때문에 `O(n)`
    - 추가 / 삭제 : 다음 노드를 기억하고 있기 때문에 `O(1)`
- 연결 리스트 종류
    - 싱글 연결 리스트
        - 다음 노드의 위치만 알 수 있고, 이전 노드의 위치 알기 어려움
        - 단방향 탐색만 가능
    - 이중 연결 리스트
        - 다음 노드의 위치, 이전 노드의 위치 정보 모두 포함
        - 양방향 탐색 가능
        - 탐색 성능 완화할 수 있지만 그만큼 저장 공간이 더 필요
    - 환형 연결 리스트
        - 꼬리 노드(마지막)가 헤드 노드(첫 번째)를 가리켜 노드들이 원형으로 구성됨
        - 모든 노드 데이터를 여러 차례 순회해야할 때 유용하게 활용 가능

## 3️⃣ 스택과 큐

### 스택

- 한 쪽에서만 데이터의 삽입 및 삭제가 가능한 자료구조
- 후입선출 (Last in First Out)
- push(데이터를 저장), pop(데이터를 삭제)
- 활용)
    - 최근에 임시 저장한 데이터를 가장 먼저 활용해야할 때
        - 최근에 호출된 함수의 매개변수가 가장 먼저 활용되고, 가장 먼저 메모리에서 삭제
    - 뒤로가기 기능을 만들고 싶을 때

### 구현하기

```python
class myStack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        if self.is_empty():
            return None
        item = self.items[-1]
        del self.items[-1]
        return item

    def is_empty(self):
        return len(self.items) == 0

s = myStack()
s.push('a')
s.push('b')
s.push('c')

print(s.pop())  # c
print(s.pop())  # b
print(s.pop())  # a
```

### 큐

- 한 쪽으로 데이터를 삽입하고, 다른 한 쪽으로 데이터를 삭제할 수 있는 자료구조
- 선입선출 (First In First Out)
- enqueue(큐 한쪽 끝에 데이터를 삽입), deque(데이터를 삭제하는 연산)
- 활용)
    - 임시저장된 데이터를 차례차례 내보내거나 꺼내 와야하는 각종 버퍼로 활용 (줄 세우기)
- 큐 종류
    - 원형 큐 (삽입/삭제 하는 양쪽을 하나로 연결해 원형으로 사용)
    - 양방향 큐 (양쪽으로 데이터를 삽입/삭제할 수 있는 큐)
    - 우선순위 큐 (정해진 우선순위가 높은 순서대로 빠져나가는 큐)
- 힙
    - 우선순위 큐는 힙이라는 자료구조를 기반으로 구현됨

### 구현하기

```python
class myQueue:
    def __init__(self):
        self.items = []

    def enqueue(self, item):
        self.items.append(item)

    def dequeue(self):
        if self.is_empty():
            return None
        item = self.items[0]
        del self.items[0]
        return item

    def is_empty(self):
        return len(self.items) == 0

q = myQueue()
q.enqueue('a')
q.enqueue('b')
q.enqueue('c')

print(q.dequeue())  # a
print(q.dequeue())  # b
print(q.dequeue())  # c
```

## 4️⃣ 해시테이블

> 키 - 값 대응
> 
> - 키: 해시 테이블에 대한 입력
> - 값: 키를 통해 얻고자 하는 데이터

구조

- 버킷: 여러 버킷들은 배열을 형성. 키를 통해 얻고자 하는 데이터가 들어있음
- 해시함수는 키를 인자로 활용해 인덱스를 반환한다.

![image.png](attachment:2ab0741a-7d6f-45ab-9fa1-fdfd5186951b:image.png)

- 로드 팩터: 해시 테이블에 저장된 데이터 수를 버킷의 수로 나눈 수
    - 즉, 해시 테이블이 얼마나 가득 차 있는지에 대한 지표
    - 클수록 해시테이블의 성능이 떨어짐

### 해시함수

- 임의의 길이를 지닌 데이터를 고정된 길이의 데이터로 변환하는 단방향 함수
    - **단방향 함수**이므로 특정 입력 데이터를 고정된 길이의 해시 값으로 변환할 수는 있어도 반대로 해시 값을 토대로 어떤 데이터가 입력되었는지를 도출하기 어렵다.
- 해시 알고리즘
    - 예시) MD5, SHA-1, SHA-256, SHA-512, SHA3, HMAC
- 데이터의 무결성
    - 무작위 값을 만들거나 단방향 암호를 만들 때, 데이터의 무결성을 검증하기 위해 사용되기도 한다.
    - 전송 과정에서 조금이라도 정보가 왜곡되거나 훼손되었다면 전혀 다른 해시 값이 도출되므로 잘못된 데이터가 전송되었음을 쉽게 파악할 수 있음
- 활용
    - 비밀번호 저장
        - 사이트에 단방향 암호화 (해시함수 적용)를 통해 저장되도록 규제하고 있음
            - 해시 함수 ex) bcrypt, PBKDF2, scrypt, argon2 …
        - 웹 프레임워크는 로그인 및 회원 정보 저장 기능을 제공한다. 해시 함수 또한 웹 프레임워크 단계에서 지원하는 경우가 많다.
            - ex) 스프링 시큐리티 (BCryptPasswordEncoder), 장고(PASSWORD_HASERS)
- 모듈러 연산도 간단한 해시 함수라고 볼 수 있다.

### 해시테이블

- **해시테이블을 사용하는 이유?**
    - **빠른 검색 속도**
    - 검색, 삽입, 삭제 연산의 시간복잡도 : `O(1)`
- 단점도 있음!
    - 속도가 빠른 만큼 **상대적으로 많은 메모리 공간이 소요됨**

### 해시 충돌

- 서로 다른 키에 대해 같은 해시 값이 대응되는 상황
- 어떻게 해결할까?
    - 체이닝
    - 개방 주소법
- 체이닝 (chaining)
    - 충돌이 발생한 데이터를 ‘**연결 리스트**’로 추가하는 방법
    - 충돌이 발생할 때마다 연결 리스트의 노드가 추가된다면 빠른 속도라는 해시 테이블의 장점을 살리지 못할 수 있음 (탐색의 성능이 O(n)까지 떨어질 수 있음)
- 개방 주소법 (open addressing)
    - 충돌이 발생한 버킷의 인덱스가 아닌 다른 인덱스에 데이터를 저장하는 방식
    - 조사: 충돌이 발생했을 때 비어 있는 다른 버킷의 인덱스를 찾는 과정
        - 선형 조사법
            - 충돌이 발생한 인덱스의 다음 인덱스부터 순차적으로 가용한 인덱스 찾기
            - f(key) `+1` , f(key) `+2`, f(key) `+3`, …
        - 이차 조사법
            - 충돌이 발생한 인덱스에서 제곱수만큼 떨어진 거리에 위치한 인덱스 찾기
            - f(key) `+1^2` , f(key) `+2^2`, f(key) `+3^2`, …
    - 데이터의 군집화
        - 충돌이 발생한 인덱스 인근에 충돌이 발생한 여러 데이터가 몰려 저장되는 현상
        - 오랜 순차 탐색이 필요해 성능 악화로 이어질 수 있음
- 이중 해싱 (double hashing)
    - 2개의 해시 함수를 사용하는 방법
    - 다른 해시 함수에 대한 해시 값만큼 떨어진 거리에 위치한 인덱스 찾기
    - f(key) `+ g(key)`, f(key) `+ 2g(key)`, f(key) `+ 3g(key)`
- 프로그래밍 언어별 해시 테이블 구현
    - C++ : unordered_map
    - Java: HashTable, HashMap
    - Python: dictionary
    - JavaScript: Map
    - Go: Map

## 5️⃣ 트리

- 계층적인 구조를 표현하기 위한 자료구조 (노드-간선으로 구성)
- 관련 용어
    
    ![image.png](attachment:d6bff797-3d4f-4301-a3eb-085eeeb8763c:image.png)
    
    - **루트(root)**: 부모 노드가 없는 최상위 노드. 트리마다 루트는 하나다.
    - **부모(parent) 노드**: 자식 노드를 가지는 노드.
    - **자식(child) 노드**: 어떤 노드의 하위 노드.
    - **형제(sibling) 노드**: 부모가 같은 노드들.
    - **리프(leaf) 노드**: 자식이 없는 노드.
    - **서브트리(subtree)**: 특정 노드를 루트로 했을 때 그 노드 아래로 구성되는 트리.
    - **크기(size)**: 자신을 포함한 모든 자식 노드의 수.
    - **레벨(level)**: 루트에서부터 해당 노드까지 연결된 간선의 수.
    - **깊이(depth)**: 루트에서 해당 노드까지의 거리. 수치적으로는 레벨과 같다.
    - **높이(height)**: 해당 노드에서 가장 깊은 하위 노드까지의 거리.
    - **경로(path)**: 어떤 노드에서 다른 노드로 가기 위해 거치는 노드들의 순서.
    - **차수(degree)**: 자식 노드의 수.
        
        > 레벨(Level), 깊이(Depth), 높이(Height) 는 개념이 비슷해 보이지만 구분할 필요가 있다.
        > 
        > 
        > **깊이**는 루트에서 특정 노드까지의 거리이고,
        > 
        > **높이**는 특정 노드에서 가장 깊은 하위 노드까지의 거리다.
        > 
- 구현 방법
    - 하나의 노드를 (데이터를 저장할 공간) (자식 노드의 위치 정보들)의 모음으로 간주
        
        (마치 연결리스트처럼…)
        

### 트리 순회

- 전위 순회
    - 루트 노드 → 왼쪽 서브트리 전위 순회 → 오른쪽 서브트리 전위 순회
    
    ![image.png](attachment:19432e87-b6b0-4d78-a698-0ca2e6b9aee8:image.png)
    
- 중위 순회
    - 왼쪽 서브트리 전위 순회 → 루트 노드 → 오른쪽 서브트리 전위 순회
    
    ![image.png](attachment:e97f97af-aa78-4d78-bfe0-143c8380c9fc:image.png)
    
- 후위 순회
    - 왼쪽 서브트리 전위 순회 → 오른쪽 서브트리 전위 순회 → 루트 노드
    
    ![image.png](attachment:c8524b10-90e4-4f94-b6f8-147c902211c5:image.png)
    
- cf) 레벨 순서 순회
    - 가장 낮은 레벨부터 차례로 노드를 순회하는 방법도 있음

### 트리 종류

- 이진 트리
    - 편향된 이진 트리
        - 모든 자식노드가 한쪽으로 치우친 이진 트리)
    - 정 이진 트리
        - 자식 노드의 개수가 1개가 아닌 이진 트리
    - 포화 이진 트리
        - 리프 노드를 제외한 모든 노드들이 자식 노드를 2개씩 가지고 있고, 모든 리프 노드의 레벨이 동일한 이진 트리
    - 완전 이진 트리
        - 마지막 레벨을 제외한 모든 레벨이 2개의 자식 노드를 가지고 있으며, 마지막 레벨의 모든 노드들이 왼쪽부터 존재하는 이진 트리
- 이진 탐색 트리
    - 특정 노드의 왼쪽 서브트리에는 해당 노드보다 작은 값을 지닌 노드들이 있고, 오른쪽 서브 트리에는 해당 노트보다 큰 값을 지닌 노드들이 있는 구조의 이진 트리
    - 탐색 시간 복잡도: `O(log n)`
        - 단, 편향된 이진 트리의 경우, 탐색 속도는 O(n)
- 힙
    - 탐색에 특화된 트리의 일종
    - 최댓값과 최솟값을 빠르게 찾기 위해 사용
    - 최대 힙과 최소힙
        - 최대 힙: 부모 노드가 자식 노드의 값보다 큰 값으로 이루어진 이진 트리
        - 최소 힙: 부모 노드가 자식 노드의 값보다 작은 값으로 이루어진 이진 트리
    - 숫자 뿐만 아니라 문자 간의 비교도 가능하고, 원하는 우선순위 직접 지정 가능
- 자가 균형 이진 탐색 트리
    - 이진 탐색 트리는 삽입과 삭제 연산을 반복하며 편향된 트리가 될 수도 있다. 이러한 이진 탐색 트리의 탐색 성능을 균일하기 유지하려면?
        - 왼쪽 서브트리와 오른쪼고 서브트리의 높이 차이가 최소화 되어야한다.
            
            → 자가 균형 이진 탐색 트리
            
            ex) AVL 트리, RB 트리
            
- RB 트리
    - 활용)
        - 리눅스의 CPU 스케줄러인 CFS 스케줄러
        - 키-쌍 데이터를 저장하는 C++의 맵(map)
    - 모든 노드를 빨간색 혹은 검은색으로 칠한 트리.
        - RB 트리의 리프 노드는 NIL (Null Leaf) 노드라고 부르는 실질적인 데이터가 저장되어 있지 않은 노드라고 가정한다.
    - RB 트리 유지 조건
        1. 루트 노드는 블랙 노드이다.
        2. 리프 노드는 블랙 노드이다.
        3. 레드 노드의 자식 노드는 블랙 노드이다.
        4. 루트 노드에서 임의의 리프 노드에 이르는 경로의 블랙 노드 수는 같다. (Black-Height)
    - 새 노드를 삽입할 때
        - 삽입할 노드를 레드로 간주하고, 일반 이진 탐색 트리와 동일하게 삽입을 수행
            - Red로 지정하는 이유는 Black-Height 변경을 최소화하기 위함이다.
        - 노드 삽입 이후에도 RB 트리 조건이 유지되어야함
        - 트리 조건에 부합할 때까지 트리를 회전하거나 색상을 재지정
- B트리
    
    ![image.png](attachment:7423cc13-35e1-42c7-b600-0efd27e19393:image.png)
    
    - RB트리와 마찬가지로 균형을 유지하는 트리
    - **파일시스템이나 데이터베이스와 같은 대용량 입출력 작업이 필요한 상황에서 주로 사용된다.**
        - 한 노드에 블록 단위의 여러 데이터를 저장할 수 있는 B트리가 보조기억장치에 대한 입출력 연산을 줄일 수 있어 성능 면에서 이득!
    - B 트리는 이진 탐색 트리가 아닌 **다진 탐색 트리**
        - 다진 탐색 트리: 한 노드가 다음과 같이 여러 자식 노드를 가질 수 있는 트리
    - 구성
        - B 트리에서는 한 노드가 가질 수 있는 자식 노드의 최소/최대 수가 정해져있음
        - 최대 자식 노드의 개수: M개 → M차 B트리
        - 최소 자식 노드의 개수: M/2 (올림)
            
            ex) 5차 B 트리의 한 노드는 최대 5개의 자식 노드를 가질 수 있고, 루트 노드와 리프 노드를 제외한 노드들은 최소 3개의 자식 노드를 가질 수 있다.
            
        - 하나 이상의 키 값이 존재하고, 각 키들이 오름차순으로 저장
            
            ![image.png](attachment:90f80275-3602-4a79-bdd7-afec704593f8:image.png)
            
    - **각 키 사이에 자식 노드(혹은 서브트리)의 위치를 저장하고 있고, 키가 자식 노드(혹은 서브트리)가 가질 수 있는 범위를 나타내는 역할을 한다!**
    - 키가 N개인 노드가 가질 수 있는 자식 노드의 수는 반드시 (N+1)개가 된다.
    - B 트리는 모든 리프 노드의 깊이가 같다.
- B+트리
    - B 트리의 변형된 형태
    - 주요 차이점 2가지!
        1. B+ 트리에서는 실질적인 데이터가 모두 최하위 리프 노드에 위치한다.
            - 리프 노드가 아닌 노드에 저장되어 있는 것
                - 자식 노드의 범위를 분할할 용도로 사용되는 키
                - 자식노드의 주소
        2. 실질적 데이터를 저장하는 최하위 리프 노드는 연결 리스트의 형태를 띄고 있다.
            - 따라서 부모 노드와 다른 리프 노드들 간의 범위 연산이 용이함
    
    ![image.png](attachment:bb43095a-20b9-4170-accb-8d5c2d4a22d9:image.png)
    
- 그 외 트리
    - 트라이, 세그먼트 트리, 멘윅 트리 등

## 6️⃣ 그래프

- 정점이라 불리는 데이터를 간선(혹은 링크)로 연결한 형태의 자료구조 (연결관계 표현)
- 트리도 그래프의 일종!
    - 트리는 **사이클**을 형성하지 **않고**, 연결된 노드 간에 **상하 관계를 갖는다**
    - 그래프는 **사이클**을 형성할 수 **있고**, 이웃한 정점끼리 **상하 관계를 갖지 않는다.**
- 연결/비연결, 방향/무방향, 가중치, 서브 그래프
- 그래프 표현
    - 인접 행렬 기반
    - 인접 리스트 기반
- 깊이 우선 탐색과 너비 우선 탐색
    - 깊이 우선 탐색 (DFS)
        - 그래프에서 더 이상 방문한 정점이 없을 때까지 최대한 깊이 탐색하기를 반복하는 탐색 방법
        - 배열(방문 여부)과 스택으로 구현
    - 너비 우선 탐색 (BFS)
        - 인접한 모든 정점들을 방문하고, 방문한 정점들과 연결된 모든 정점을 방문하기를 반복하는 탐색 방법
        - 배열(방문 여부)과 큐로 구현
- 최단 경로 알고리즘
    - 한 정점에서 목적지 정점까지 이르는 가중치의 합이 최소가 되는 경로를 결정하는 알고리즘
    - ex) 다익스트라 알고리즘
        - 간선의 가중치가 음이 아닌 수라는 가정 하에 사용 가능한 알고리즘
        - 특정 정점에 이르는 거리를 저장한 데이터 (최단 거리 테이블)가 함께 사용
            - 경로 상의 가중치 합과 최단 거리 테이블 상의 값을 비교