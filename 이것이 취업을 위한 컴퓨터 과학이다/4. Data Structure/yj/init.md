### Array & LinkedList

| 항목       | `Array`          | `ArrayList`      | `LinkedList`      |
| -------- | ---------------- | ---------------- | ----------------- |
| 구조       | 고정 크기의 배열        | 내부적으로 배열 사용      | 노드 기반 연결 리스트      |
| 크기       | 고정 (선언 시 결정) | 자동으로 동적 확장   | 자동으로 동적 확장    |
| 데이터 접근   | 인덱스로 O(1)        | 인덱스로 O(1)        | 인덱스로 O(n)         |
| 삽입/삭제 성능 | 느림 (복사 필요)       | 중간 삽입/삭제 시 느림    | 중간 삽입/삭제 빠름   |
| 메모리 효율   | 가장 효율적           | 배열보다 다소 비효율적     | 노드 포인터로 메모리 더 사용  |
| 순차 접근    | 빠름               | 빠름               | 빠름                |
| 랜덤 접근    | 빠름               | 빠름               | 느림                |
| 사용 예시    | 정해진 크기의 정수 배열 등  | 리스트, 동적 크기 필요할 때 | 큐, 덱, 자주 삽입/삭제할 때 |


#### 1. `Array` (배열)

```java
int[] arr = new int[5];
arr[0] = 10;
```

* **고정된 크기**를 가지며, 생성 이후 크기 변경 불가
* `O(1)` 시간으로 인덱스 접근 가능
* 중간 삽입/삭제 시 배열 복사가 필요해 **비효율적**

---

#### 2. `ArrayList`

```java
ArrayList<Integer> list = new ArrayList<>();
list.add(10);
list.add(0, 5); // 중간 삽입
```

* 내부적으로 **배열 기반**
* 자동으로 **크기가 늘어남 (2배 확장)**
* 중간 삽입/삭제 시 데이터를 **복사**해야 하므로 느림
* **랜덤 접근 빠름**, 리스트 다룰 때 가장 많이 사용됨

---

#### 3. `LinkedList`

```java
LinkedList<Integer> list = new LinkedList<>();
list.add(10);
list.addFirst(5);  // 맨 앞에 삽입
```

* **이중 연결 리스트 (Doubly Linked List)**
* 중간 삽입/삭제는 포인터만 바꾸면 되므로 **빠름**
* 인덱스로 접근할 경우 순차 탐색하므로 **느림 (O(n))**
* 큐, 스택, 덱 구조에 적합


### Stack & Queue

#### Stack
선형 자료구조의 일종으로 LIFO

#### Queue
선형 자료구조의 일종으로 FIFO
Java에서는 인터페이스로 LinkedList, PriorityQueue 등의 구현체를 가지고 있음.

두 자료구조는 DFS, BFS에서 많이 사용됨

### Tree
비선형적 자료구조, 계층적 관계를 표현하는 자료구조.

트리를 구성하고 있는 구성요소들(용어)
- Node (노드) : 트리를 구성하고 있는 각각의 요소를 의미한다.
- Edge (간선) : 트리를 구성하기 위해 노드와 노드를 연결하는 선을 의미한다.
- Root Node (루트 노드) : 트리 구조에서 최상위에 있는 노드를 의미한다.
- Terminal Node ( = leaf Node, 단말 노드) : 하위에 다른 노드가 연결되어 있지 않은 노드를 의미한다.
- Internal Node (내부노드, 비단말 노드) : 단말 노드를 제외한 모든 노드로 루트 노드를 포함한다.


#### Binary Tree (이진 트리)
정의: 각 노드가 최대 두 개의 자식 노드를 가지는 트리
각 자식은 왼쪽 자식(left), 오른쪽 자식(right)으로 구분
트리는 루트(root) 노드부터 시작하며, 노드 간에는 계층적(parent-child) 관계가 있음

#### 이진 트리의 종류

| 종류                            | 설명                            |
| ----------------------------- | ----------------------------- |
| 정 이진 트리   | 모든 노드가 0개 또는 2개의 자식을 가짐       |
| 완전 이진 트리 | 왼쪽부터 차례로 채워진 트리               |
| 포화 이진 트리 | 모든 리프가 같은 깊이에 있고, 노드가 완전히 채워짐 |
| 이진 탐색 트리 | 왼쪽 < 부모 < 오른쪽 조건을 만족          |
| 균형 이진 트리 | 좌우 서브트리의 높이 차이가 제한됨           |

#### BST (Binary Search Tree)
- 규칙 1. 이진 탐색 트리의 노드에 저장된 키는 유일하다.
- 규칙 2. 부모의 키가 왼쪽 자식 노드의 키보다 크다.
- 규칙 3. 부모의 키가 오른쪽 자식 노드의 키보다 작다.
- 규칙 4. 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다.

#### Binary Heap
자료구조의 일종으로 Tree의 형태을 하고 있으며, Tree 중에서도 배열에 기반한 Complete Binary Tree이다.

- O(1) 시간에 최대/최솟값 조회 가능
- O(log n) 시간에 삽입, 삭제 가능 → 정렬보다 빠름
- 완전 이진 트리 구조라서 배열로 구현하기 쉬움

Java의 PriorityQueue는 내부적으로 Binary Heap을 사용하고 있음.