### Array & LinkedList

| 항목       | `Array`          | `ArrayList`      | `LinkedList`      |
| -------- | ---------------- | ---------------- | ----------------- |
| 구조       | 고정 크기의 배열        | 내부적으로 배열 사용      | 노드 기반 연결 리스트      |
| 크기       | 고정 (선언 시 결정) | 자동으로 동적 확장   | 자동으로 동적 확장    |
| 데이터 접근   | 인덱스로 O(1)        | 인덱스로 O(1)        | 인덱스로 O(n)         |
| 삽입/삭제 성능 | 느림 (복사 필요)       | 중간 삽입/삭제 시 느림    | 중간 삽입/삭제 빠름   |
| 메모리 효율   | 가장 효율적           | 배열보다 다소 비효율적     | 노드 포인터로 메모리 더 사용  |
| 순차 접근    | 빠름               | 빠름               | 빠름                |
| 랜덤 접근    | 빠름               | 빠름               | 느림                |
| 사용 예시    | 정해진 크기의 정수 배열 등  | 리스트, 동적 크기 필요할 때 | 큐, 덱, 자주 삽입/삭제할 때 |


#### 1. `Array` (배열)

```java
int[] arr = new int[5];
arr[0] = 10;
```

* **고정된 크기**를 가지며, 생성 이후 크기 변경 불가
* `O(1)` 시간으로 인덱스 접근 가능
* 중간 삽입/삭제 시 배열 복사가 필요해 **비효율적**

---

#### 2. `ArrayList`

```java
ArrayList<Integer> list = new ArrayList<>();
list.add(10);
list.add(0, 5); // 중간 삽입
```

* 내부적으로 **배열 기반**
* 자동으로 **크기가 늘어남 (2배 확장)**
* 중간 삽입/삭제 시 데이터를 **복사**해야 하므로 느림
* **랜덤 접근 빠름**, 리스트 다룰 때 가장 많이 사용됨

---

#### 3. `LinkedList`

```java
LinkedList<Integer> list = new LinkedList<>();
list.add(10);
list.addFirst(5);  // 맨 앞에 삽입
```

* **이중 연결 리스트 (Doubly Linked List)**
* 중간 삽입/삭제는 포인터만 바꾸면 되므로 **빠름**
* 인덱스로 접근할 경우 순차 탐색하므로 **느림 (O(n))**
* 큐, 스택, 덱 구조에 적합


### Stack & Queue

#### Stack
선형 자료구조의 일종으로 LIFO

#### Queue
선형 자료구조의 일종으로 FIFO
Java에서는 인터페이스로 LinkedList, PriorityQueue 등의 구현체를 가지고 있음.

두 자료구조는 DFS, BFS에서 많이 사용됨

### Tree
비선형적 자료구조, 계층적 관계를 표현하는 자료구조.

트리를 구성하고 있는 구성요소들(용어)
- Node (노드) : 트리를 구성하고 있는 각각의 요소를 의미한다.
- Edge (간선) : 트리를 구성하기 위해 노드와 노드를 연결하는 선을 의미한다.
- Root Node (루트 노드) : 트리 구조에서 최상위에 있는 노드를 의미한다.
- Terminal Node ( = leaf Node, 단말 노드) : 하위에 다른 노드가 연결되어 있지 않은 노드를 의미한다.
- Internal Node (내부노드, 비단말 노드) : 단말 노드를 제외한 모든 노드로 루트 노드를 포함한다.


#### Binary Tree (이진 트리)
정의: 각 노드가 최대 두 개의 자식 노드를 가지는 트리
각 자식은 왼쪽 자식(left), 오른쪽 자식(right)으로 구분
트리는 루트(root) 노드부터 시작하며, 노드 간에는 계층적(parent-child) 관계가 있음

#### 이진 트리의 종류

| 종류                            | 설명                            |
| ----------------------------- | ----------------------------- |
| 정 이진 트리   | 모든 노드가 0개 또는 2개의 자식을 가짐       |
| 완전 이진 트리 | 왼쪽부터 차례로 채워진 트리               |
| 포화 이진 트리 | 모든 리프가 같은 깊이에 있고, 노드가 완전히 채워짐 |
| 이진 탐색 트리 | 왼쪽 < 부모 < 오른쪽 조건을 만족          |
| 균형 이진 트리 | 좌우 서브트리의 높이 차이가 제한됨           |

#### BST (Binary Search Tree)
- 규칙 1. 이진 탐색 트리의 노드에 저장된 키는 유일하다.
- 규칙 2. 부모의 키가 왼쪽 자식 노드의 키보다 크다.
- 규칙 3. 부모의 키가 오른쪽 자식 노드의 키보다 작다.
- 규칙 4. 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다.

#### Binary Heap
자료구조의 일종으로 Tree의 형태을 하고 있으며, Tree 중에서도 배열에 기반한 Complete Binary Tree이다.

- O(1) 시간에 최대/최솟값 조회 가능
- O(log n) 시간에 삽입, 삭제 가능 → 정렬보다 빠름
- 완전 이진 트리 구조라서 배열로 구현하기 쉬움

Java의 PriorityQueue는 내부적으로 Binary Heap을 사용하고 있음.

#### Red Black Tree
![Red Black Tree](Red-Black-Tree.png)

##### 규칙
1. 각 노드는 red 또는 black이다.
2. 루트 노드는 항상 black이다.
3. 모든 리프(nil 노드, null 포인터)는 black이다.
4. red 노드의 자식은 반드시 black이어야 한다. (즉, red-red 연속 불가)
5. 임의의 노드에서 리프까지 가는 모든 경로의 black 노드 수는 같아야 한다. (black height)

### Hash Table
1. 내부적으로 배열 기반
2. 평균 검색시간은 O(1)이지만, 충돌 시 O(N)까지 느려질 수 있음. 

#### Hash Function
key를 작은 범위의 숫자로 매핑하는 함수.

1. key 전체를 참조해 고르게 분포, 충돌을 최소화 하는 함수가 좋은 Hash Function.
2. 1:1보다 충돌을 줄이는게 더 좋은 선택임.

##### 충돌 해결 방법
| 항목      | Open Addressing | Separate Chaining |
| ------- | --------------- | ----------------- |
| 구조      | 배열 내부에서 이동      | 각 버킷에 별도 구조       |
| 캐시 효율   | 높음              | 낮음                |
| 확장 필요성  | 빠름              | 느림                |
| 밀도 증가 시 | 성능 급감           | 상대적으로 안정적         |

1. Open Addressing
빈 버킷을 찾아 직접 테이블 내부에서 이동하며 저장.

2. Separate Chaining
각 버킷에 연결 리스트 or 트리 구조로 여러 요소 저장.

##### 해시 버킷 동적 확장 (resize)
해시 버킷의 개수가 적으면 메모리를 아낄 수 있지만, 충돌로 성능 저하가 발생함.
key-value 쌍 데이터 개수가 일정 이상이 되면, 해시 버킷의 개수를 2배로 늘림.

### Graph

* 그래프(Graph) : 정점(Vertex)과 간선(Edge)의 집합.
* 트리(Tree) : 그래프의 일종으로 사이클이 없는 연결 그래프.
* 유향 그래프(Directed) vs 무향 그래프

---

#### 그래프 표현 방식

| 방식     | 설명         | 공간 복잡도     | 특징                      |
| ------ | ---------- | ---------- | ----------------------- |
| 인접 행렬  | 2차원 배열로 표현 | `O(V²)`    | 빠른 탐색, Dense 그래프에 적합    |
| 인접 리스트 | 연결 리스트로 표현 | `O(V + E)` | 메모리 효율적, Sparse 그래프에 적합 |

---

#### 그래프 탐색 알고리즘

| 알고리즘                       | 자료구조          | 시간복잡도      | 특징                             |
| -------------------------- | ------------- | ---------- | ------------------------------ |
| DFS (Depth First Search)   | Stack (재귀 포함) | `O(V + E)` | 깊이 우선, 백트래킹                    |
| BFS (Breadth First Search) | Queue         | `O(V + E)` | 너비 우선, 최단 경로 탐색에 유리 (비가중치 그래프) |

---

#### 최소 신장 트리 (MST, Minimum Spanning Tree)
주어진 그래프에서 모든 정점을 연결하고, 간선 가중치의 합이 최소인 트리.

#### Kruskal’s Algorithm

간선 중심 (Edge-based)
간선을 가중치 기준 정렬 → cycle 없는 것만 선택
Union-Find로 cycle 여부 판단
시간복잡도: `O(E log E)`

#### Prim’s Algorithm

정점 중심 (Vertex-based)
현재 구성된 정점 집합에서 가장 작은 간선으로 새로운 정점 연결
우선순위 큐(Heap) 사용 시 시간복잡도: `O(E log V)`

---

## 💡 면접 예상 질문


## ✅ 기초 자료구조

### 📌 Array vs LinkedList

1. `Array`와 `LinkedList`의 차이점은 무엇인가요?
2. `ArrayList`와 `LinkedList` 중 중간 삽입/삭제에 더 적합한 것은 무엇인가요?
3. `LinkedList`는 왜 랜덤 접근 속도가 느린가요?

### 📌 Stack & Queue

4. `Stack`과 `Queue`의 차이점은 무엇인가요?
5. `Stack`을 어떤 문제에서 사용할 수 있나요? 예시를 말해보세요.

## ✅ 트리 (Tree)

### 📌 Binary Tree & BST

6. `이진 트리(Binary Tree)`와 `이진 탐색 트리(BST)`의 차이점은 무엇인가요?
7. BST에서의 탐색, 삽입, 삭제의 시간복잡도는 어떻게 되나요?

### 📌 Heap

8. `Binary Heap`이란 무엇인가요?

### 📌 Red Black Tree

9. `Red-Black Tree`가 Self-Balancing Tree인 이유는?
10. `Red-Black Tree`의 규칙 5가 의미하는 것은 무엇인가요?
11. `삽입 시 노드는 왜 항상 red로 추가되나요?`

## ✅ 해시(Hash Table)

12. `Hash Table`에서 충돌이 발생했을 때 해결 방법은?
13. `Open Addressing`과 `Separate Chaining`의 차이점은?
14. `HashMap`이 성능 저하 없이 동작하려면 어떤 조건을 만족해야 하나요?
15. 좋은 `Hash Function`의 조건은 무엇인가요?

## ✅ 그래프 (Graph)

16. 그래프를 저장하는 방법에는 어떤 것이 있나요? 각 방법의 장단점은?
17. `DFS`와 `BFS`는 각각 어떤 자료구조로 구현되며, 어떤 상황에 적합한가요?
18. `Kruskal`과 `Prim` 알고리즘의 차이는 무엇인가요?
19. 최소 신장 트리를 구하는 알고리즘들의 시간복잡도는 어떻게 되나요?

### 그 외
20. `Trie` 자료구조는 무엇인가요? 어떤 경우에 사용하나요?