# CH02. 컴퓨터 구조

- [운영체제의 큰 그림](#1-운영체제의-큰-그림)
- [프로세스와 스레드](#2-프로세스와-스레드)
- [동기화와 교착 상태](#3-동기화와-교착-상태)

## :pushpin: 핵심 개념 요약

## 1. 운영체제의 큰 그림

### 간단한 용어 정리

- `자원(시스템 자원, (system) resource)` : 프로그램 실행에 필요한 요소  
   실행에 필요한 ‘데이터(소프트웨어)’, 실행에 필요한 ‘부품(하드웨어)’
- `운영 체제(Operating System, OS)` : 응용프로그램 또는 사용자가 컴퓨터 하드웨어를 편리하고 효율적으로 사용하게 하기 위하여 시스템 자원(메모리, 프로세서 등)을 관리하고 여러가지 프로그램이 필요로 하는 공통적인 서비스를 제공하는 소프트웨어

- `프로세스(process)` : 실행 중인 프로그램의 인스턴스(instance)  
   => 하드디스크 등에 저장되어 있는 프로그램을 사용하기 위해 메모리에 복사한다.

- `스레드(thread)` : 프로세스 내에서 실행되는 가장 작은 실행 단위. 동일한 프로세스의 자원을 공유한다.

### 운영체제란?

- 운영 체제의 핵심 기능은  
   (1) 자원 할당 및 관리  
   (2) 프로세스 및 스레드 관리

### 운영체제의 역할

- `CPU 스케줄링` : CPU의 한정된 자원을 실행중인 프로그램들이 공정하고 합리적으로 할당받을 수 있도록 운영체제가 CPU의 할당 순서와 사용 시간을 결정한다.

- `메모리 관리` : 프로그램을 메모리에 적재 및 삭제하며 효율적으로 관리  
   가상 메모리 기술(실제 물리적인 메모리 크기보다 더 큰 메모리를 이용)을 활용

- `파일/디렉터리 관리` : 보조기억장치에서 원하는 정보 빠르게 접근하기 위해 `파일 시스템`을 활용해 보조기억장치 내의 정보들을 효율적으로 관리  
  (`파일 시스템` : 보조기억장치 내의 정보를 파일 및 폴더(디렉터리) 단위로 접근·관리할 수 있도록 만드는 운영체제 내부 프로그램)

- `입출력장치 및 캐시 메모리 관리` : 일부 입출력장치의 장치 드라이버, 하드웨어
  인터럽트 서비스 루틴을 제공하거나 캐시 메모리의 일관성을 유지하는 등의 기능을 제공

- `프로세스 및 스레드 관리` : 메모리에 적재된 여러 프로세스에 필요한 자원을 할당하고, 스레드는 할당받은 자원을 바탕으로 작업 수행. 프로세스를 이루는 스레드가 둘 이상인 경우에는 동일한 작
  업을 동시 진행 가능
  운영체제는 프로세스와 스레드가 올바르게 처리되도록 실행의 순
  서 제어, 자원을 적절하게 배분

<div align="center">
   <img src="./assets/운영체제 큰 그림.PNG" style="height:360px">
</div>

### 시스템 콜과 이중 모드

- `커널 영역(kernel space)` : 메모리 내에서 운영체제가 적재되는 영역
- `사용자 영역(user space)` : 운영체제가 적재되는 커널 영역 외에 사용자 응용 프로그램이 적재되는 공간
- `시스템 콜(system call)` : 운영체제의 서비스를 제공받기 위한 수단(인터페이스)으로, 호출 가능한 함수의 형태를 가진다.

일반적으로 (사용자)응용 프로그램은 CPU, 메모리와 같은 자원에 직접 접근 또는 조작이 불가능하기 때문에, `시스템 콜(system call)`을 호출하여 운영체제 코드를 실행한다.  
`(= 운영체제가 자신의 코드를 실행한 응용 프로그램의 자원 접근 및 조작을 대행)`

운영체제마다 제공하는 시스템 콜의 종류와 개수는 다양하다.

<div align="center" style="margin:40px">
   <img src="./assets/시스템 콜.PNG" style="height:360px">
</div>

> 프로세스는 또 다른 프로세스를 생성하며 계층적 구조로 관리된다. 이때 새 프로세스를 생성한 프로세스를 `부모 프로세스(parent process)`, 부모 프로세스에 의해 생성된 프로세스를 `자식 프로세스(child process)`라고 한다.

### 시스템 콜 호출 과정

- `소프트웨어 인터럽트(software interrupt)` : 명령어에 의해 발생하는 인터럽트

(1) 사용자 영역을 실행하는 과정에서 시스템 콜이 호출  
(2) CPU는 현재 수행 중인 작업을 백업  
(3) 커널 영역 내의 인터럽트를 처리하기 위한 코드(시스템 콜을 구성하는 코드)를 실행한 뒤  
(4) 다시 사용자 영역의 코드 실행을 재개

// 여기에서 만약에 자원을 리턴하게 된다면?
OS는 프로세스에 가장 주소를 리턴한다.

운영체제는 대부분 “자체 자원 그 자체”를 주는 게 아니라,
“그 자원을 가리키거나 간접적으로 조작할 수 있는 핸들 또는 주소”를 리턴합니다.

메모리 관련 요청 → 보통 가상 주소 리턴

파일, 소켓, 프로세스 등 → 보통 핸들(정수 ID) 리턴

```

 전체 흐름 요약
사용자 프로그램(스레드)이 어떤 자원이 필요함

예: 메모리 할당, 파일 열기, 네트워크 접속 등

운영체제에게 요청하기 위해 시스템 콜(System Call)을 사용

사용자 모드(User Mode)에서 커널 모드(Kernel Mode)로 전환됨

운영체제가 요청 처리 → 자원 할당 or 작업 수행

예: 메모리 공간을 확보하고 주소 리턴, 파일 핸들을 생성하여 리턴 등

결과(또는 자원 핸들)를 사용자 프로그램으로 리턴

다시 커널 모드에서 사용자 모드로 전환됨

스레드는 리턴받은 자원을 이용해 계속 작업 수행

예: 리턴받은 주소에 데이터를 저장하거나, 파일 핸들을 사용해 파일에 쓰기 등
```

## 2. 프로세스와 스레드

- `포그라운드 프로세스(foreground process)` : 사용자가 보는 공간에서 사용자와 상호작용

- `백그라운드 프로세스(background process)` : 사용자가 보지 못하는 공간
  - `데몬(demon) == 서비스(service)` : 사용자와 상호 작용 X

### 프로세스와 메모리

`사용자 영역`

- 정적 할당 영역 (실행도중 크기 변동 X)
  - `코드 영역`  
    : 실행 가능한 명령어가 저장되는 공간, 읽기 전용(read-only, 쓰기 금지)
  - `데이터 영역`  
    : 프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간(정적 변수, 전역 변수)
- 동적 할당 영역 (실행도중 크기 변동 O)
  - `힙 영역`  
    : 사용자가 직접 할당 가능한 저장 공간 (메모리 누수(memory leak) 발생 가능하여 가비지 컬렉션(garbage collection) 기능 제공하기도 함)
  - `스택 영역`  
    : 일시적으로 사용할 값들이 저장되는 공간 (매개변수, 지역 변수, 함수 복귀 주소)
    `스택 트레이스(stack trace)`(특정 시점에 스택 영역에 저장된 함수 호출 정보)가 저장될 수 있다

`커널 영역`

- `PCB(프로세스 제어 블록,Process Control Block)`
  - 프로세스와 관련한 다양한 정보를 내포하는 구조체의 일종
  - 프로세스 ID(PID), 실행 과정에서 사용한 레지스터 값, 프로세스 상태, 프로세스가 언제, CPU 스케줄링(우선순위) 정보, 메모리 관련 정보, 프로세스가 사용한 파일 및 입출력장치 관련 정보가 명시된다.
  - 여러 PCB들은 커널 내에 `프로세스 테이블(process table)`의 형태로 관리
  - 프로그램 실행시 PCB가 프로세스 테이블에 추가, 종료 시 제거  
    \*\* `좀비 프로세스(zombie process)` : 프로세스가 비정상 종료되어 사용한 자원이 회수되었음에도 프로세스 테이블에 남아있는 비정상 종료 상태

### 타이머 인터럽트

- 다양한 프로세스들은 한정된 시간 동안 운영체제로부터 CPU의 자원을 `번갈아 가며 할당`받아서 이용한다.

- `타이머 인터럽트(타임아웃 인터럽트,timer interrupt)`  
  : 시간이 끝났음을 알리는 인터럽트, 프로세스의 CPU 사용 시간은 타이머 인터럽트에 의해 제한됩니다.
  정해진 시간만큼 CPU를 이용하고, 타이머 인터럽트가 발생하면 자신의 차례를 양보하고 다음 차례가 올 때까지 기다린다.
- `문맥(context)` : 프로세스의 수행을 재개하기 위해 기억해야 할 정보(프로그램 카운터를 비롯한 각종 레지스터 값과 메모리 정보, 실행을 위해 열었던 파일, 사용한 입출력장치 등)
- 프로세스 할당 순서

  1.  차례가 된 프로세스가 정해진 시간동안 CPU 에 할당된다.
  2.  시간이 다 되면 지금까지의 context를 해당 프로세스의 PCB에 백업한다.
  3.  다음 차례에 시행할 프로세스의 context를 복구한다.

  `문맥 교환(context switching)` : 기존 프로세스의 문맥을 PCB에 백업하고, PCB에서 문맥을 복구하여 새로운 프로세스를 실행하는 과정

  프로세스 간에 너무 잦은 문맥 교환이 발생하면 캐시 미스가 발생할 가능성이 높아져 메모리로부터 실행할 프로세스의 내용을 가져오는 작업이 빈번해지고, 이는 큰 오버헤드로 이어질 수 있기 때문입니다.

### 프로세스의 상태

- `생성 상태(new)`  
  : 프로세스를 생성 중인 상태로, 메모리에 적재되어 PCB를 할당받은 상태

- `준비 상태(ready)`  
  : 생성 상태를 거쳐 실행할 준비가 완료된 프로세스  
  준비 상태인 프로세스가 CPU를 할당받으면 실행 상태가 되며, 준비 상태인 프로세스가 실행 상태로 전환되는 것을 `디스패치(dispatch)`라고 한다.

- `실행 상태(running)`  
  : 실행 상태는 CPU를 할당받아 실행 중인 상태, 일정 시간 동안만 CPU를 사용할 수 있다.  
  타이머 인터럽트 발생 => 준비 상태로 전환 / 입출력장치 사용 => 대기 상태로 전환

- `대기 상태(blocked)`  
  : 프로세스가 입출력 작업을 요청하거나 바로 확보할 수 없는 자원을 요청하는 등 곧장 실행이 불가능한 조건
  에 놓이는 경우 대기 상태로 전환.  
  대기 상태였던 해당 프로세스는 입출력 작업이 완료되는 등 실행 가능한 상태가 되면 다시 준비 상태가 되어 CPU 할당을 기다린다.

  `+ 블로킹 입출력과 논블로킹 입출력`  
   프로세스가 실행 도중 입출력 작업을 수행해야 하는 경우,
  (1) `블로킹 입출력(blocking I/O)` : 입출력 작업이 완료되면 대기 -> 준비 상태로 전환하여 실행을 재개

  (2) `논블로킹 입출력(non-blocking I/O)` : 입출력장치에게 입출력 작업을 맡긴 뒤, 곧바로 이어질 명령어를 실행

- `종료 상태(terminated)`  
  : 종료 상태는 프로세스가 종료된 상태  
  프로세스가 종료되면 운영체제는 PCB와 프로세스가 사용한 메모리를 정리

### 멀티프로세스와 멀티스레드

`멀티프로세스(multi-process)`

- 동시에 여러 프로세스가 실행되는 것 (e.g. 웹 브라우저)
- 각각의 프로세스들은 기본적으로 <u>자원을 공유하지 않고</u> 독립적으로 실행된다.  
  => 각각의 PID(프로세스 ID) 값이 다르고, 프로세스별로 자원이 독립적으로 할당되어 다른 프로세스에 영향 X

`멀티스레드(multi-thread)`

- 프로세스를 동시에 실행하는 여러 스레드
- 각각의 스레드는 스레드를 식별할 수 있는 고유 정보인 스레드 ID와 프로그램 카운터, 레지스터 값, 스택 등으로 구성 => 스레드마다 다음에 실행할 주소를 가질 수 있고, 연산 과정의 임시 저장 값을 가질 수 있다.
- <u>같은 프로세스를 실행하는 여러 스레드들은 프로세스의 자원을 공유</u>한다.  
  => 멀티스레드 환경에서는 한 스레드에 생긴 문제가 프로세스 전체의 문제가 될 수 있다.

`스레드 조인(thread join)`
: join은 스레드를 생성한 주체가 ‘생성/실행된 스레드가 종료될 때까지 대기’해야 함

e.g. ‘main’ 스레드가 ‘a’ 스레드를 생성할 때 join을 호출  
=> ‘main’ 스레드는 생성한 ‘a’ 스레드가 종료될 때까지 실행되지 않고 대기

### 프로세스 간 통신

`프로세스 간 통신(IPC, Inter-Process Communication)`

- 프로세스는 기본적으로 자원을 공유하지 않지만, 프로세스 간에도 자원을 공유하고 데이터를 주고
  받을 수 있는 방법이 있다.

  - `(1)` `공유 메모리shared memory`

    - 프로세스 간에 공유하는 메모리 영역을 토대로 데이터를 주고받는 통신 방식
    - 공유 메모리라는 특별한 메모리 공간을 할당하여 프로세스가 해당 메모리 공간을 공유하여  
      통신을 주고받는 각 프로세스가 마치 자신의 메모리 영역을 읽고 쓰는 것처럼 통신한다.
    - 프로세스가 데이터를 주고받는 과정에 커널의 개입이 거의 없다.
    - 통신 속도가 빠르나 데이터의 일관성 훼손 가능(레이스 컨디션)

  - `(2)` `메시지 전달`

    - 메시지 전달은 프로세스 간에 주고받을 데이터가 커널을 거쳐 송수신되는 통신 방식
    - 메시지를 보내는 수단과 받는 수단이 명확하게 구분되어 있다.
    - 통신 속도가 느리나 레이스 컨디션 고려 덜 해도 된다.
    - 대표적인 수단 : 파이프, 시그널, 소켓, 원격 프로시저 호출(RPC)
      - `파이프(pipe)`란 단방향 프로세스 간의 통신 도구(데이터가 흐를 수 있는 공간)  
         `익명 파이프(unnamed pipe)` : 단방향 통신 수단인 전통적인 파이프, 부모 프로세스와 자식 프로세스 간에만 통신이 가능
        `지명 파이프(named pipe)` : 양방향 통신을 지원하며, 부모 프로세스와 자식 프로세스 뿐만 아니라 임의의 프로세스 간에도 사용 가능

  - `(3)` `시그널(signal)` : 프로세스에게 특정 이벤트(event)가 발생했음을 알리는 비동기적인 신호

    - 프로세스는 시그널이 발생하면 여느 인터럽트 처리 과정과 유사하게 하던 일을 잠시 중단하고, 시그
      널 처리를 위한 `시그널 핸들러(signal handler)`를 실행한 뒤 실행을 재개합니다.  
      이때 프로세스는 직접 특정 시그널을 발생 및 일부 시그널 핸들러를 (재)정의 가능하다.
      => 시그널이 발생했을 때의 동작을 정의하여 프로세스에게 해당 시그널을 보냄으로써 프로세스 간 통신을 수행할 수 있다.
    - 시그널을 이용하는 방법은 앞선 IPC 기법들과 다르게 직접적으로 메시지를 주고받지는 않지만, 비
      동기적으로 원하는 동작을 수행할 수 있는 좋은 수단임

    - 시그널의 기본 동작은 대부분 프로세스를 종료하거나 무시하거나 코어 덤프 생성
    - `코어 덤프(core dump)` : 주로 비정상적으로 종료하는 경우에 생성되는 파일, 프로그램이 특정 시점에 작업하던 메모리 상태가 기록되어 있다.

  - 그 외 : 원격 프로시저 호출(RPC), 네트워크 소켓

## 3. 동기화와 교착 상태

### 간단한 용어 정리

- `공유 자원(shared resource)` : 프로세스 혹은 스레드가 공유하는 자원

- `임계 구역(critical section)` : 공유 자원에 접근하는 코드 중 동시에 실행했을 때 문제가 발생할 수 있는 코드  
   => 동시에 실행되는 프로세스나 스레드가 동시에 임계 구역에 진입하여 실행되면 문제가 발생할 수 있습니다

- `레이스 컨디션(race condition)` : 프로세스 혹은 스레드가 동시에 임계 구역의 코드를 실행하여 문제가 발생하는 상황  
   자원의 일관성이 손상될 수 있기 때문에 2개 이상의 프로세스 혹은 스레드가 임계 영역에 진입하고자 한다면 둘 중 하나는 작업이 끝날 때까지 대기해야 한다.

레이스 컨디션을 방지하면서 임계 구역을 관리하기 위해서는 프로세스와 스레드가 동기화되어야 합
니다.

### 동기화

`프로세스와 스레드의 동기화(synchronization)`란 다음의 2가지 조건을 준수하며 실행하는 것을 의미한다.

- `실행 순서 제어` : 프로세스 및 스레드를 올바른 순서로 실행하기  
  e.g. 쓰고 읽어야하는데 반대로 수행
- `상호 배제` : 동시에 접근해서는 안 되는 자원에 하나의 프로세스 및 스레드만 접근하기  
  e.g. 두 프로세스 모두 동일한 공유자원을 수정

### 동기화 기법

`1. 뮤텍스 락(mutex lock)`

- 동시에 접근해서는 안 되는 자원에 동시 접근이 불가능하도록 상호 배제를 보장하는 동기화 도구
- 하나의 공유 자원을 고려하는 동기화 도구
  `임계 구역에 접근하고자 한다면 반드시 락(lock)을 획득(acquire)해야 하고, 임계 구역에서의 작업이 끝났다면 락을 해제(release)해야 한다.`
- 프로세스 및 스레드가 공유하는 변수(lock)와 2개의 함수(acquire, release)로 구현

  - 변수 `lock` : 프로세스 및 스레드가 공유하는 변수
  - 함수 `acquire()` : 락을 획득하기 위한 함수로, 특정 락에 대해 한 번만 호출이 가능한 함수  
    (다른 곳에서 해제하기 전까지는 사용 X)
  - 함수 `release()` : 획득한 락을 해제하기 위한 함수

  > 1. lock.acquire()을 호출하여 임계 구역에 진입 (다른 프로세스 및 스레드는 락이 해제될 때까지 기다려야 한다.)
  > 2. 임계 구역의 작업이 끝나면 락을 해제하기 위해 lock.release()를 호출
  > 3. 임계 구역 앞에서 대기하는 프로세스 혹은 스레드가 있다면 해제된 락을 획득하고(lock.acquire() 호출에 성공하고) 임계 구역에 진입

`2. 세마포(semaphore)`

- 여러 개의 공유 자원이 있는 상황에서도 동기화 가능
- 다음과 같은 하나의 변수와 2개의 함수로 구성

  - 변수 `S`: 사용 가능한 공유 자원의 개수를 나타내는 변수 (+ 대기중인 프로세스 및 스레드가 몇개인지도 나타냄)
    공유 자원의 개수가 S개 => 임계 구역에 진입하여 동시에 실행 가능한 프로세스 혹은 스레드도 S개
  - 함수 `wait()`: 임계 구역 진입 전 호출하는 함수
  - 함수 `signal()`: 임계 구역 진입 후 호출하는 함수

  > 1. `wait()`을 호출하면 s = s-1
  >    s >= 0 이면 임계 구역 진입, s < 0 이면 대기 큐에 삽입
  > 2. `signal()`을 호출하면 s = s + 1
  >    s >= 0 이면 대기 상태로 접어든 프로세스 중 하나를 준비 상태로 전환

  ***

  `e.g.`  
   (1) 프로세스 P1 wait() 호출, S를 1 감소시키면 S = 1이므로 임계 구역 진입  
   (2) 프로세스 P2 wait() 호출, S를 1 감소시키면 S = 0이므로 임계 구역 진입  
   (3) 프로세스 P3 wait() 호출, S를 1 감소시키면 S = -1이므로 대기 상태로 전환  
   (4) 프로세스 P1 임계 구역 작업 종료. signal() 호출, S를 1 증가시키면 S = 0이므로 대기 상태였던 P3을 준비 상태로 전환  
   (5) 깨어난 프로세스 P3 임계 구역 진입  
   (6) 프로세스 P2 임계 구역 작업 종료. signal() 호출, S를 1 증가시키면 S = 1  
   (7) 프로세스 P3 임계 구역 작업 종료. signal() 호출, S를 1 증가시키면 S = 2

  ***

  - 이진 세마포와 카운팅 세마포  
    공유 자원이 1개이면 `이진 세마포(binary semaphore)` : S가 0과 1의 값을 가지는 세마포
    공유 자원이 2개 이상이면 `카운팅 세마포(counting semaphore)`

  - 여기서의 자원이란 무엇일까?

    | 상황         | 자원의 의미       | 세마포 S 값 | S의 역할                       |
    | ------------ | ----------------- | ----------- | ------------------------------ |
    | 프린터 1대   | 물리 장비 1개     | 1           | 동시에 한 프로세스만 접근 가능 |
    | DB 커넥션 풀 | 커넥션 10개       | 10          | 최대 10개 동시 연결 허용       |
    | 화장실       | 칸 3개            | 3           | 3명까지 동시 입장 가능         |
    | 작업 스레드  | 작업 슬롯 20개    | 20          | 최대 20개 동시 작업 허용       |
    | 다운로드     | 동시 접속 허용 수 | 5           | 최대 5명 동시 다운로드         |

`3. 모니터`

- `조건 변수(condition variable)`란 실행 순서 제어를 위한 동기화 도구, 특정 조건 하에 프로세스를 실행/일시 중단함으로써 프로세스나 스레드의 실행 순서를 제어할 수 있다.
- 조건 변수에 대해 wait()와 signal() 함수를 호출할 수 있다.
  - 함수 `wait()` : 호출한 프로세스 및 스레드의 상태를 대기 상태로 전환하는 함수
  - 함수 `signal()` : wait()로 일시 중지된 프로세스 및 스레드의 실행 재개하는 함수
    > - 아직 특정 프로세스가 실행될 조건이 되지 않았을 때는 wait()를 통해 실행을 중단한다.
    > - 특정 프로세스가 실행될 조건이 충족되었을 때는 signal()을 통해 실행을 재개한다

---

- `모니터(monitor)` : 공유 자원과 그 공유 자원을 다루는 함수(인터페이스)로 구성된 동기화 도구  
  상호 배제를 위한 동기화뿐만 아니라 <u>실행 순서 제어를 위한 동기화</u>까지 가능

- 모니터의 작동원리  
   프로세스 및 스레드는 공유 자원에 접근하기 위해 반드시 정해진 공유 자원 연산(인터페이스)을 통해 모니터 내로 진입해야 하고, 모니터 안에 진입하여 실행되는 프로세스 및 스레드는 항상 하나여야 합니다. 이미 모니터 내로 진입하여 실행 중인 프로세스 및 스레드가 있다면 큐에서 대기해야 한다.

  e.g. 프로세스 A, B 중 반드시 A가 먼저 실행되고, 다음으로 B가 실행되어야 한다
  => 프로세스 B는 모니터 내에서 실행되기에 앞서 프로세스 A의 실행이 끝났는지를 검사  
   if (프로세스 A 완료) => 모니터 진입
  else => wait() , B는 큐에서 대기
  이후에 signal() 호출하면 대기하던 B가 실행

`스레드 안전`

- `스레드 안전(thread safety)` : 멀티스레드 환경에서 어떤 변수나 함수, 객체에 동시 접근이 이루어져도 실행에 문제가 없는 상태
  레이스 컨디션이 발생했다면 이는 스레드 안전하지 않은 상황인 것이죠. 반대로 어떤 함수가 스레드 안전하다면, 이는
  여러 스레드에 의해 호출되어도 레이스 컨디션이 발생하지 않는 것을 의미합니다

### 교착 상태(deadlock)

- 일어나지 않을 사건을 기다리며 프로세스의 진행이 멈춰 버리는 현상
- 교착 상태의 발생조건

  - `상호 배제`  
    교착 상태가 발생하는 근본적인 원인은 한 번에 하나의 프로세스만 해당 자원을 이용 가능했기 때문 즉, 한 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없는 상호 배제의 상황에서 교착 상태가 발생할 수 있다.
  - `점유와 대기(hold and wait)`
    한 프로세스가 어떤 자원을 할당받은 상태(점유)에서 다른 자원 할당받기를 기다린다면(대기) 교착 상태가 발생할 수 있다
  - `비선점`  
    자원이 비선점되었다 == 해당 자원을 이용하는 프로세스의 작업이 끝나야만 비로소 자원을 이용할 수 있다.
    => 어떤 프로세스도 다른 프로세스의 자원을 강제로 빼앗지 못함
  - `원형 대기`  
    각각의 프로세스가 서로 점유한 자원을 할당받기 위해 원의 형태로 대기할 경우 교착 상태가 발생할 수 있다

- 교착 상태 해결 방법
  - 교착 상태 `예방`  
    : 교착 상태 발생 필요 조건 중 하나를 충족하지 못하게 하는 방법  
    프로세스에 자원을 할당할 때 상호 배제, 점유와 대기, 비선점, 원형 대기 중 하나라도 만족하지 않으면 교착 상태가 발생하지 않기 때문이다.  
    점유와 대기 => 한 프로세스에 필요한 자원들을 몰아 주고, 그 다음에 다른 프로세스에 필요한 자원을 몰아주기  
    원형 대기 => 할당 가능한 모든 자원에 번호를 매기고 오름차순으로 할당
  - 교착 상태 `회피`  
    : 교착 상태가 발생하지 않을 정도로만 조심하면서 자원을 할당하는 방법  
    <u>교착 상태 = 한정된 자원의 무분별한 할당으로 인해 발생하는 문제로 간주</u>  
    프로세스에 할당할 수 있는 자원이 충분한 상황에서 프로세스들이 한두 개의 적은 자원만을 요구하기  
    e.g. 은행원 알고리즘(banker’s algorithm)
  - 교착 상태 `검출 후 회복`  
    : 상태의 발생을 인정하고 처리하는 사후 조치  
    운영체제는 프로세스가 자원을 요구할 때마다 그때 그때 자원을 할당하고 주기적으로 교착 상태의 발생 여부를 검사, 교착 상태가 검출 시 자원 선점을 통해 회복시키거나, 프로세스를 강제 종료함으로써 회복한다.  
    (자원 선점을 통한 회복 : 교착 상태가 해결될 때까지 다른 프로세스로부터 강제로 자원을 빼앗아 한 프로세스에 몰아서 할당)

## 4. CPU 스케줄링

`CPU 스케줄링(CPU scheduling)` 이란 운영체제가 프로세스와 스레드에 CPU의 사용을 배분하는 방법이다. `CPU 스케줄러(CPU scheduler)`가 CPU 스케줄링 알고리즘을 결정하고 수행한다.

### 우선순위

- 모든 프로세스는 CPU의 자원을 필요로 하기 때문에 운영체제는 CPU의 자원을 단순히 순차적으로 할당하는 것이 아닌, 프로세스별로 우선순위(priority)를 판단하여 PCB에 명시하고, 이에 맞추어 CPU의 자원을 적절하게 할당한다.

- `CPU 활용률(CPU utilization)` : 전체 CPU의 가동 시간 중 작업을 처리하는 시간의 비율  
   운영체제는 가급적 CPU 활용률을 높게 유지할 수 있도록 우선순위를 할당한다.

- 운영체제는 높은 CPU 활용률을 유지하기 위해 기본적으로 입출력 작업이 많은 프로세스의 우선순위를 높게 유지합니다.

대부분의 프로세스들은 CPU와 입출력장치를 모두 사용해 실행과 대기 상태를 오가며 실행된다.

`CPU 버스트(CPU burst)` : 프로세스가 CPU를 이용하는 작업
=> `CPU 집중 프로세스(CPU bound process)` : CPU 작업이 많은 프로세스, 실행 상태에 더 많이 머무른다.

`입출력 버스트(I/O burst)` : 프로세스가 출력장치를 기다리는 작업
=> `입출력 집중 프로세스(I/O bound process)` : 입출력 작업이 많은 프로세스, 대기 상태에 더 많이 머무른다.

<u>모든 프로세스가 동일한 시간의 빈도로 CPU를 사용하는 것은 합리적이지 않다!!</u>
입출력장치가 입출력 작업을 완료하기 전까지 입출력 집중 프로세는 어차피 대기 상태가 될 것이므로 얼른 입출력 집중 프로세스를 먼저 처리해 버리면 그 이후에 다른 프로세스를 실행시켜 CPU 활용률을 높일 수 있다.그래서 <u>입출력 집중 프로세스는 일반적으로 CPU 집중 프로세스보다 우선순위가 높다.</u>

### 스케줄링 큐

- 운영체제는 처리할 프로세스의 순서를 `스케줄링 큐(scheduling queue)`를 통해 구현한다.
- CPU를 이용하고 싶은 프로세스의 PCB와 메모리로 적재되고 싶은 프로세스의 PCB, 특정 입출력장치를 이용하고 싶은 프로세스의 PCB를 큐에 삽입
  - `준비 큐(ready queue)` : CPU를 이용하고 싶은 프로세스의 PCB가 서는 줄
  - `대기 큐(waiting queue)` : 대기 상태에 접어든 프로세스의 PCB가 서는 줄, 입출력장치마다 대기 큐가 존재
    운영체제는 큐에 삽입된 순서대로 실행하되, 우선순위가 높은 프로세스부터 먼저 실행한다.
    같은 입출력장치를 요구한 프로세스들은 같은 대기 큐에서 기다린다.
    완료 인터럽트 발생시 운영체제는 대기 큐에서 작업이 완료된 PCB를 찾고, 이 PCB를 준비 상태로 변경한 뒤 큐에서 제거하고 준비 큐로 이동한다.

### 선점형 스케줄링과 비선점형 스케줄링

| 항목                     | `선점형 스케줄링(preemptive scheduling)`                                  | `비선점형 스케줄링(non-preemptive scheduling)`                         |
| ------------------------ | ------------------------------------------------------------------------- | ---------------------------------------------------------------------- |
| **정의**                 | 실행 중인 프로세스를 강제로 중단하고 다른 프로세스로 CPU를 할당할 수 있음 | 한 번 CPU를 할당받은 프로세스는 스스로 CPU를 반납할 때까지 계속 실행됨 |
| **CPU 제어권 회수 시점** | 타이머 인터럽트, 우선순위 높은 프로세스 도착 등                           | 프로세스가 종료되거나 대기 상태로 전환될 때만                          |
| **응답 시간**            | 일반적으로 더 짧음 (대기 시간이 고르게 분산됨)                            | 응답 시간이 길어질 수 있음                                             |
| **공정성(Fairness)**     | 비교적 공정하게 CPU 분배 가능                                             | 긴 프로세스가 CPU를 독점할 수 있음 (기아 현상 발생 가능)               |
| **문맥 교환(오버헤드)**  | 빈번한 문맥 교환 발생 → 오버헤드 큼                                       | 문맥 교환 횟수 적음 → 오버헤드 작음                                    |
| **사용 예시**            | 실시간 시스템, 멀티태스킹 운영체제(Windows, Linux 등)                     | 단순한 작업 순차 처리 시스템, 배치 처리 시스템 등                      |
| **대표 알고리즘**        | 라운드 로빈(Round Robin), SRTF, 우선순위 기반(선점형) 등                  | FCFS, SJF, 우선순위 기반(비선점형) 등                                  |

### CPU 스케줄링 알고리즘

`비선점형 스케줄링(non-preemptive scheduling)`

운영체제가 프로세스에 CPU를 배분하는 방법은 CPU 스케줄링 알고리즘이라고 합니다. CPU 스케
줄링 알고리즘의 종류는 매우 다양한데요. 우선 많은 전공 서적에서 대표적으로 소개하는 7가지 CPU
스케줄링 알고리즘에 대해 알아보고, 실제 운영체제(리눅스)의 CPU 스케줄링을 간략하게 살펴보
겠습니다. 책에서는 대표적인 스케줄링 알고리즘을 '전통적 스케줄링 알고리즘'이라고 명명했습니다.
각각의 스케줄링 알고리즘들의 작동 방식과 장단점을 이해하는 데 집중하며 읽어 보길 바랍니다.

- `FCFS(선입 선처리, First Come First Served)`

  - <u>준비 큐에 삽입된 순서대로</u> 먼저 CPU를 요청한 프로세스부터 CPU를 할당하는 스케줄링 방식
  - 먼저 삽입된 프로세스의 오랜 실행 시간으로 인해 나중에 삽입된 프로세스의 실행이 지연되는 문제를 `호위 효과(convoy effect)` 발생 가능

- `SJF(최단 작업 우선, Shortest Job First)`

  - 준비 큐에 삽입된 프로세스 중 <u>CPU를 이용하는 시간의 길이가 가장 짧은</u> 프로세스부터 먼저 실행하는 스케줄링 방식
  - 비선점형 스케줄링 알고리즘으로 분류되지만, '최소 잔여 시간 우선 스케줄링'처럼 선점형으로 구현될 수도 있다.

- `라운드 로빈(round robin)`

  - `FCFS` + `타임 슬라이스(time slice, 프로세스가 CPU를 사용하도록 정해진 시간)`
  - 큐에 삽입된 프로세스들이 삽입된 순서대로 CPU를 이용하되, 정해진 타임 슬라이스만큼만 CPU를 이용하는 선점형 스케줄링, 프로세스가 정해진 시간을 모두 사용하고도 완료되지 않으면 문맥 교환이 발생해 다시 큐의 맨 뒤에 삽입된다.

- `SRT(최소 잔여 시간 우선, Shortest Remaining Time)`

  - `SJF` + `Round robin`
  - 프로세스로 하여금 정해진 타임 슬라이스만큼 CPU를 이용하되, 남아 있는 작업시간이 가장 적은 프로세스를 다음으로 CPU를 이용할 프로세스로 선택한다.

- `우선순위(priority)`

  - 프로세스에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 방식
  - 우선순위가 높은 프로세스로 인해 우선순위가 낮은 프로세스의 실행이 연기되는 `아사 현상(starvation)`을 방지하기 위해 `에이징(aging, 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식)` 기법 사용

- `다단계 큐(multilevel queue)`

  - 우선순위 스케줄링의 발전된 형태로, 우선순위별로 여러 개의 준비 큐를 사용하는 스케줄링 방식
    우선순위가 가장 높은 큐부터 순차적으로 프로세스 처리한다.
  - 우선순위가 낮은 큐의 프로세스에 아사 현상 발생할 수 있다.

- `다단계 피드백 큐(multilevel feedback queue)`
  - `다단계 큐` + 프로세스들이 큐 사이를 이동 가능
  - 우선순위가 가장 높은 우선순위 큐에 삽입된 프로세스는 타임 슬라이스 동안 실행되며, 해당 큐에서 프로세스의 실행이 끝나지 않으면 <u>다음 우선순위 큐에 삽입</u>되어 실행
  - 에이징 기법 적용할 수도 있음

### 리눅스 CPU 스케줄링

실제 운영체제에서는 프로세스의 가중치에 따라 타임 슬라이스를 달리 할당받을 수도 있다.
실제 리눅스 운영체제의 CPU 스케줄링을 살펴보자.

`리눅스 운영체제의 스케줄링 정책(scheduling policy)`

- 스케줄링 정책은 새로운 프로세스를 언제 어떻게 선택하여 실행할지를 결정하기 위한 규칙의 집합

| **스케줄링 정책** | **적용 상황 (설명)**                                                                            |
| ----------------- | ----------------------------------------------------------------------------------------------- |
| `SCHED_FIFO`      | **실시간** 스케줄링 정책. 우선순위 기반 **비선점형**. 우선순위가 높은 프로세스가 선점.          |
| `SCHED_RR`        | **실시간** 정책. `SCHED_FIFO`와 유사하지만 **라운드 로빈 방식**으로 **선점형**.                 |
| `SCHED_OTHER`     | **기본 정책 (CFS - Completely Fair Scheduler)**. 일반적인 **비실시간** 프로세스에 적용.         |
| `SCHED_BATCH`     | **배치 작업용 정책**. 사용자와의 인터랙션이 적고, CPU 사용량이 높은 프로세스에 적합.            |
| `SCHED_IDLE`      | **가장 낮은 우선순위**. 시스템이 유휴 상태일 때만 실행. 백그라운드에서 실행되는 작업 등에 사용. |

이들 중 일반적으로 가장 자주 언급되는 정책인 FIFO, RR, NORMAL 위주로 살펴보겠습니다.

- `SCHED_FIFO(First-In-First-Out)`와 `SCHED_RR(Round Robin)`  
  RTReal-Time 스케줄러에 의해 이뤄지는 스케줄링입니다.  
  실시간성이 강조된 프로세스(실시간 프로세스)에 적용되는 스케줄링 정책입니다.

- `SCHED_NORMAL`
- 일반적인 프로세스에 적용되는 스케줄링 정책
- `CFS(Completely Fair Scheduler)` : 프로세스에 대해 '완전히 공평한 CPU 시간 배분'을 지향하는 CPU 스케줄러
  리눅스에서는 프로세스마다 `가상 실행 시간(vruntime, virtual runtime)`이라는 정보를 유지하는데, CFS는 이 vruntime이 가장 작은 프로세스부터 스케줄링한다.
- vruntime은 프로세스가 '실제로 실행된 시간(runtime)'이 아닌, 프로세스의 '가중치(weight, 프로세스의 우선순위와 연관된 값으로, 프로세스의 우선순위가 높아질수록 가중치도 높아진다)'를 고려한 가상의 실행 시간
  => 프로세스의 가중치가 높아질수록 vruntime이 천천히 증가, 따라서 프로세스의 가중치가 높을수록 먼저 스케줄링될 확률이 높다.

CFS로 스케줄링되는 프로세스들의 타임 슬라이스는 다음 수식과 같이 프로세스의 가중치에 따라
결정됩니다. 역시 수식을 암기할 필요는 없습니다. 프로세스의 우선순위가 높아질수록 가중치도 높
아진다고 설명했죠. 수식을 살펴보면 알 수 있듯, 프로세스의 가중치가 높아지면 타임 슬라이스도
크게 할당받을 수 있습니다

vruntime과 가중치는 리눅스 운영체제에서 '/proc/< PID>/sched'라는 파일을 출력하는 명령어
를 통해 확인할 수 있습니다. 가령 다음 명령어의 결과는 PID가 '34913'인 프로세스의 vruntime,
가중치 등을 나타냅니다.

> 커널(CFS 스케줄러)은 수많은 프로세스 중 vruntime이 가장 작은 프로세스를 빠르게 선별하기 위해 RB 트리를 사용한다.

## :bulb: 면접 예상 질문

<div style="font-family: sans-serif; line-height: 1.6;">
  <details>
    <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">공유 메모리 기반 IPC가 소켓 통신보다 빠른 이유를 설명해 보세요.</strong></summary>
    <p><strong style="color: #999;">A.</strong> 공유 메모리는 동일한 메모리 공간에 직접 접근하여 데이터를 주고받고, 마치 자신의 메모리 공간을 읽고 쓰는 것처럼 IPC가 이루어지기 때문에 빠릅니다. 이에 반해 소켓 통신은 주고받는 데이터가 커널을 통하므로 추가적인 오버헤드가 발생할 수 있어, 공유 메모리 기반 IPC보다 다소 느릴 수 있습니다.</p>
  </details>
  <details>
    <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">운영체제의 커널이 무엇이며, 커널이 왜 존재하는지에 대해 설명해 보세요.</strong></summary>
    <p><strong style="color: #999;">A.</strong>커널은 운영체제의 핵심 부분으로, 컴퓨터 하드웨어와 응용 프로그램 간의 중재자 역할을 합니다. 커널은 프로세스와 스레드가 올바르게 실행되도록 돕고, 이들이 CPU, 메모리, 보조기억장치 등의 하드웨어를 공정하게 할당받아 실행되도록 합니다. 또 커널은 이중 모드를 운영해 사용자 응용 프로그램이 안전하고 효율적으로 시스템 자원을 사용할 수 있도록 합니다.</p>
  </details>
  <details>
    <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">스레드 안전하지 않은 메서드를 동기화하지 않으면 어떤 문제가 생길 수 있나요?</strong></summary>
    <p><strong style="color: #999;">A.</strong>여러 스레드가 동시에 실행될 경우 레이스 컨디션이 발생하여 데이터의 일관성이 깨질 수 있습니다. 따라서 추가적인 동기화 도구를 적용하거나, 스레드 안전한 메서드를 사용해야 합니다.</p>
  </details>
  <details>
    <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">지나치게 문맥 교환이 반복되면 어떤 문제가 발생할 수 있나요?</strong></summary>
    <p><strong style="color: #999;">A.</strong> 빈번한 문맥 교환은 실제 작업보다 문맥 저장과 복구에 CPU 시간을 사용하게 되므로 효율성을 떨어뜨립니다. 또한 캐시 메모리의 데이터를 반복적으로 무효화하게 되므로 캐시 미스율이 증가하고, 캐시 미스와 문맥 교환 오버헤드로 인한 전체 시스템의 처리 속도가 저하될 수 있습니다.</p>
  </details>
   <details>
   <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">운영체제란 무엇인가요?</strong></summary>
   <p><strong style="color: #999;">A.</strong>운영체제는 사용자와 하드웨어 사이에서 자원을 효율적으로 관리하고, 여러 프로그램에 공통된 서비스를 제공하는 시스템 소프트웨어입니다. 핵심 기능으로는 자원 할당 및 관리, 프로세스와 스레드 관리가 있습니다.</p>
</details>
 <details>
   <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">프로세스와 스레드의 차이는 무엇인가요?</strong></summary> 
   <p><strong style="color: #999;">A.</strong>프로세스는 실행 중인 프로그램의 인스턴스이며, 독립적인 자원을 가집니다. 스레드는 프로세스 내에서 실행되는 가장 작은 단위로, 같은 프로세스의 자원을 공유합니다. 즉, 프로세스는 자원 단위, 스레드는 실행 단위입니다.</p>
 </details>
 <details>
   <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">시스템 콜이란 무엇이고 어떻게 작동하나요?</strong></summary> 
   <p><strong style="color: #999;">A.</strong>시스템 콜은 사용자 프로그램이 운영체제의 기능을 사용하기 위한 인터페이스입니다. 사용자 영역에서 시스템 콜을 호출하면 커널 모드로 전환되어 운영체제가 자원을 할당하거나 작업을 처리하고, 결과를 반환한 뒤 다시 사용자 모드로 돌아옵니다.</p>
 </details>
 <details>
   <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">문맥 교환(Context Switching)이란 무엇인가요?</strong></summary> 
   <p><strong style="color: #999;">A.</strong>문맥 교환은 CPU가 현재 실행 중인 프로세스의 상태(context)를 PCB에 저장하고, 다른 프로세스의 context를 복구하여 실행을 전환하는 과정입니다. 이 과정은 타이머 인터럽트나 입출력 대기 등에 의해 발생합니다.</p>
 </details>
 <details>
   <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">프로세스의 상태는 어떻게 전이되나요?</strong></summary> 
   <p><strong style="color: #999;">A.</strong>프로세스는 생성(new) → 준비(ready) → 실행(running) → 대기(blocked) → 종료(terminated) 상태를 가집니다. CPU를 받으면 실행 상태가 되고, 입출력 요청 시 대기 상태로, 시간이 초과되면 다시 준비 상태로 전환됩니다.</p>
 </details>
 <details>
   <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">프로세스 간 통신(IPC)의 방법은 무엇이 있나요?</strong></summary> 
   <p><strong style="color: #999;">A.</strong>대표적으로 공유 메모리, 메시지 전달(파이프, 소켓 등), 시그널 방식이 있습니다. 공유 메모리는 빠르지만 동기화가 필요하고, 메시지 전달은 속도는 느리지만 안전하며, 시그널은 비동기적 알림 방식입니다.</p>
 </details>
 <details>
   <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">임계 구역과 레이스 컨디션이란 무엇인가요?</strong></summary> 
   <p><strong style="color: #999;">A.</strong>임계 구역은 공유 자원에 접근하는 코드 영역이며, 레이스 컨디션은 여러 스레드가 동시에 임계 구역에 진입해 데이터 일관성이 깨지는 현상입니다. 이를 막기 위해 동기화 기법이 필요합니다.</p>
 </details>
 <details>
   <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">뮤텍스와 세마포의 차이는 무엇인가요?</strong></summary> 
   <p><strong style="color: #999;">A.</strong>뮤텍스는 1개의 공유 자원에 대한 상호 배제를 보장하는 락 개념이며, 세마포는 여러 개의 자원 수를 관리할 수 있는 변수 기반 동기화 기법입니다. 세마포는 이진(0/1) 또는 카운팅(여러 개) 형태로 사용됩니다.</p>
 </details>
 <details>
   <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">세마포의 S 값이 음수가 되는 의미는 무엇인가요?</strong></summary> 
   <p><strong style="color: #999;">A.</strong>S가 음수라는 것은 현재 대기 큐에 있는 프로세스(또는 스레드)의 개수를 의미합니다. 즉, 사용 가능한 자원은 없고, 그만큼의 프로세스가 기다리고 있다는 뜻입니다.</p>
 </details>
 <details>
   <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">교착 상태가 발생하는 4가지 조건은 무엇인가요?</strong></summary> 
   <p><strong style="color: #999;">A.</strong>① 상호 배제, ② 점유와 대기, ③ 비선점, ④ 원형 대기입니다. 이 네 가지 조건이 모두 만족될 때 교착 상태가 발생합니다.</p>
 </details>
 <details>
   <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">교착 상태를 해결하는 방법은 무엇인가요?</strong></summary> 
   <p><strong style="color: #999;">A.</strong>예방(필요조건 중 하나를 제거), 회피(은행원 알고리즘 등), 검출 후 회복(자원 회수나 프로세스 강제 종료) 등이 있습니다.</p>
 </details>
 <details>
   <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">스레드 안전(Thread Safety)이란 무엇인가요?</strong></summary> 
   <p><strong style="color: #999;">A.</strong>멀티스레드 환경에서 동시에 자원에 접근해도 문제가 발생하지 않도록 하는 설계입니다. 스레드 안전한 함수는 레이스 컨디션 없이 동작합니다.</p>
 </details>
 <details>
   <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">모니터와 조건 변수의 관계는?</strong></summary> 
   <p><strong style="color: #999;">A.</strong>모니터는 공유 자원과 이를 다루는 함수, 조건 변수로 구성됩니다. 조건 변수는 wait()와 signal()로 실행 순서를 제어하며, 모니터 내부에서 하나의 프로세스만 실행되도록 상호 배제도 보장합니다.</p>
 </details>
 </div>
