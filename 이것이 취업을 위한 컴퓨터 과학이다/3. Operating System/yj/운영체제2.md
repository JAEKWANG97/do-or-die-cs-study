# 📌 Part 4. CPU 스케줄링

### 1) 개념

* CPU 스케줄링은 **여러 프로세스가 동시에 CPU를 요구할 때 CPU를 누구에게 줄지 결정하는 알고리즘**

  1. **CPU 이용률 최대화** (CPU가 쉬는 시간을 최소화)
  2. **처리량(Throughput) 증가** (단위 시간당 처리된 프로세스 수)
  3. **대기 시간/응답 시간 최소화**
  4. **공정성(Fairness) 보장**

### 2) 스케줄링 시점

* **장기 스케줄링** : 어떤 작업(Job)을 메모리에 올려 프로세스로 만들지 결정.
* **중기 스케줄링** : 메모리에서 일부 프로세스를 디스크로 내보내는 Swapping.
* **단기 스케줄링** : Ready Queue에서 어떤 프로세스에 CPU를 줄지 결정.

### 3) 스케줄링 방식

* **비선점형 (Non-preemptive)**

  * CPU를 잡은 프로세스는 자발적으로 종료하거나 대기할 때까지 CPU를 뺏기지 않음.
  * **FCFS** (First Come First Served): 도착 순. 단점은 Convoy Effect 발생.
  * **SJF** (Shortest Job First): CPU burst가 가장 짧은 프로세스 먼저. 평균 대기 시간 최소.

* **선점형 (Preemptive)**

  * 다른 프로세스가 더 높은 우선순위를 가지면 CPU를 빼앗길 수 있음.
  * **SRTF** (Shortest Remaining Time First): 남은 CPU burst가 가장 짧은 것 선택.
  * **Priority Scheduling**: 우선순위 높은 것 먼저. 단, 기아 현상 가능.
  * **Round Robin (RR)**: Time Quantum 단위로 CPU를 공평하게 나눔. 응답 시간 보장.

* **멀티레벨 큐 (Multi-level Queue)**

  * 프로세스를 성격별로 나눠 큐를 만들고, 각 큐마다 다른 알고리즘 적용.
  * 예: 대화형 → RR, 배치 작업 → FCFS.

* **리눅스 CFS (Completely Fair Scheduler)**

  * 모든 프로세스가 CPU 시간을 가중치에 따라 **공평하게** 배분받도록 설계.
  * “가상의 실행 시간”을 기준으로 가장 적게 실행된 프로세스에게 CPU 배정.

---

# 📌 Part 5. 가상 메모리 (Virtual Memory)

### 1) 개념

* 가상 메모리는 **실제 물리 메모리보다 큰 논리적 메모리 공간**을 제공하는 기법입니다.
* 프로그램은 연속된 메모리를 쓰는 것처럼 보이지만, 실제로는 여러 물리 주소에 나뉘어 저장됩니다.
* 장점:

  * 큰 프로그램 실행 가능
  * 프로세스 간 메모리 보호
  * 다중 프로세스 동시 실행 효율 ↑

### 2) 주소 변환

* CPU가 생성하는 주소 = **논리 주소(Logical Address)**
* 실제 하드웨어 메모리 주소 = **물리 주소(Physical Address)**
* 변환은 \*\*MMU (Memory Management Unit)\*\*가 담당.

### 3) 기법

1. **스와핑 (Swapping)**

   * 프로세스를 통째로 디스크 ↔ 메모리 교체.

2. **페이징 (Paging)**

   * 가상 메모리를 **페이지(Page)** 단위로, 물리 메모리를 **프레임(Frame)** 단위로 나눔.
   * **페이지 테이블**이 가상 주소 → 물리 주소 매핑 관리.
   * 단점: 내부 단편화 가능.

3. **세그멘테이션 (Segmentation)**

   * 프로그램을 논리적 단위(Code, Data, Stack)로 나눔.
   * 장점: 논리적 단위별 보호, 공유 용이.
   * 단점: 외부 단편화 발생.

### 4) 페이지 교체 알고리즘

* **FIFO** : 가장 먼저 들어온 페이지 교체. (Belady’s Anomaly 가능)
* **OPT (Optimal)** : 앞으로 가장 오랫동안 사용하지 않을 페이지 교체. (이론적 최적)
* **LRU (Least Recently Used)** : 가장 오랫동안 사용되지 않은 페이지 교체.
* **Clock Algorithm** : LRU 근사 구현, 하드웨어 지원 필요 X.

---

# 📌 Part 6. 파일 시스템 (File System)

### 1) 개념

* 파일 시스템은 **운영체제가 디스크에 데이터를 저장·관리하는 구조와 메커니즘**.
* **파일**은 단순히 데이터뿐 아니라 속성(메타데이터)을 포함.

### 2) 구성 요소

* **파일(File)** : 이름, 크기, 생성일자, 권한 등 포함.
* **디렉터리(Directory)** : 파일을 그룹화해 계층적 관리.
* **FCB (File Control Block)** : 파일의 메타데이터 저장 구조.

### 3) 파일 접근 방법

* **순차 접근(Sequential Access)** : 앞에서부터 차례대로 읽기.
* **직접 접근(Direct Access)** : 임의의 블록에 바로 접근.

### 4) 파일 시스템 구조

* 계층 구조: **응용 프로그램 → 시스템 콜 → 파일 시스템 → 디스크 드라이버 → 물리 디스크**

### 5) 추가 개념

* **저널링 파일 시스템 (Journaling FS)**

  * 변경 사항을 로그에 먼저 기록 후 반영 → 장애 발생 시 로그 기반 복구 가능.
* **부팅 과정**

  * BIOS/UEFI 실행 → 부트로더(boot loader) 실행 → 커널 로드 → 파일 시스템 마운트.
* **가상화 환경**

  * VM, 컨테이너는 파일 시스템을 논리적으로 격리해 독립 실행 환경 제공.

---

# 📌 면접 질문

1. **CPU 스케줄링에서 비선점형과 선점형의 차이를 설명해보세요.**

   * 선점형은 CPU를 뺏을 수 있고, 비선점형은 CPU를 자발적으로 반납해야 함.

2. **Round Robin 스케줄링의 장점과 단점을 말해보세요.**

   * 응답 시간을 보장하지만, Time Quantum이 너무 크면 FCFS와 비슷해지고 너무 작으면 문맥 전환 비용 증가.

3. **리눅스의 CFS 스케줄러는 어떤 방식으로 공정성을 보장하나요?**

   * 가상의 실행 시간을 기록하여 CPU를 적게 사용한 프로세스에 우선권을 줌.

4. **가상 메모리를 사용하는 이유는 무엇인가요?**

   * 물리 메모리보다 큰 프로그램 실행, 프로세스 간 메모리 보호, 다중 작업 효율 향상.

5. **페이징과 세그멘테이션의 차이를 설명하세요.**

   * 페이징은 고정 크기 단위 분할(내부 단편화), 세그멘테이션은 논리 단위 분할(외부 단편화).

6. **페이지 교체 알고리즘 중 LRU와 FIFO를 비교해보세요.**

   * FIFO는 단순하지만 Belady’s Anomaly 가능, LRU는 실제 사용 패턴 반영하지만 구현 복잡.

7. **파일 시스템에서 저널링(Journaling) 기법은 왜 필요한가요?**

   * 장애 발생 시 데이터 일관성을 유지하고 빠르게 복구 가능.

8. **파일 시스템에서 순차 접근과 직접 접근의 차이를 설명해보세요.**

   * 순차 접근은 앞에서부터 차례대로 읽어야 하고, 직접 접근은 특정 위치로 바로 접근 가능.