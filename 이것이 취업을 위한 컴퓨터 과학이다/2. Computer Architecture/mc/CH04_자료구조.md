# CH04. 자료구조

- [시간복잡도와 공간복잡도](#시간-복잡도와-공간-복잡도)
- [Array](#array)
- [Stack and Queue]()
- [Tree]()
- [Binary Heap]()
- [Red Black Tree]()
- [Hash Table]()
- [Graph]()

## 📌 핵심 개념 요약

### 시간 복잡도와 공간 복잡도

프로그램을 만드는 과정에서 소스 코드를 통해 다양한 데이터를 다루고(자료구조), 그 데이터를 활용해 특정 목적을 이루기 위한 연산(알고리즘)을 구현한다.
이 때에 같은 목적의 코드이더라도 자료구조와 알고리즘을 고려한 코드는 보다 뛰어난 성능을 보일 수 있다.

그렇다면, 그 "성능"은 어떠한 기준으로 판단할까?

이는 "시간 복잡도"와 "공간 복잡도"를 통해 알 수 있다.
"시간 복잡도"란 입력의 크기에 따른 프로그램 실행 시간의 관계를 의미한다.
대중적으로 빅 오 표기법(big O notation)을 사용한다. 빅 오 표기법은 함수의 점근적 상한을 표기하는 방법으로, 입력의 크기 n에 대한 빅 오 표기법은 흔히 실행 시간의 O(상한(n)) 형태로 표현된다.

`O(상한(n)) = 입력하는 n이 점점 증가해 무한대로 커진다고 하더라도 실행 시간이 대략 이 이상(상한)은 커지지 않을 것`

```
빅 오 : 증가율이 상한보다 크지 않다.
빅 세타 : 증가율이 상한과 같다
빅 오메가 : 증가율이 상한보다 작지 않다.
```

문장에서 알 수 있듯이 n이 무한대로 커졌을 때를 논하기 때문에, 점근적 상한을 표현할 때에는 최고차항의 차수만을 고려한다.

공간 복잡도는 프로그램이 실행되었을 때 필요한 메모리 자원의 양을 의미한다.

### Array

`배열`이란 일정한 메모리 공간을 차지하는 `여러 요소들이 순차적으로 나열된 자료구조`이다.
각 요소에는 0부터 시작하는 고유한 순서 번호인 인덱스가 매겨진다.
이 인덱스로 배열의 요소를 식별할 수 있다.
`인덱스를 통해 요소를 검색하거나 값을 재할당`하는 것에는 `O(1)`의 시간복잡도를 가진다. 그러나 `요소를 삭제하거나 삽입`하는 경우 기존요소의 재배치가 발생하므로 `O(n)`의 시간복잡도를 가진다.

이러한 단점을 보완할 수 있는 자료구조가 `연결 리스트(Linked Array)`이다. 연결리스트는 각 요소들이 자신의 값과 함께 다음 원소의 주소값을 함께 가지고 있다. 따라서 어떠한 요소를 삽입하거나 삭제할 경우 `O(1)`의 시간복잡도를 가지게 된다. 그러나, 특정 위치에 요소를 삽입하고자 할 경우에는 처음 요소부터 차례대로 조회해야하므로 `O(n)`의 시간복잡도를 가지게 된다는 단점이 있다.

### Stack과 Queue

`Stack`이란 데이터의 삽입과 삭제가 한쪽 끝에서만 발생하는 자료구조로, `후입선출(Last In First Out) 방식`을 따른다.
대표적인 예시로 웹페이지의 뒤로 가기 기능, 함수의 매개 변수 처리 등을 들 수 있다.

`Queue`는 한쪽 끝에서 삽입이 이루어지면 다른 한쪽 끝에서 삭제가 이루어지는 자료구조로, `선입선출(First In First Out) 방식`을 따른다.
대표적인 예시로 프린터의 인쇄 작업 순서를 들 수 있다.

`Queue`는 여러 변형된 형태로 사용된다. `원형 큐(circle queue)`는 데이터를 삽입하는 쪽과 삭제하는 쪽을 하나로 연결해 원형으로 사용하는 자료구조이다. `덱(deque)`은 `양방향 큐(double-ended queue)`의 약자로 양쪽으로 데이터를 삽입/삭제할 수 있는 큐를 말하며, `우선순위 큐(priority queue)`는 저장된 요소들이 정해진 우선순위가 높은 순서대로 빠져나가는 큐이며, `힙(heap)`이라는 자료구조를 기반으로 구현된다.

### Tree

`Tree`는 계층적인 구조를 표현하기 위한 자료구조로, 데이터가 저장되어 있는 `노드(node)`, 노드와 노드를 연결하는 `간선(edge) 또는 링크(link)`로 이루어져 있으며 각 연결된 노드는 상하 관계를 형성한다.

```md
- 노드(node) : 트리를 구성하는 각각의 요소
- 간선(edge) 또는 링크(link) : 노드와 노드를 연결하는 선
- 루트 노드 또는 단말 노드(loot node) : 최상단에 위치한 노드, 부모 노드가 없는 노드
- 리트 노드(leaf node) : 최하단에 위치한 노드, 자식 노드가 없는 노드
```

상하 관계에 따라 `부모 노드`와 `자식 노드`로 표현할 수 있다.

** 추가적인 표현 **

- 차수(degree) : 각 노드가 가지는 자식 노드의 수
- 레벨(level) 또는 깊이(depth) : 특정 노드에 이르기까지 거치게 되는 간선의 수
- 높이(height) : 가장 높은 레벨

모집단의 일부를 표본이라 부르듯이 트리 안에 포함되어 있는 트리를 `서브트리(subtree)`라고 부른다.

`트리의 순회(tree traversal)`는 트리의 모든 노드를 한 번씩 방문하는 것으로 3가지의 대표적인 방법이 있다.

> `전위 순회(preorder traversal)` : 루트 노드 -> 왼쪽 서브트리 -> 오른쪽 서브트리  
> `중위 순회(inorder traversal)` : 왼쪽 서브트리 -> 루트 노드 -> 오른쪽 서브트리  
> `후위 순회(postorder traversal)` : 왼쪽 서브트리 -> 오른쪽 서브트리 -> 루트 노드

트리에는 다양한 종류가 있다.

## 💡 면접 예상 질문

- 캐시 메모리는 왜 필요한가요?
- RISC와 CISC의 차이점은?

## ❓스터디에서 논의하고 싶은 질문

- 컨트롤 유닛이 명령어 디코딩 시 수행하는 실제 동작은?

## 🔗 참고 자료

- [CS 정리 블로그](https://example.com)
