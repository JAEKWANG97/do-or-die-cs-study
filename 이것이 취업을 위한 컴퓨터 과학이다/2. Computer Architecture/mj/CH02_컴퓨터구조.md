# CH02. 컴퓨터 구조

## 📌 핵심 개념 요약

- CPU, 메모리와 캐시메모리, 보조기억장치, 입출력장치, 메인보드와 버스
- 데이터와 명령어
- CPU (레지스터, 인터럽트, 코어, 스레드, 병렬성과 동시성, 파이프라이닝을 통한 명령어 병렬 처리)
- 메모리 (RAM, 빅 엔디안과 리틀 엔디안, 캐시 메모리)
- 보조기억장치와 입출력장치

## 💡 면접 예상 질문

- 부동소수점이라는 용어의 뜻은 무엇인가요?
- 프로그래밍 언어에서 0.1+0.2라는 값과 0.3이라는 값을 비교했을 때 같지 않다는 오차가 발생하는 원인에 대해서 설명해주세요.
- 아스키코드, EUC-KR, 유니코드에 대한 간단한 설명과 두드러진 차이점 한가지를 설명해주세요
- ‘abc’라는 문자열을 base64 방식으로 인코딩하는 과정을 간단하게 설명해주세요.(힌트: 아스키코드 a,b,c는 각각 97,98,99)
  - 이때 6비트씩 나누어떨어지지 않는다면?
- 명령어 집합인 CISC와 RISC의 차이점을 설명해주세요.
  - 둘 중에 파이프라이닝에 적합한 명령어집합은?
- 파이프라인 위험의 종류 세가지를 설명해주세요.
- 캐시 메모리는 무엇을 저장할까요?
  - 그럼 CPU가 사용할 법한 것은 어떻게 예측하나요?
- DMA 입출력 과정을 간단하게 설명해주세요.

## ❓스터디에서 논의하고 싶은 질문

-

## 🔗 참고 자료

- **[책]** 이것이 취업을 위한 컴퓨터 과학이다 with CS 기술 면접

---

### 명령어

- 연산코드 (명령어가 수행할 동작) | 데이터가 저장된 위치 (오퍼랜드)
- CPU의 대표적인 연산 코드 : 데이터 전송, 산술/논리 연산, 제어 흐름 변경, 입출력 제어
- **기계어**(0과 1)와 **어셈블리어**(기계어를 읽기 편한 형태로 단순 번역한 언어)
  - 어셈블리어를 보면 CPU가 이해할 수 있는 명령어의 종류와 동작을 파악할 수 있음
  - 어셈블리어는 기계어를 그대로 번역한 언어이기 때문에 명령어의 종류가 달라지면, 기계어도, 이를 번역한 어셈블리어도 달라지게 된다.
  - 같은 프로그램일지라도 CPU마다 이해하는 명령어가 다르면 실행이 불가할 수도 있다.

### 명령어 사이클

인출 ↔ 실행 (반복)

- **인출 사이클**: 명령어를 메모리에서 CPU로 가지고오는 것
- **실행 사이클**: CPU는 메모리 속 명령어를 가져와 실행
- **간접 사이클**: 명령어를 실행하기 위해 한 번 더 메모리에 접근하는 단계

![image.png](attachment:b5b47d99-f436-4eb8-8adc-62fd052694f3:image.png)

# CPU

## 레지스터

- CPU 안에 있는 작은 임시 저장장치

### 1. 프로그램 카운터

메모리에서 다음으로 읽어 들일 **명령어의 주소**를 저장

명령어 포인터라고 부르기도함

일반적으로 1씩 증가 (다음으로 읽어 들일 메모리주소가 1씩 증가하는 것과 같음)

> 언제나 증가만 하냐? → 아님. 조건문, 리턴문처럼 임의의 위치로 변경되기도함

### 2. 명령어 레지스터

메모리에서 방금 **읽어들인 명령어를 저장**하는 레지스터

CPU 내의 제어장치는 명령어 레지스터 속 명령어를 해석한 뒤 ALU(산술논리연산장치)가 연산하도록 시키거나 다른 부품으로 제어 신호를 보내 해당 부품을 작동시킴

### 3. 범용 레지스터

다양하고 일반적인 상황에서 자유롭게 사용하는 레지스터

CPU에는 여러 개의 범용 레지스터가 있음

### 4. 플래그 레지스터

연산의 결과 혹은 CPU 상태에 대한 **플래그 값을 저장**하는 레지스터

플래그 : CPU가 명령어를 처리하는 과정에서 반드시 참조해야할 상태 정보

ex) 부호 플래그, 제로 플래그, 캐리 플래그, 오버플로우 플래그, 인터럽트 플래그, 슈퍼바이저 플래그

### 5. 스택 포인터

실행 중인 프로그램들은 스택과 같은 형태로 사용가능한 주소 공간을 하나 이상 가지고 있다. 이 영역을 ‘스택 영역’이라고 함

스택 포인터: 메모리 내 스택 영역의 최상단(마지막으로 스택에 저장된) 스택 데이터 위치를 가리키는 특별한 레지스터

## 인터럽트

- **동기** 인터럽트 (**=예외**. CPU에 의해, 예상치 못한 상황)
- **비동기** 인터럽트 (**=하드웨어 인터럽트.** 입출력장치에 의해, 알림의 역할)

![image.png](attachment:e8a454ac-a369-45a5-92b3-3c3d8babb046:image.png)

- 폴링 (↔ 인터럽트)
  - 입출력장치의 상태가 어떤지, 처리할 데이터가 있는지 주기적으로 확인

### 하드웨어 인터럽트 (비동기 인터럽트)

- CPU가 하드웨어 인터럽트 처리하는 순서
  1. 입출력 장치는 CPU에게 **인터럽트 요청 신호**를 보낸다
  2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전에 항상 **인터럽트 여부를 확인**
  3. 인터럽트 요청을 확인하고, **인터럽트 플래그**를 통해 현재 인터럽트를 받아들일 수 있는지 여부 확인
  4. 인터럽트 받아들일 수 있다면, CPU가 지금까지 한 작업을 백업
  5. CPU는 **인터럽트 벡터**를 참조하여 **인터럽트 서비스 루틴**을 실행
  6. 인터럽트 서비스 루틴 실행이 끝나면 백업해둔 작업을 복구하여 실행을 재개

![image.png](attachment:f1c4432e-73be-4fbf-ab9d-cc9b9c11a894:image.png)

### 예외 (동기 인터럽트)

- 폴트 / 트랩 / 중단 / 소프트웨어 인터럽트
- 폴트
  - 예외가 발생한 명령어부터
  - ex) 페이지 폴트: 명령어 실행을 위해 꼭 필요한 데이터가 아직 메모리가 아닌 보조 기억장치에 저장되어 있을 때
- 트랩
  - 예외가 발생한 명령어의 다음 명령어부터
  - ex) 디버깅의 브레이크 포인트

## CPU 성능 향상을 위한 설계

- CPU 클럭 속도: 컴퓨터의 부품을 움직일 수 있게 하는 시간의 단위
  (1초에 100번 반복되는 CPU의 클럭속도 → 100Hz)

### 코어

- 코어: CPU 내에서 명령어를 읽어들이고, 해석하고, 실행하는 부품
- 기술적 발전을 통해 여러 개가 존재하는 ‘멀티코어’

### 스레드

- 스레드: 실행 흐름의 단위
  - **하드웨어적**(CPU에서 사용)/**소프트웨어적**(운영체제에서 사용)인 스레드
    용어 구분하기!
- `하드웨어 스레드` (CPU에서 사용)
  (= 논리 프로세서)
  - 하나의 코어가 동시에 처리하는 **명령어의 단위**
  - 실행하는 부품 2개가 한번에 4개의 명령어를 처리한다면 → 2코어 4스레드 CPU
- `소프트웨어 스레드` (운영체제에서 등장)
  - 하나의 프로그램에서 독립적으로 실행되는 단위
  - 여러 스레드를 통해 실행된다 == 메모리에 적재된 해당 프로그램을 구성하는 여러 부분이 동시에 실행될 수 있다.

### 병렬성과 동시성

- 병렬성: 작업을 물리적으로 동시에 처리하는 성질
  - 같은 시점에 여러 작업을 동시에
- 동시성: 동시에 작업을 처리하는 것처럼 보이는 성질
  - CPU가 빠르게 작업을 번갈아가며 처리할 경우, 여러 작업이 동시에 처리되는 것처럼 보임

## 파이프라이닝을 통한 명령어 병렬 처리

- 명령어 병렬 처리 기법
- 파이프라이닝 (쪼개진 각각의 단계에서 동시에 실행가능한 단계를 겹쳐 실행, CPU성능높임)
  1. 명령어 인출
  2. 명령어 해석
  3. 명령어 실행
  4. 결과 저장
     같은 단계가 겹치지만 않는다면 CPU가 각각의 단계를 동시에 실행할 수 있다.
- 슈퍼스칼라: CPU 내부에 여러 ㅁ여령어 파이프라인을 포함하는 구조
- CISC와 RISC

# 메모리

## RAM

- 메인 메모리 역할을 하는 RAM과 ROM → 보통 RAM을 지칭
- 휘발성 저장장치 (↔ 비휘발성: 보조기억장치)
- 임의/직접 접근 (↔ 순차 접근)
- 종류
  - DRAM, SRAM, SDRAM, DDR SDRAM

### 1. DRAM

- Dynamic RAM
  - 시간이 지나면 저장된 데이터가 점차 사라지는 RAM
  - 장점) 소비전력이 낮고, 저렴, 집적도가 높아 대용량 설계에 용이

### 2. SRAM

- Static RAM
  - 저장된 데이터가 변하지 않는 RAM
  - 비휘발성 저장장치라는 것은 아님!!
  - 장점) DRAM에 비해 속도가 빠름 → 속도가 빨라야하는 저장장치 (캐시메모리)에 사용
  - 단점) 소비전력이 크고 , 비싸고, 집적도가 낮음

### 3. SDRAM

- Synchronous Dynamic RAM
  - **클럭 신호와 동기화**된, 발전된 형태의 DRAM
    - 클럭 타이밍에 맞춰 CPU와 정보를 주고받을 수 있다.

### 4. DDR SDRAM

- Double Data Rate SDRAM
  - 대역폭을 넓혀 속도를 빠르게 만든 SDRAM
  - 대역폭: 데이터를 주고받을 길의 너비
  - SDRAM보다 전송 속도가 두배 정도 빠르다 (한클럭당 두번씩)

## 메모리에 바이트를 밀어 넣는 순서

### 빅 엔디안과 리틀 엔디안

- 빅 엔디안: 낮은 번지의 주소에 상위 바이트부터 저장하는 방식
  - 메모리 값을 직접 읽거나 디버깅할 때 편리
- 리틀 엔디안: 낮은 번지의 주소에 하위 바이트부터 저장하는 방식
  - 수치 계산이 편리하다 (일의 자리부터 계산하는것처럼)

## 캐시 메모리

- CPU의 연산속도와 메모리 접근 속도의 차이를 줄이기 위해 탄생한 저장장치
- CPU와 메모리 사이에 위치. SRAM 기반 저장장치
- L1 / L2 / L3
  - 크기: L1<L2<L3
  - 속도: L1>L2>L3
  - L1,L2 (코어 내부) L3(코어 외부)
- L1I (명령어만을 저장)/ L1D(데이터만을 저장) → 분리형 캐시

### 캐시 히트와 캐시 미스

- 캐시 메모리는 무엇을 저장할까?
  > 보조장치가 (전원이 꺼져도) ‘보관할 것’
  > 캐시 메모리는 CPU가 사용할 법한 것
- 캐시 히트
  - 캐시 메모리가 예측하여 저장한 데이터가 실제 CPU에 의해 실제로 사용되는 경우
- 캐시 미스
  - 캐시 메모리가 예측하여 저장했지만 틀린 예측으로 인해 CPU가 메모리부터 필요한 데이터를 직접 가져와야하는 경우
- 캐시 적중률
  - 캐시 히트 횟수 / (캐시 히트 횟수 + 캐시 미스 횟수)

### 참조 지역성

- 최근에 접근했던 메모리 공간에 다시 접근하려는 경향(**시간 지역성**), 접근한 메모리 공간의 근처에 접근하려는 경향 (**공간 지역성**)

### 캐시 메모리 쓰기 정책과 일관성

- CPU가 캐시 메모리에 데이터를 쓸 때는 캐시 메모리에 새롭게 쓰여진 데이터와 메모리 상의 데이터가 일관성을 유지해야한다.
- 즉시 쓰기
  - 캐시 메모리와 메모리에 동시에 쓰면서 메모리를 항상 최신 상태로 유지
  - 단점) 데이터를 쓸 때마다 메모리를 참조해야 하므로 버스의 사용 시간과 쓰기 시간이 늘어난다는 단점이 있다.
- 지연 쓰기
  - 캐시 메모리에만 값을 써 두었다가 추후 수정된 데이터를 한 번에 메모리에 반영
  - 메모리 접근 횟수를 줄일 수 있어 속도는 더 빠르지만, 메모리와 캐시 메모리 간의 일관성이 깨질 수 있다.
- 캐시 메모리를 사용하면 데이터 접근에 있어 어느 정도의 빠른 성능을 보장할 수 있지만, 그와 동시에 데이터의 일관성을 유지하기 위한 책임이 따른다!

# 보조기억장치와 입출력장치

> 메모리의 휘발성 보완, 메모리보다 큰 저장 공간 제공
> 보조기억장치에 저장된 정보를 안정적이고 안전하게 관리하는 ‘RAID’

## RAID

- 보조기억장치 2가지
  - 하드 디스크 드라이브
  - 플래시 메모리 기반 저장장치
    - USB, SD카드, **SSD**
    - 주로 보조기억장치로 사용되는 SSD

### RAID0

- 데이터를 여러 보조기억장치에 단순하게 나누어 저장하는 구성 방식
- 줄무늬처럼 분산되어 저장된 데이터 → 스트라입
  - 이렇게 분산하여 저장하는 동작 → 스트라이핑
- 장점)
  - 빠른 입출력 속도
- 단점)
  - 저장된 정보가 안전하지 않다.
  - 하드디스크1에 문제가 생긴다면, 나머지 2,3,4에 불완전한 데이터

### RAID1

- 완전한 복사본을 만들어 저장하는 구성 방식
  - (= 미러링)
- 장점) 복구가 간단하고 안전성이 높다
- 단점) RAID0보다는 쓰기 속도가 느려지고, 복사본이 저장된 크기만큼 사용 가능한 용량이 적어진다

### RAID4

- 패리티 정보를 저장하는 디스크를 따로 두는 구성 방식
  - 패리티: 오류를 검출할 수 있는 정보
- 단점) 패리티를 저장하는 장치에 병목 현상 발생

### RAID5

- 패리티를 분산하여 저장하는 구성방식
- RAID4의 단점인 병목현상 보완

### RAID6

- 기본적인 구성은 RAID5와 같지만, 서로 다른 2개의 패리티를 두는 구성 방식
- 장점) RAID4, RAID5에 비해 안전성이 높다.
- 단점) 새로운 정보를 저장할 때마다 함께 저장하는 패리티가 2개이므로 RAID5에 비해 속도는 일반적으로 느리다.

### Nested RAID

- 여러 RAID 레벨을 혼합한 방식

## 입출력 기법

> 보조기억장치도 메모리를 보조하는 임무를 수행하는 특별한 입출력장치로 볼 수 있다.

### 장치 컨트롤러와 장치 드라이버

- CPU 입장에서 모든 입출력 장치의 작동 방식을 아는 것은 어렵기 때문에
- 입출력장치는 CPU와 직접 연결되어 정보를 주고받지 않고, 장치 컨트롤러라는 하드웨어를 통해 연결됨
- 장치 컨트롤러
  - CPU와 입출력 사이의 통신을 중개하는 중개자 역할의 하드웨어
- 장치 드라이버
  - 장치 컨트롤러의 동작을 알고, 장치 컨트롤러가 컴퓨터 내부와 정보를 주고받을 수 있도록 하는 프로그램
  - ex) 프린터는 장치 드라이버를 별로도 설치해줘야 함

### 입출력 수행 방법 3가지

1. **프로그램 입출력**
   - 프로그램 속 명령어로 입출력 작업 수행
     - CPU: 입출력 명령어를 실행
   - 2가지
     - 고립형 입출력
       - 입출력장치에 접근하는 주소와 메모리에 접근하는 주소를
         별도의 주소 공간으로 간주
     - 메모리 맵
       - 입출력장치에 접근하는 주소 공간과 메모리에 접근하는 주소 공간을 구분하지 않고 메모리에 부여된 주소 공간 일부를 입출력장치를 식별하기 위한 주소 공간으로 사용
       - 메모리에 접근하는 명령어로 입출력이 가능하기 때문에 입출력 전용 명령어가 별로도 필요하지 않는다.
2. 인터럽트 기반 입출력: 다중 인터럽트
   - 인터럽트가 여러 입출력장치로부터 동시다발적으로 발생하는 경우
   - CPU가 플래그 레지스터 속 인터럽트 비트를 비활성화한 채 인터럽트 처리하는 경우
     - 다른 하드웨어 인터럽트를 받아들이지 않기 때문에 순서대로 인터럽트 서비스 루틴 실행
   - 플래그 레지스터 인터럽트 비트 활성화 혹은 비활성화해도 무시할 수 없는 인터럽트인 NMI가 발생한 경우, 우선순위가 높은 인터럽트부터 먼저 처리
   - 다중 인터럽트를 처리하기 위해서는 `PIC`
     - 프로그래머블 인터럽트 컨트롤러
     - 여러 장치 컨트롤러에 연결되어 있어 장치 컨트롤러에서 보낸 하드웨어 인터럽트 요청들의 **우선순위를 판별한 뒤**, CPU에게 지금 해야할 하드웨어 인터럽트가 무엇인지 알려줌
     - 많은 하드웨어 인터럽트를 관리하기 위해 2개이상의 계층으로 구성
3. DMA 입출력
   - 입출력장치와 메모리 사이에 전송되는 모든 데이터가 반드시 CPU를 거쳐야한다면 CPU의 부담이 커지겠지??
     - 그래서 DMA가 등장
     - Direct Memory Access
     - 직접 메로리에 접근할 수 있는 입출력 기능
     - 시스템 버스에 연결된 DMA 컨트롤러라는 하드웨어가 필요
   - `PCIe`
     - 대표적인 입출력 버스
       - 버전에 따라 최대 속도가 달라질 수 있다.
       - PCIe 버스는 여러 레인을 이용해 정보를 주고받을 수 있다.
     - 레인: PCIe 버스를 통해 정보를 송수신하는 단위

### cf) GPU
