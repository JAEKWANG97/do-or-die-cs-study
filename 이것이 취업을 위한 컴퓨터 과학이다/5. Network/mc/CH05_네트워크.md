# CH05. 네트워크

## 목차

- [1. 네트워크의 큰 그림](#1-네트워크의-큰-그림)
- [2. 물리 계층과 데이터 링크 계층](#2-물리-계층과-데이터-링크-계층)
- [3. 네트워크 계층 - IP](#3-네트워크-계층---ip)
- [4. 전송 계층 - TCP와 UCP](#4-전송-계층---tcp와-udp)
- [5. 응용 계층 - HTTP의 기초](#5-응용-계층---http의-기초)
- [6. 응용 계층 - HTTP의 응용](#6-응용-계층---http의-응용)
- [7. 프록시와 안정적인 트래픽](#7-프록시와-안정적인-트래픽)
- [면접 예상 질문](#면접-질문-리스트교재-버전)

## 1. 네트워크의 큰 그림

### 네트워크(Network)

- 여러 대의 장치가 연결되어 정보를 주고받는 통신망

- 노드(네트워크 기기)와 간선(네트워크 기기 간에 정보를 주고받는 유무선의 통신 매체)으로 이루어진 그래프 형태

- `네트워크 토폴로지(network topology)`  
  : 네트워크 상에서 노드와 노드 사이의 연결 구조
  e.g.망형, 트리형, 링형

- `호스트(host)`  
  : 네트워크의 가장자리에 위치해 주고받는 정보를 최초로 송신하고 최종 수신하는 노드  
   대부분의 네트워크 기기(노트북과 구글의 서버 컴퓨터) - `클라이언트(client)` : `요청(request)`을 보내는 호스트
  - `서버(server)` : `응답(response)`을 보내는 호스트  
    노트북(클라이언트)이 구글의 서버 컴퓨터에게 웹 페이지를 가져다 달라는 요청을 보내면 구글의 서버 컴퓨터(서버)가 노트북에게 웹 페이지로 응답한다.
- 그 외 노드 : 중간 역할을 하는 스위치와 라우터, 공유기

- `프로토콜(protocol)` : 네트워크에서 통신을 주고받는 노드 간의 합의된 규칙이나 방법


### 네트워크 구분

- `LAN(Local Area Network)`  
  : 근거리 네트워크  
  공유기를 통해 네트워크 기기가 통신 => LAN이 공유기를 기준으로 구축  
  공유기와 연결된 네트워크 기기들은 `모두 같은 네트워크(LAN)에 속해 있다`고 인식

- `WAN(Wide Area Network)`  
  : LAN 간의 통신이 이루어지는 네트워크
  `ISP(Internet Service Provider)` : 인터넷 서비스 업체 e.g. KT, LG유플러스, SK브로드밴드

### 패킷 교환 네트워크

`패킷 교환 네트워크` : 패킷 단위로 주고받는 정보를 쪼개서 송수신하고 수신지에서 재조립하며 패킷을 주고받는 네트워크

`패킷(packet)` : 이렇게 네트워크를 통해 송수신되는 데이터의 단위  
`헤더(header)` : 패킷에 추가되는 부가 정보  
<p style="text-align:center;">= `페이로드(payload)` + `헤더(header)` ( + `트레일러(trailer)` )</p>  
 
### 주소의 개념과 전송 방식

`주소(address)` : 패킷의 헤더에 명시되는 정보 (`IP 주소`와 `MAC 주소`)

- 주소를 바탕으로 다양한 수신지 유형을 지정해 패킷을 전송  
  수신지를 특정 호스트 하나로 지정할 수도 있고, 네트워크 내 모든 호스트로 지정할 수도 있다.
  - `유니캐스트(unicast)` : 송신지와 수신지가 일대일 통신

  - `브로드캐스트(broadcast)` : 네트워크상의 모든 호스트에게 메시지를 전송

    `브로드캐스트 도메인(broadcast domain)` : 브로드캐스트가 전송되는 범위  

     => 호스트가 같은 브로드캐스트 도메인에 속해 있는 경우에는 같은 LAN에 속해 있다고 간주

  - `멀티캐스트(multicast)` : 네트워크 내의 동일 그룹에 속한 호스트에게만 전송
  
  - `애니캐스트(anycast)` : 네트워크 내의 동일 그룹에 속한 호스트 중 가장 가까운 호스트에게 전송


### 네트워크 참조 모델

`네트워크 참조 모델(network reference model)`  
- 통신이 이루어지는 단계를 계층적으로 표현한 모델  

- 패킷을 송신하는 쪽에서는 상위 계층에서 하위 계층으로 정보를 보내고, 패킷을 수신하는 쪽에서는 하위 계층에서 상위 계층으로 정보를 받아들이게 되는 것이죠.

### OSI 7계층과 TCP/IP 4계층 비교표

| OSI 7계층        | TCP/IP 4계층 | 설명 |
| ---------------- | ------------------ | ----------- |
| 응용 계층        | 응용 계층                | 사용자 인터페이스 및 응용 프로그램과의 상호작용 |
| 표현 계층        | ...                      | 데이터 형식, 인코딩, 암호화 등                  |
| 세션 계층        | ...                      | 세션 설정, 유지 및 종료                         |
| 전송 계층        | 전송 계층                | 종단 간 연결, 오류 제어, 흐름 제어 (TCP/UDP)    |
| 네트워크 계층    | 인터넷 계층              | 논리적 주소 지정(IP), 경로 설정                 |
| 데이터 링크 계층 | 네트워크 인터페이스 계층 | 물리적 주소(MAC), 프레임 전송, 오류 감지        |
| 물리 계층        |                          | 전기적 신호, 케이블, 커넥터 등 물리적 전송 매체 |

> `+` 참고: TCP/IP 모델은 OSI보다 간략화되어 있고, 상위 3계층(응용/표현/세션 계층)은 TCP/IP의 "응용 계층"에 통합됩니다.

`OSI Model`(7계층)

- `물리 계층(physical layer)`
    - 비트 신호(0과 1만으로 이루어진 신호)를 유무선 통신 매체를 통해 운반하는 계층  
    - 패킷의 이름 : 심볼(symbol) 또는 비트(bit)

- `데이터 링크 계층(data link layer)`  
    - 같은 LAN에 속한 호스트끼리 올바르게 정보를 주고받기 위한 계층  
    - 같은 네트워크에 속한 호스트를 식별할 수 있는 주소(MAC 주소)를 사용  
    - 물리 계층을 통해 주고받는 정보에 오류가 없는지 확인
    - 패킷의 이름 : 프레임(frame)

    => 물리 계층과 데이터 링크 계층은 서로 밀접하게 연관된 계층이며, 하드웨어와 밀접하게 맞닿아 있는 계층

- `네트워크 계층(network layer)`  
    - 네트워크 간 통신을 가능하게 하는 계층
    - 데이터 링크 계층이 기본적으로 같은 LAN에 속한 호스트끼리 올바르게 정보를 주고받기 위해 필요한 계층이라면, 네트워크 계층은 LAN을 넘어 다른 네트워크와 통신을 주고받기 위해 필요한 계층
    - => 네트워크 간 통신 과정에서 호스트를 식별할 수 있는 주소(IP 주소)가 필요하죠.
    - 패킷의 이름 : 패킷(이하 IP 패킷) 또는 데이터그램
    - 대표 프로토콜 : IP

- `전송 계층(transport layer)`
    - 신뢰성 있는 전송을 가능하게 하는 계층  
    - `포트(port)` 정보를 통해 특정 응용 프로그램과의 연결 다리 역할을 수행하는 계층  
    - 패킷의 이름 : TCP 기반(세그먼트) UDP 기반 (데이터그램)  
    - 대표 프로토콜 : TCP와 UDP

- `세션 계층(session layer)`  
    - `세션(session)`(응용 프로그램 간의 연결 상태)을 관리하기 위한 계층  
    - 응용 프로그램 간의 연결 상태를 유지하거나 새롭게 생성하고, 필요하다면 연결을 끊는다.  
    - 이 이상의 계층에서는 패킷의 이름 : 데이터 또는 메시지

- `표현 계층(presentation layer)`
  인코딩과 압축, 암호화와 같은 작업을 수행  
  => 세션 계층과 표현 계층은 다른 계층과 달리, 두 계층을 명확하게 구분하지 않거나 응용 계층에 포함하여 간주하는 경우가 많다.

- `응용 계층(application layer)`
  사용자와 가장 밀접하게 맞닿아 있어 여러 네트워크 서비스를 제공하는 계층  
  중요한 프로토콜들이 다수 포함  
   대표 프로토콜 : HTTP, HTTPS, DNS

`TCP/IP Model` (4계층)

- `네트워크 액세스 계층(network access layer)`
- 링크 계층(link layer) 또는 네트워크 인터페이스 계층(network interface layer)이라고도 부른다.
    - `인터넷 계층(internet layer)`은 OSI 모델의 네트워크 계층과 유사하며,
    - `전송 계층(transport layer)`은 OSI 모델의 전송 계층,
    - `응용 계층(application layer)`은 OSI 모델의 세션 계층, 표현 계층, 응용 계층을 합친 것과 유사

### 캡슐화와 역캡슐화

> 패킷을 송신하는 쪽에서는 상위 계층에서 하위 계층으로 정보를 보내고, 패킷을 수신하는 쪽에서는 하위 계층에서 상위 계층으로 정보를 받아들인다.

● 네트워크 계층 구조를 이용하면 프로토콜을 계층별로 구성할 수 있다.  
● 하나의 패킷은 헤더와 페이로드(때로는 트레일러까지)를 포함하며, 프로토콜의 목적과 특징에 따라 헤더의 내용은 달라질 수 있다.

각 계층에서는 어떤 정보를 송신할 때 상위 계층으로부터 내려받은 패킷을 페이로드로 삼아, 각 계층에 포함된 프로토콜의 각기 다른 목적과 특징에 따라 헤더 혹은 트레일러를 덧붙인 다음 하위 계층으로 전달한다.  
상위 계층의 패킷 == 하위 계층의 페이로드

`캡슐화(encapsulation)` : 송신 과정에서 헤더(및 트레일러)를 추가해 나가는 과정

`역캡슐화(decapsulation)` : 수신 과정에서 캡슐화 과정에서 붙인 헤더(및 트레일러)를 각 계층에서 확인한 뒤 제거하는 과정

### 네트워크 지도 그리기
(363페이지 참고)

<div style="display:flex; ">
    <div style="flex:1">
    <p>물리 계층과 데이터 링크 계층</p>
    </div>
    <div style="flex:3">
    <ul>
        <li>이더넷</li>
        <li>유무선 통신 매체</li>
        <li>이더넷 프레임</li>
        <li>다양한 네트워크 장비 (NIC, 허브, 스위치)</li>
    </ul>
    </div>
</div>

<div style="display:flex; ">
    <div style="flex:1">
    <p>네트워크 계층</p>
    </div>
    <div style="flex:3">
    <ul>
        <li>IP의 목적과 특징</li>
        <li>IP 구조(구조, 종류, 할당 방식)</li>
        <li>ICMP</li>
        <li>ARP</li>
    </ul>
    </div>
</div>

<div style="display:flex; ">
    <div style="flex:1">
    <p>전송 계층</p>
    </div>
    <div style="flex:3">
    <ul>
        <li>TCP</li>
        <li>UDP</li>
    </ul>
    </div>
</div>

<div style="height: 5px; background:white"></div>

## 2. 물리 계층과 데이터 링크 계층

### `이더넷(Ethernet)`

- LAN 내의 호스트들이 올바르게 정보를 주고받을 수 있게 해주는 기술 표준(설계도와 같은 것)

> `이더넷 표준`  
> 오늘날의 (유선)LAN 대부분이 이더넷 표준을 따르기 때문에 대다수의 LAN 장비들이 특정 이더넷 표준(IEEE 802.3)을 따른다.
> 이더넷 표준이 달라지면 통신 매체의 종류를 비롯한 신호 송수신 방법, 나아가 최대 지원 속도도 달라질 수 있다.

`이더넷 프레임(Ethernet frame)`  
이더넷 기반의 네트워크에서 주고받는 프레임 (e.g Ethernet II 프레임)
사실상 ‘프레임’이 이더넷 프레임을 지칭한다고 보아도 무방

- 이더넷 프레임의 구성 요소

  - `프리앰블(preamble)`
    송수신지 동기화를 위해 사용되는 8바이트(64비트) 크기의 정보
    수신지는 프리앰블 비트를 통해 현재의 이더넷 프레임이 수신되고 있다는 사실을 알아차리게 된다.

  - `송수신지 MAC 주소`  
    : 프레임에는 송신지와 수신지를 특정할 수 있는 6바이트(48비트) 길이의 `MAC 주소(mac address)`(네트워크 인터페이스마다 하나씩 부여되는 물리적 주소)가 명시  
    콜론(:)으로 구분된 12자리 16진수 (e.g. ab:cd:ab:cd:00:01 )

  - `네트워크 인터페이스`
    : 네트워크를 향하는 통로, 연결 매체와의 연결 지점(NIC)  
    NIC가 여러 개인 상황처럼 네트워크 인터페이스가 여럿이라면 한 호스트가 여러 개의 MAC 주소를 가질 수 있다.

  - `타입/길이(type/length) 필드`  
     필드에 명시된 크기에 따라

    - 1500 이하(16진수 05DC) = 프레임의 크기
    - 1536 이상(16진수 0600) = 타입
      <u>타입 = 캡슐화된 상위 계층의 정보</u>  
      => 타입을 통해 어떤 상위 계층 프로토콜이 캡슐화되었는지를 알 수 있다.

  - `데이터 필드`  
     페이로드(상위 계층으로 전달하거나 전달받을 데이터)

    > NOTE : `MTU`
    > ‘1500바이트’는 이더넷 프레임으로 전송 가능한 최대 데이터의 크기이자, 네트워크 계층 패킷(헤더 + 페이로드)의 최대 크기를 지칭하는 데 사용
    > 점보 프레임(jumbo frame) : 일반적인 이더넷 프레임보다 더 큰 데이터를 포함할 수 있는 프레임

  - `FCS(Frame Check Sequence)`  
     프레임의 오류가 있는지의 여부를 확인하기 위한 필드  
     `CRC(Cyclic Redundancy Check)`라는 오류 검출용 값이 명시되어 있다.

    송신지 : (전송할 데이터 + 데이터에 대한 CRC 값) 전송  
     -(전송)-> 수신지 : (전달받은 데이터의 CRC 값 과 전달받은 CRC 값대조)하여 프레임의 오류 여부 확인

### 유무선 통신 매체

호스트의 데이터 처리 + `하드웨어의 성능` 도 필요!

- 유선 매체 : `트위스티드 페어 케이블(twisted pair cable)`
<div style="display:flex; margin:10px; gap:10px">
    <img src="./assets/트위스티드 페어 케이블.png" style="width:150px">
        <ul>
            <li>구리선을 통해 전기적으로 신호를 주고받는 통신 매체 => 전기 신호에 왜곡을 줄 수 있는 <u>주변 잡음(노이즈, noise)</u>에 취약하다.</li>
            <li>`카테고리(category)` <br>트위스티드 페어 케이블의 성능을 구분하는 일종의 등급 역할을 한다. 카테고리에 따라 대응되는 주요 이더넷 표준이 다르고, 표준에 따른 최대 지원 속도도 달라질 수 있습니다.</li>
        </ul>
</div>

> NOTE
> 트위스티드 페어 케이블을 그물 모양의 철사나 포일(foil)로 감싸 노이즈를 방지  
> 구리선 주변을 보호해 노이즈를 감소시키는 방식은 차폐(shielding)라고 하며, 차폐에 사용된 그물 모양의 철사와 포일은 각각 브레이드 실드(braided shield)와 포일 실드(foil shield)
> STP(Shielded Twisted Pair) 케이블 : 브레이드 실드로 노이즈를 감소시킨 케이블
> FTP(Foil Twisted Pair) 케이블 : 포일 실드로 노이즈를 감소시킨 케이블
> UTP(Unshielded Twisted Pair) 케이블 : 아무것도 감싸지 않아 구리선만 있는 케이블

- 무선 매체 : `전파와 WiFi`
- 진동수 2.4GHz와 5GHz(와이파이를 사용할 때 주로 활용)
- `와이파이(Wi-Fi)`
- 표준 : ‘IEEE 802.11’ + 숫자 / 표준 규격에 따라 지원되는 최대 속도나 주파수 대역 등이 달라질 수 있다.
- 와이파이 뒤에 붙는 숫자로 세대를 구분, 세대에 따라 지원되는 표준 규격/최대 속도나/주파수가 달라질 수 있다.

> 같은 대역을 사용하는 서로 다른 무선 네트워크를 구분하기 위해 `채널channel`이라는 하위 주파수 대역으로 세분화되고, 해당 채널 대역에서 무선 통신이 이루어진다.

> AP와 SSID
> `AP(Access Point)` : 여러 무선 통신 기기를 연결해 무선 네트워크를 구성하는 장비(e.g. 무선 공유기)
> `서비스 셋(Service Set)` : AP를 중심으로 구성된 무선 네트워크
> `SSID(Service Set Identifier)` : 서비스 셋을 식별하는 정보(서비스 셋 식별자)

### 네트워크 인터페이스와 NIC

`네트워크 인터페이스(network interface)`

- 네트워크 상에서 노드와 통신 매체가 연결되는 지점, 노드와 네트워크 사이의 통로
- 네트워크 인터페이스마다 물리적 주소라고 불리는 MAC 주소가 부여된다.

`NIC(Network Interface Controller)`

- 통신 매체의 신호를 호스트가 이해하는 프레임으로 변환하거나 호스트가 이해하는 프레임을 통신 매체의 신호로 변환하거나, MAC 주소를 토대로 잘못 전송된 패킷이 없는지 확인하는 역할을 한다.
- NIC를 작동시키는 시스템 콜 존재  
  대부분 DMA도 지원

> NOTE : `티밍(teaming) 혹은 본딩(bonding)`

### 허브와 스위치

둘 다 네트워크 장비(하드웨어), 허브와 스위치는 물리 계층과 데이터 링크 계층의 중간 노드이다.

| 항목                | 허브(Hub)                                                      | 스위치(Switch)                                                    |
| ------------------- | -------------------------------------------------------------- | ----------------------------------------------------------------- |
| 계층                | 물리 계층 (Layer 1)                                            | 데이터 링크 계층 (Layer 2, 일반적으로 L2 스위치 의미)             |
| 통신 방식           | 반이중 통신 (Half Duplex)<br>동시 송수신 불가능<br>e.g. 무전기 | 전이중 (Full Duplex)<br>동시 송수신 가능<br>e.g. 전화기           |
| 데이터 전달 방식    | 수신한 신호를 모든 포트로 브로드캐스트                         | 수신한 프레임의 목적지 포트로만 유니캐스트 전달                   |
| 충돌 도메인         | 전체 허브가 하나의 충돌 도메인                                 | 각 포트가 별도의 충돌 도메인                                      |
| 브로드캐스트 도메인 | 전체 허브가 하나의 브로드캐스트 도메인                         | 기본적으로 전체가 하나의 브로드캐스트 도메인 (VLAN으로 분리 가능) |
| MAC 주소 처리       | MAC 주소 인식 불가                                             | MAC 주소 학습 및 MAC 주소 테이블 저장 가능                        |
| 사용 현황           | 현재는 거의 사용하지 않음                                      | 현재 네트워크에서 표준적으로 사용                                 |
| 주요 용도           | 단순 신호 증폭 및 분배 (리피터 역할)                           | 지능적인 데이터 전송 및 분할된 네트워크 구성                      |
| VLAN 기능           | 지원하지 않음                                                  | VLAN 구성 가능 (논리적으로 네트워크 분리)                         |
| 추가 설명           |                                                                |                                                                   |

`허브`

- 물리 계층의 대표적인 네트워크 장비로, 여러 대의 호스트를 연결하는 장치

`포트(port)` : 허브에서 케이블의 커넥터가 꽂히는 부분, 통신 매체를 연결하는 지점

- 특징

  1. 보로드캐스트(전달받은 신호를 모든 포트로 내보낸다)
     허브는 신호를 전달받으면 해당 신호에 대한 어떠한 조작이나 판단도 하지 않고, 모든 포트에 단순하게 신호를 내보낸다.

  2. 반이중 통신
     `반이중 통신` : `반이중(half duplex) 모드`로 송수신하는 것  
     = 송신 또는 수신을 번갈아 가면서 수행해야 하는 통신 방식  
     = 동시 송수신이 불가능한 상태  
     e.g. 무전기와 같이 어느 한 쪽이 송신할 때 다른 쪽은 송신이 불가능

  허브는 반이중 모드로 통신 == 어느 한 호스트가 허브를 향해 정보를 전달하면 다른 호스트는 정보를 전송할 수 없다.  
   `콜리전(충돌) 도메인(collision domain)` : 충돌(허브를 향해 동시에 메시지를 보냈을 때 발생하는 문제)이 발생할 수 있는 영역

`스위치(switch)`

- 허브의 한계를 보완하기 위한 네트워크 장비
- 특징

  1. 유니 캐스트  
     `MAC 주소 학습(MAC address learning) 기능`을 통해 전달받은 신호를 목적지 호스트가 연결된 포트로만 내보낸다.
     - 프레임 헤더에 명시된 MAC 주소를 이해하고, 이를 토대로 현재 어떤 포트에 어떤 MAC 주소를 가진 호스트가 연결되어 있는지 파악하고, ‘포트, 연결된 호스트의 MAC 주소’의 대응 관계를 `MAC 주소 테이블(MAC address table)`에 저장하고 참조한다.
  2. 전이중 모드  
     전이중 모드를 지원해 동시 송수신이 가능하여 콜리전 도메인이 좁다.

- 데이터 링크 계층의 상위 계층에서도 사용되는 스위치가 있다.(L2 스위치, L3 스위치 ...)

`VLAN(Virtual LAN)`

- 가상(Virtual)의 LAN
- 같은 스위치에 연결된 모든 호스트를 하나의 네트워크로 간주하지 않고 여러 논리적인 네트워크로 나누고 싶을 때 사용된다.
- 서로 다른 VLAN에 속해 있으므로 서로 다른 네트워크로 간주되며, 브로드캐스트 도메인도 겹치지 않아 브로드캐스트 메시지가 서로에게 도달하지 않는다. 서로 통신을 주고받으려면 네트워크 계층 이상의 장비가 필요하다.

<div style="height: 5px; background:white"></div>

## 3. 네트워크 계층 - IP

> 같은 IP 대역 + 같은 서브넷 마스크 → LAN 내부 통신 (스위치 기반, 라우터 불필요)
> 같은 IP 대역이라도 VLAN이 다르면 → LAN 간 통신 (라우터 필요)
> 서로 다른 IP 대역 → 네트워크 간 통신 (라우터 필요)

### IP의 목적과 특징

> `IP 패킷` : IP 주소 정보를 담고, 네트워크 계층에서 전송되는 데이터 단위

`주소 지정(addressing)`

- 네트워크 간의 통신 과정에서 IP 주소를 통해 호스트를 특정하는 것,

- IP 패킷의 필드 요소

  1. 송신지 IP 주소/수신지 IP 주소

     - 4바이트의 점으로 구분된 10진수 4개(e.g. 0.0.0.0 ~ 255.255.255.255)
     - `옥텟(octet)` : 점으로 구분된 하나의 10진수  
        e.g. ‘192.168.0.1’ => 옥탯은 ‘192’, ‘168’, ‘0’, ‘1’

     - `라우터(router)` : IP 주소를 기반으로 IP 패킷의 최적 경로를 결정하여 목적지까지 전달(`라우팅(routing)`)하는 네트워크 장비 e.g. 공유기

     - `IPv4`와 `IPv6`  
        `IPv4 주소`는 총 4바이트(32비트)로 고갈될 여지가 있음.  
        => `IPv6 주소`는 16바이트(128비트)로 주소를 표현하여 할당 가능한 IPv6 주소는 2^128개, 콜론(:)으로 구분된 8개 그룹의 16진수로 표기

       > IPv4 주소 : 192.168.1.1  
       > IPv6 주소 : 2001:0230:abcd:ffff:0000:0000:ffff:1111

  2. 단편화와 관련된 필드

     > - `단편화(fragmentation)` : 데이터를 여러 IP 패킷으로 올바르게 쪼개어 보내는 것

     > - `MTU(최대 전송 단위, Maximum Transmission Unit)`  
     >   => 전송하고자 하는 IP 패킷(IP 헤더와 페이로드)의 크기가 MTU라는 단위보다 클 경우에는 패킷을 MTU 이하의 여러 패킷으로 쪼개서 전송하고, 이렇게 쪼개서 전송된 패킷들은 수신지에서 재조합된다.
     > - 일반적인 MTU 크기는 1500바이트

     - IP 패킷 헤더에서 단편화와 관련된 필드

       - `식별자(identifier)` : 특정 패킷이 어떤 데이터에서 쪼개진 패킷인지를 식별하기 위해 사용되는 필드  
         같은 식별자 = 같은 정보에서 쪼개진 패킷

       - `플래그(flag)`: 3비트로 구성된 필드 [0 / DF / MF]  
          DF(‘IP 단편화를 수행하지 말라(Don’t Fragment)’)  
          MF(‘단편화된 패킷이 더 있다(More Fragment)’)

       - `단편화 오프셋(fragment offset)`: 특정 패킷이 초기 데이터에서 얼마나 떨어져 있는지가 명시된 필드 단편화되어 전송되는 패킷을 목적지에서 재조합하기 위해 패킷의 올바른 순서를 나타내는 데 사용된다.

       - 특징 : ‘신뢰할 수 없는 통신’과 ‘비연결형 통신’

신뢰할 수 없는 통신과 비연결형 통신

- `신뢰할 수 없는 프로토콜(unreliable protocol)`  
  : 패킷이 수신지까지 제대로 전송되었다고 보장하지 않는 프로토콜
  패킷이 유실되거나 목적지에 순서대로 전송되지 않더라도 이에 대한 조치를 취하지 않는다.
  신뢰할 수 없는 통신 = 신뢰성이 낮은 통신 = `최선형 전달(best effort delivery)`

- `비연결형 프로토콜(connectionless protocol)`  
  : 패킷을 주고받기 전에 사전 연결 과정을 거치지 않는다는 것
  상대 호스트의 수신 가능 여부는 고려하지 않고 수신지를 향해 패킷을 전송

> 잦은 IP 단편화는 네트워크에 여러 악영향을 미칠 수 있습니다.
> 단편화된 패킷들이 많아지면 전송해야 할 패킷의 헤더들이 많아지기 때문에 **불필요한 트래픽 증가와 대역폭 낭비**를 초래하고, 단편화된 패킷을 재조립하는 과정에서 발생하는 부하도 성능 저하로 이어질 수 있다.
> IP 단편화를 피하려면 IP 패킷을 주고받는 경로에 존재하는 모든 호스트의 ‘처리 가능한 MTU 크기’를 고려해야 합니다.
> `경로 MTU(Path MTU)` : ‘IP 단편화 없이 주고받을 수 있는 최대 크기’
> `경로 MTU 발견(Path MTU discovery)` : 경로 MTU를 구하고 해당 크기만큼만 송수신하여 IP 단편화를 회피하는 기술

### IP 주소의 구조

- `IP 주소` = `네트워크 주소` + `호스트 주소`

  `네트워크 주소`  
   : 호스트가 속한 네트워크를 특정하기 위해 사용(= 네트워크 ID, 네트워크 식별자(network identifier))

  `호스트 주소`  
   : 네트워크에 속한 호스트를 특정하기 위해 사용(= 호스트 ID, 호스트 식별자(host identifier))

`클래스풀 주소 체계(classful addressing)`

- 클래스를 바탕으로 IP 주소를 관리하는 주소 체계  
  하나의 IP 주소에서 네트워크 주소를 표현하는 크기와 호스트를 표현하는 크기가 유동적일 수 있다!

- `IP 주소의 클래스(class)` : 네트워크의 크기에 따라 유형별로 IP 주소를 분류하는 기준

  > (이 중 D와 E 클래스는 각각 멀티캐스트를 위한 클래스로, 특수한 목적을 위해 예약된 클래스)

  첫 옥텟의 주소만 보고도 A, B, C 클래스 중 어떤 클래스에 속한 IP 주소인지를 알 수 있습니다

  - `A 클래스`: 0.0.0.0 ~ 127.255.255.255 => 8비트 중에서 앞이 "0"으로 시작

    비트 ‘0’으로 시작 / 네트워크 : 1옥텟 / 호스트 주소 : 3옥텟

  - `B 클래스`: 128.0.0.0 ~ 191.255.255.255 => 8비트 중에서 앞으 "10'으로 시작

    비트 ‘10’으로 시작 / 네트워크 : 2옥텟 / 호스트 주소 : 2옥텟

  - `C 클래스`: 192.0.0.0 ~ 223.255.255.255 => "8비트 중에서 앞이 110"으로 시작 (192 ~ 223)

    비트 ‘110’으로 시작 / 네트워크 : 3옥텟 / 호스트 주소 : 1옥텟

> NOTE **Q. 네트워크/브로드캐스트 주소와 예약 주소호스트의 주소 공간을 모두 사용할 수 있을까?**  
> A. NO!!  
> `호스트 주소가 전부 0인 IP 주소`와 `호스트 주소가 전부 1인 IP 주소`는 특정 호스트를 지칭하는 데 사용될 수 없다.
> `호스트 주소가 전부 0인 IP 주소` : 네트워크 자체를 의미하는 주소로 사용 (e.g. 172.16.0.0)  
> `호스트 주소가 전부 1인 IP 주소` : 브로드캐스트를 위한 주소로 사용 (e.g. 172.16.255.255)  
> `+` 특수한 목적을 위해 예약된 IP 주소도 있다.  
> e.g. `루프백 주소(loopback address)` : 자기 자신을 가리키는 특별한 주소(로컬호스트)

### 클래스리스 주소 체계와 서브넷 마스크

`클래스리스 주소 체계(classless addressing)`

- 클래스를 이용하지 않고(classless) `서브넷 마스크`를 이용하여 네트워크와 호스트를 구분하는 방식
- `서브넷 마스크(subnet mask)` : IP 주소상에서 네트워크 주소를 1로 표기하고, 호스트 주소를 0으로 표기한 비트열
- `서브네트워크(서브넷, subnetwork)` : IP 주소에서 네트워크 주소로 구분할 수 있는 네트워크의 부분집합  
   서브넷 마스크 = 곧 서브넷을 구분(마스크mask)하는 비트열

- `서브네팅(subnetting)` : 서브넷 마스크를 이용해 원하는 크기로 클래스를 더 잘게 쪼개어 사용

  > 서브넷 마스크 표기법 - `CIDR 표기법(Classless Inter-Domain Routing notation)`  
  > 서브넷 마스크를 10진수가 아닌 ‘IP 주소/서브넷 마스크상의 1의 개수’의 형식으로 표기  
  > e.g.  
  > `192.168.20.3/30` > `/30`  
  > = 서브넷 마스크 상에서 1이 30개  
  > = ‘11111111.11111111.11111111.11111100’  
  > = ‘255.255.255.252’

### 공인 IP 주소와 사설 IP 주소

**Q. `IP 주소는 유일하고 고유한 주소?`**  
**A.** 고유한 IP 주소도 있고, 고유하지 않은 IP 주소도 있다. 그리고 이 두 종류의 IP 주소는 함께 사용되는 경우가 많다.

` 공인 IP 주소(public IP address)`

- 전 세계에서 고유한 IP 주소로, 인터넷을 비롯한 네트워크 간 통신에서 사용되는 IP 주소
- 호스트가 속한 네트워크 밖에서 사용하는 주소로 ISP나 공인 IP 주소 할당 기관을 통해 할당받을 수 있다.

`사설 IP 주소(private IP address)`

- 사설 네트워크(외부 네트워크에 공개되지 않은)에서 사용하기 위한 IP 주소
- 일반적으로 라우터(공유기)를 통해 할당되기 때문에 공유기(라우터)를 중심으로 구성된 LAN 대부분은 사설 네트워크에 해당한다.
- IP 주소 공간 중에서 사설 IP 주소로 사용하도록 특별히 예약된 IP 주소 공간이 있다.
- 중복될 수 있다.

### IP 주소의 할당

`정적 할당`

- 직접 수작업으로 IP 주소를 부여하는 방식
- `정적 IP 주소(static IP address)` : 정적 할당을 통해 할당된 IP 주소
- `게이트웨이(gateway)` : 서로 다른 네트워크를 연결하는 하드웨어적/소프트웨어적 수단  
  `기본 게이트웨이(default gateway)`는 호스트가 속한 네트워크의 외부로 나가기 위한 첫 기본 경로  
  => 기본 게이트웨이 = 네트워크 외부와 연결된 라우터(공유기)의 주소를 의미하는 경우가 많다.

> IP 할당의 맥락에서 사용되는 ‘게이트웨이’라는 용어는 기본 게이트웨이를 의미

- `DNS 주소`는 호스트가 도메인 네임을 토대로 IP 주소를 알아내기 위해 질의하는 서버의 주소.
  `도메인 네임` :IP 주소에 대응되는 기억할 수 있는 호스트를 식별할 수 있는 문자열 e.g. ‘google.com, hanbit.co.kr, minchul.net’
  호스트가 DNS 서버에 질의하여 도메인 네임에 대응되는 IP 주소를 알아낸다.
  `DNS 서버` : <도메인 네임, IP 주소> 쌍을 저장하는 서버

`동적 할당`

- 프로토콜을 통해 자동으로 IP 주소를 부여하는 방식
- `동적 IP 주소(dynamic IP address)` : 동적 할당을 통해 할당된 IP 주소
- 대표 프로토콜 : `DHCP(Dynamic Host Configuration Protocol)`  
  : DHCP 서버와 메시지를 주고받으며 동적 IP 주소를 할당받을 수 있다.
  `DHCP 서버` : 호스트에 할당 가능한 IP 주소 목록을 관리하다가, IP 주소 할당 요청을 받았을 때 IP 주소를 할당해 주는 호스트 , 일반적으로 라우터(공유기)가 DHCP 서버 역할을 수행한다.

1. 동적 IP 주소에는 사용 가능한 기간(임대 기간)이 정해져 있다. (‘IP 주소의 임대’)  
   `임대 갱신l(ease renewal)`도 가능
2. 동적 IP 주소는 할당받을 때마다 다른 주소를 받을 수 있다.
   => 컴퓨터의 진짜 정보를 보내는 게 아니라, 공유기가 동적으로 할당

| 유형                     | 설명                                                    | 사용 예시                            |
| ------------------------ | ------------------------------------------------------- | ------------------------------------ |
| **정적 IP (Static IP)**  | 고정된 IP 주소. 변경되지 않음.                          | 서버(웹사이트 운영, 프린터, CCTV 등) |
| **동적 IP (Dynamic IP)** | DHCP 서버가 자동으로 할당. 일정 시간 후 변경될 수 있음. | 일반 가정용 컴퓨터, 스마트폰 등      |

### IP 전송 특징의 보완: ICMP

IP : 신뢰할 수 없는 프로토콜이자, 비연결형 프로토콜 => 빠른 송수신 가능
신뢰성 + 연결형 통신이 필요하다면?

1. 신뢰할 수 있는 연결형 통신을 지원하는 상위 계층의 프로토콜을 이용하기
   TCP를 통해 패킷을 송수신하면 신뢰성과 연결형 통신을 보장할 수 있다.

2. `ICMP(Internet Control Message Protocol)`

- IP 패킷의 전송 과정에 대한 피드백 메시지(이하 ICMP 메시지)를 얻기 위해 사용하는 프로토콜  
  ICMP 메시지를 통해 패킷이 상대방에게 어떻게 전송되었는지를 알려줄 수 있어 IP 전송의 결과를 엿볼 수 있다.
  e.g.  
  [네트워크 도달 불가]: 패킷의 발신지\*수신지를 모를 경우  
  [단편화가 필요하지만 DF가 1로 설정되어 단편화할 수 없음] 처리하기에 너무 큰 패킷을 전달받았는데, DF 플래그가 설정되어 있어 단편화가 불가능할 경우  
  [시간 초과(Time Exceeded)] 패킷은 멀리 떨어진 호스트끼리 통신할 때 여러 라우터를 거쳐 이동할 수 있는데, 패킷이 하나의 라우터를 거칠 때(`홉hop`)마다 `TTL(Time To Live, 패킷의 수명)`이 1씩 감소하고, TTL 필드가 0이 되면 해당 패킷은 폐기되고 전송되는 메시지.

### IP 주소와 MAC 주소의 대응: ARP

`ARP(Address Resolution Protocol)`

- IP 주소와 MAC 주소를 함께 활용하는 통신 과정에서, 동일 네트워크 내에 있는 송수신 대상의 IP 주소를 통해 MAC 주소를 알아내는 프로토콜
- 동작 과정

  1. ARP 요청

  - 브로드캐스트 메시지(네트워크 내에 있는 모든 호스트에게 보내는 메시지)
  - 알고 싶은 MAC 주소에 대응되는 IP 주소가 포함

  2. 네트워크 내 모든 호스트가 이를 수신

  - ARP 요청 메시지에 포함된 IP 주소를 확인해 자신과 관련이 없는 IP 주소일 경우에는 무시,
  - 자신의 IP 주소일 경우에는 ARP 응답 메시지(응답 메시지를 보내는 호스트의 MAC 주소가 포함) 전달

  - `ARP 테이블(ARP Table)`  
    : ARP 테이블은 < IP 주소, MAC 주소 >의 항목들로 구성된 표 형태의 정보  
    ARP 요청 메시지와 ARP 응답 메시지를 통해 알게 된 < IP 주소, MAC 주소 > 쌍은 ARP 테이블에 추가  
    ARP 테이블 항목은 일정 시간이 지나면 삭제되고, 임의로 삭제 가능

## 4. 전송 계층 - TCP와 UDP

### 포트를 통한 프로세스 식별

네트워크 통신을 통해서 전달되는 패킷을 최종적으로 송수신해야하는 대상은 호스트가 아닌 호스트의 프로세스이다.
네트워크는 IP 주소로, 호스트는 MAC 주소로, 프로세스는 `포트(port) 번호` 통해 식별할 수 있다.
‘IP 주소:포트 번호’의 조합을 통해 통해 ‘특정 호스트가 실행하는 특정 프로세스’를 식별할 수 있다.

`포트를 통한 프로세스 식별` = 전송 계층(TCP, UDP)의 주된 목적

TCP와 UDP는 모두 포트를 통해 프로세스를 식별할 수 있다.

포트 번호는 16비트(2^16)
번호의 범위에 따라 `잘 알려진 포트`, `등록된 포트`, `동적 포트`로 나뉜다.

| 구분                                 | 포트 번호 범위      | 설명                                        | 예시                                    |
| ------------------------------------ | ------------------- | ------------------------------------------- | --------------------------------------- |
| **고정 포트 (Well-Known Ports)**     | 0번부터 1023번      | 특정 서비스가 항상 사용하는 포트 번호       | HTTP: 80, HTTPS: 443, SSH: 22           |
| **등록 포트 (Registered Ports)**     | 1024번부터 49151번  | 특정 앱이나 서비스가 등록해 사용하는 포트   | Docker: 2375, MySQL: 3306               |
| **동적/임시 포트 (Ephemeral Ports)** | 49152번부터 65535번 | 클라이언트가 통신할 때 임시로 사용하는 포트 | 브라우저가 서버에 요청할 때 자동 할당됨 |

> 서버로서 동작하는 프로그램의 경우 주로 잘 알려진 포트와 등록된 포트가 할당되는 경우가 많지만, 클라이언트로서 동작하는 프로그램의 경우에는 동적 포트 번호 중에서 임의의 번호가 할당되는 경우가 많다.
> 클라이언트 프로그램이 서버에 요청할 때마다 랜덤으로 동적 포트 번호를 할당하기 때문에 다르게 할당될 수 있다.

### NAT와 NAPT

`NAT(Network Address Translation)`

- 공인 IP 주소(네트워크 외부)와 사설 IP 주소(네트워크 내부)간 변환을 위해 사용하는 기술  
   네트워크 내부의 호스트와 네트워크 외부 호스트간의 통신을 위해서는 <u>공인 IP 주소와 사설 IP 주소 간 변환</u>이 필요하다.
- 대부분의 라우터와 (가정용)공유기는 NAT 기능을 내장 => 방향에 맞추어서 IP의 변환이 이루어진다.
- 일대일로 변환 시 많은 공인 IP 주소가 필요하기 때문에 다수의 사설 IP 주소를 그보다 적은 수의 공인 IP 주소로 변환

`NAPT(Network Address Port Translation)`

- IP 주소 변환 과정에서 변환할 IP 주소의 쌍과 더불어, 포트 번호도 함께 고려하는 <u>포트 기반의 NAT</u>
  공인 IP 주소 수의 부족 문제를 개선하는 기술로도 간주되고 있습니다

### (비)신뢰성과 (비)연결형 보장

> 표현 주의! TCP는 프로토콜이므로 "TCP로" 와 같은 표현보다는 "TCP를 통해"(== TCP라는 통신 규약을 따라서)

| 항목                 | TCP (Transmission Control Protocol)    | UDP (User Datagram Protocol)         |
| -------------------- | -------------------------------------- | ------------------------------------ |
| **연결 방식**        | 연결 지향 (3-way handshake 필요)       | 비연결 지향                          |
| **신뢰성**           | 신뢰성 보장 (데이터 순서 보장, 재전송) | 신뢰성 없음 (순서 보장 X, 손실 허용) |
| **속도**             | 느림 (신뢰성 유지 위한 오버헤드)       | 빠름 (단순한 구조)                   |
| **헤더 크기**        | 20바이트 이상                          | 8바이트                              |
| **흐름 제어**        | 있음 (수신 속도에 따라 조절)           | 없음                                 |
| **혼잡 제어**        | 있음 (네트워크 상태에 따라 속도 조절)  | 없음                                 |
| **데이터 전송 방식** | 스트림 (연속적인 데이터 흐름)          | 데이터그램 (개별 패킷 전송)          |
| **패킷 순서 보장**   | 보장함                                 | 보장하지 않음                        |
| **사용 예시**        | 웹(HTTP/HTTPS), 이메일, 파일 전송 등   | 영상 스트리밍, 음성 통화, DNS 등     |
| **오버헤드**         | 큼 (많은 부가정보 포함)                | 작음 (필수 정보만 포함)              |

> 특징으로 이해하는 TCP와 UDP
> `TCP`는 신뢰할 수 있는 연결형 송수신
> => 신뢰성과 연결성을 위한 많은 정보(헤더)와 시간이 필요
> `UDP`는 신뢰할 수 없는 비연결형 송수신
> => 작업이 덜 필요하기 때문에 시간이 덜 걸린다.

<div style="font-family:monospace; font-size:10px; border:1px solid #ccc; padding:12px; background:#f9f9f9; line-height:1.8;">
  <div style="display:flex;">
    <div style="flex:1; border:1px solid #ddd; padding:6px;">
      <strong>Source Port</strong> (16bit)<br>
      <span style="color:gray;">→ 송신자 포트 번호 (어디서 왔는지)</span>
    </div>
    <div style="flex:1; border:1px solid #ddd; padding:6px;">
      <strong>Destination Port</strong> (16bit)<br>
      <span style="color:gray;">→ 수신자 포트 번호 (어디로 가는지)</span>
    </div>
  </div>
  <div style="border:1px solid #ddd; padding:6px;">
    <strong>Sequence Number</strong> (32bit)<br>
    <span style="color:gray;">→ 전송하는 데이터의 순서 지정 (정렬에 필요)</span>
  </div>
  <div style="border:1px solid #ddd; padding:6px;">
    <strong>Acknowledgment Number</strong> (32bit)<br>
    <span style="color:gray;">→ 받은 데이터에 대한 응답 번호</span>
  </div>
  <div style="display:flex;">
    <div style="flex:0.5; border:1px solid #ddd; padding:6px;">
      <strong>Data Offset</strong> (4bit)<br>
      <span style="color:gray;">→ 헤더 길이</span>
    </div>
    <div style="flex:0.5; border:1px solid #ddd; padding:6px;">
      <strong>Reserved</strong> (4bit)<br>
      <span style="color:gray;">→ 미래 확장을 위한 공간</span>
    </div>
    <div style="flex:2; border:1px solid #ddd; padding:6px;">
      <strong>Flags</strong> (8bit)<br>
      <span style="color:gray;">→ 제어 플래그 (SYN, ACK, FIN 등)</span>
    </div>
    <div style="flex:1; border:1px solid #ddd; padding:6px;">
      <strong>Window Size</strong> (16bit)<br>
      <span style="color:gray;">→ 수신 가능한 데이터 크기 (흐름 제어)</span>
    </div>
  </div>
  <div style="display:flex;">
    <div style="flex:1; border:1px solid #ddd; padding:6px;">
      <strong>Checksum</strong> (16bit)<br>
      <span style="color:gray;">→ 오류 검출용</span>
    </div>
    <div style="flex:1; border:1px solid #ddd; padding:6px;">
      <strong>Urgent Pointer</strong> (16bit)<br>
      <span style="color:gray;">→ 긴급 데이터 위치 지정 (거의 사용 안 함)</span>
    </div>
  </div>
  <div style="border:1px solid #ddd; padding:6px;">
    <strong>Options (선택)</strong><br>
    <span style="color:gray;">→ 성능 향상 기능 (예: 윈도우 크기 조정 등)</span>
  </div>
  <div style="border:1px solid #ddd; padding:6px;">
    <strong>Data (Payload)</strong><br>
    <span style="color:gray;">→ 실제 전송하려는 데이터</span>
  </div>
</div>

---

- `제어 비트(control bits, flag bits)` : 현재 세그먼트에 대한 부가 정보를 나타내는 정보
  - ACK: 세그먼트의 승인을 나타내기 위한 비트
  - SYN: 연결을 수립하기 위한 비트
  - FIN: 연결을 종료하기 위한 비트

### TCP의 연결 과정

1. `연결 수립`
   `쓰리 웨이 핸드셰이크three-way handshake` : 세 단계로 이루어진 TCP의 연결 수립 과정

e.g.

(1) [송수신 방향 A → B] SYN 세그먼트 전송
호스트 A는 SYN 비트가 1로 설정된 세그먼트(이하 SYN 세그먼트)를 호스트 B에게 전송
이때 세그먼트의 순서 번호에는 호스트 A의 순서 번호가 포함

(2) [송수신 방향 B → A] SYN + ACK 세그먼트 전송
➊에 대한 호스트 B의 응답  
호스트 B는 ACK 비트와 SYN 비트가 1로 설정된 세그먼트(이하 SYN+ACK 세그먼트)를 호스트 A에게 전송  
세그먼트의 순서 번호에는 호스트 B의 순서 번호와 ➊에서 보낸 세그먼트에 대한 확인 응답 번호가 포함

(3) [송수신 방향 A → B] ACK 세그먼트 전송
호스트 A는 ACK 비트가 1로 설정된 세그먼트(이하 ACK 세그먼트)를 호스트 B에게 전송  
세그먼트의 순서 번호에는 호스트 A의 순서 번호와 (2)에서 보낸 세그먼트에 대한 확인 응답 번호가 포함

`액티브 오픈(active open)` : 처음 연결을 시작하는 과정 (호스트 A, 주로 클라이언트)  
`패시브 오픈(passive open)` : 연결 요청을 수신한 뒤 그에 대한 연결을 수립하는 과정(호스트 B, 주로 서버)

### TCP의 세 가지 기능

1.  TCP는 재전송을 기반으로 다양한 `오류 제어`

    - 중복된 ACK 세그먼트가 도착하거나, 타임아웃이 발생했을 경우 잘못 전송된 세그먼트가 있음을 인지하고 이를 재전송하여 오류를 제어한다.
      - 중복된 ACK 세그먼트를 수신  
         TCP의 송수신은 순서 번호를 담은 세그먼트를 보내고, 그에 대한 확인 응답이 담긴 세그먼트를 받는 과정을 반복하면서 송신한 세그먼트의 일부가 전송 중 유실되어 중복으로 ACK 세그먼트를 수신하게 되는 경우
      - 타임아웃
        호스트는 세그먼트를 전송할 때마다 `RTO(Retransmission Timeout)`를 설정하고 이에 맞추어 `재전송 타이머(retransmission timer)`를 시작한다. `타임아웃(timeout)`(타이머의 카운트다운이 끝난 상황) 발생 시점까지 ACK 세그먼트를 받지 못하면 세그먼트 전송 과정에 문제가 발생했다고 간주하여 세그먼트를 재전송

    파이프라이닝 전송
    TCP의 송수신 방식은 한 번에 여러 세그먼트를 보낼 수 있는 상황에서도 확인 응답을 받기 전까지는 보낼 수 없다 = 한 번에 하나의 세그먼트만 주고받아야 한다.
    => 확인 응답을 받기 전이라도 여러 메시지를 보내는 `파이프라이닝(pipelining) 전송` 방식으로 송수신하기도 함

2.  송수신의 `흐름 제어(flow control)`

    - TCP는 수신 호스트가 한 번에 받아 처리할 수 있을 만큼만 전송한다.
    - `흐름 제어`는 송신 호스트가 수신 호스트의 처리 속도를 고려하며 송수신 속도를 균일하게 맞추는 기능
      `+` 수신 호스트가 한 번에 받을 수 있는 전송량은 <u>TCP 수신 버퍼의 크기에 의해 결정</u>된다.
      `수신 버퍼` : 수신된 세그먼트가 애플리케이션 프로세스에 의해 읽히기 전에 임시 저장되는 공간으로, 커널에 정의되어 있다.
      수신 호스트는 TCP 헤더의 윈도우(window) 필드에 명시된 `수신 윈도우(receiver window)` 크기를 통해 송신 호스트에게 한 번에 처리 가능한 양을 알려 주고, 송신 호스트는 전달받은 해당 값을 토대로 세그먼트를 전송

3.  `혼잡 제어(congestion control)`
    `혼잡` : 많은 트래픽으로 인해 패킷의 처리 속도가 느려지거나 유실될 수 있는 상황  
    e.g. 사람이 많은 카페 등에서 네트워크 속도가 느려지는 혼잡 상황
    송신 호스트가 주체적으로 얼마나 네트워크가 혼잡한지를 판단할 수 있어야 하고, 판단된 혼잡의 정도에 따라 세그먼트의 전송량을 조절할 수 있어야한다.

    송신 호스트는 중복된 ACK 세그먼트가 도착하거나 타임아웃이 발생했을 때 ‘현재 네트워크가 혼잡할 수 있다’고 판단 -> 네트워크의 혼잡 가능성을 검출한 송신 호스트는 전송할 수 있는 최대 전송량을 송신하는 것이 아니라 ‘혼잡 없이 전송할 수 있을 정도의 양’만큼만 송신
    `혼잡 윈도우(congestion window)` : 혼잡 없이 전송할 수 있을 정도의 양을 판단하는 기준
    송신 호스트는 혼잡 윈도우의 값을 넘지 않는 선에서 세그먼트를 전송

    > 수신 윈도우는 수신 호스트가 계산, 혼잡 윈도우는 송신 호스트가 계산
    > `혼잡 제어 알고리즘(congestion control algorithm)` : 혼잡 윈도우 크기를 연산하는 방법, 즉 혼잡 제어를 수행하는 일련의 과정
    > 대표 예시 : `AIMD(Additive Increase/Multiplicative Decrease)` : ‘합으로 증가, 곱으로 감소’ / AIMD는 세그먼트를 보내고, 그에 대한 응답이 오기까지 혼잡이 감지되지 않으면 혼잡 윈도우를 1씩 선형적으로 증가시키고, 혼잡이 감지되면 혼잡 윈도우를 절반으로 떨어뜨리는 동작을 반복하는 알고리즘
    > `RTT(Round Trip Time)` : 패킷을 보내고 그에 대한 응답이 수신되기까지의 시간
    > AIMD는 ‘혼잡이 감지되지 않으면 혼잡 윈도우를 RTT마다 1씩 선형적으로 증가시키고, 혼잡이 감지되면 혼잡 윈도우를 절반으로 떨어뜨리는 알고리즘’

> 흐름 제어의 주체가 수신 호스트였다면 혼잡 제어의 주체는 송신 호스트

3. TCP의 종료
   송수신 호스트가 각자 한 번씩 FIN과 ACK를 주고받으며 TCP의 연결 종료가 이루어진다.

e.g.  
➊ [송수신 방향 A → B] FIN 세그먼트
호스트 A는 FIN 비트가 1로 설정된 FIN 세그먼트를 호스트 B에게 전송

➋ [송수신 방향 B → A] ACK 세그먼트
➊에 대한 호스트 B의 응답 호스트 B는 ACK 세그먼트를 호스트 A에게 전송

➌ [송수신 방향 B → A] FIN 세그먼트
호스트 B는 FIN 세그먼트를 호스트 A에게 전송

➍ [송수신 방향 A → B] ACK 세그먼트
➌에 대한 호스트 A의 응답, 호스트 A는 ACK 세그먼트를 호스트 B에게 전송

`액티브 클로즈active close` : 먼저 연결을 종료하려는 호스트에 의해 수행되는 동작(호스트 A에 의해 액티브 클로즈가 수행)  
`패시브 클로즈passive close` : 연결 종료 요청을 받아들이는 호스트에 의해 수행되는 동작(호스트 B에 의해 패시브 클로즈 수행)

### TCP의 상태 관리

- TCP는 상태를 유지하고 관리하는 `스테이트풀 프로토콜(stateful protocol)`이다.
- `상태(state)`란 현재 어떤 통신 과정에 있는지를 나타내는 정보로, 다양한 상태를 오간다.

➊ 연결이 수립되지 않았을 때 주로 활용되는 상태 : CLOSED와 LISTEN

➋ 연결 수립 과정에서 주로 활용되는 상태 : SYN-SENT, SYN-RECEIVED, ESTABLISHED

➌ 연결 종료 과정에서 주로 활용되는 상태 : FIN-WAIT-1, CLOSE-WAIT, FINWAIT-2, LAST-ACK, TIME-WAIT

`+` CLOSING 상태
서로가 FIN 세그먼트를 보내고 받은 뒤 각자 그에 대한 ACK 세그먼트를 보냈지만, 아직 자신의 FIN 세그먼트에 대한 ACK 세그먼트를 받지 못했을 때 접어드는 상태  
e.g. 양쪽이 동시에 연결 종료를 요청하고 서로의 종료 응답을 기다릴 경우


## 5. 응용 계층 - HTTP의 기초

응용 계층의 핵심은 `HTTP`

### DNS와 URI/URL

- IP 주소와 도메인 네임 
    `ip 주소` : `192.14.12.2`  
    `도메인 네임(domain name)` : `www.example.com`

- `DNS 서버(DNS server)` : 도메인 네임을 관리하는 서버

<div style="display:flex; flex-direction: column; gap: 2px; text-align: center;">
    <p>최상단 : 루트 도메인(root domain) => '.'</p>
    <p>↓</p>
    <p>최상위 도메인(TLD, Top-Level Domain) => ‘com, net, org, kr(대한민국), jp(일본), cn(중국), us(미국)’</p>
    <p>↓</p>
    <p>2단계 도메인(second-level domain) => '.example.com.'</p>
    <p>↓</p>
    <p>...</p>
</div>


`전체 주소 도메인 네임(FQDN, Fully-Qualified Domain Name)` : ‘www’처럼 도메인 네임을 모두 포함하는 도메인 네임

`서브 도메인(subdomain)` : 다른 도메인이 포함된 도메인  
e.g.‘mail. example.com, www.example.com, developer.example.com’ => ‘example.com’의 서브 도메인

`DNS(Domain Name System)` : 계층적으로 분산되어 있는 도메인 네임에 대한 관리 체계(애플리케이션 계층 프로토콜)

- **브라우저에 www.google.com을 입력하면 어떤 일이 일어날까요?** 에서 DNS 조회와 관련된 부분!

    > (1) 주소창에 google.com을 검색합니다.

    > (2) 브라우저가 이전 기록을 토대로 구글을 방문했었는지 확인합니다.  
    > `local name server`에서 먼저 DNS cache 조회 후 없으면 다음 단계로 넘어간다.  
        - 브라우저 캐시, OS 캐시 확인, 라우터 캐시 확인, ISP 캐시 확인  
    > ISP가 로컬 네임 서버의 주소 또는 `공개 DNS 서버(public DNS Server)`를 전달

    > (3) 요청한 주소가 캐시에 없을 경우 ISP DNS가 Root 서버에 어디로 가야하는지 요청합니다.

    > (4) Root 서버는 .com 도메인을 확인하고 com 도메인을 관리하는 TLD를 안내하고 ISP 서버는 com을 관리하는 서버에게 경로를 요청합니다.

    > (5) com 서버는 google.com을 관리하는 Authoritative DNS 서버를 알려주고
    ISP 서버는 google.com을 관리하는 서버에 요청합니다.

    > (6) google.com을 관리하는 서버는 IP 주소가 142.250.196.142라는 것을 알려줍니다.

    > (7) IP 주소를 최종적으로 확인한 ISP 서버는 해당 IP 주소를 캐싱하고 브라우저에 전달합니다

    > 3번부터 6번까지의 검색(Root -> TLD -> Authoritative DNS)을 Recursive Search라고 부르며,
    IP 주소를 찾을 때까지 반복하던가 에러가 발생할 때까지 반복합니다.
    ```

### DNS 레코드 타입

`DNS 자원 레코드(DNS resource record)` : 도메인 네임 관련 설정 정보

- 구성요소
    - 이름(Record name)과 그에 대응하는 값(Value)  
    - 레코드 타입(Record type) <이름, 값> 쌍의 유형  
    e.g. 별칭인지, IPv4와 IPv6중에 어디에 대응하는지 등등에 대한 정보
    - TTL : DNS 레코드가 캐시될 수 있는 시간 

### 자원과 URI/URL

`자원(resource)` : 네트워크 상의 메시지를 통해 주고받는 최종 대상 e.g. html, 이미지 등

- `URI(Uniform Resource Identifier)` : 자원(Resource)을 식별(Indentifier)하는 통일된 방식(Uniform)

- 식별 기준  
    `URN(Uniform Resource Name)` (이름)  
    `URL(Uniform Resource Locator)` (위치)

<div style="display:flex; flex-direction: row; gap: 10px; text-align: center;justify-content:center;">
    <div style="border:solid 1px; padding:5px">
        <p>https://</p>
        <p>scheme</p>
    </div>
    <div style="border:solid 1px; padding:5px">
        <p>www.google.com:443</p>
        <p>authority</p>
    </div>
        <div style="border:solid 1px; padding:5px">
        <p>/test</p>
        <p>path</p>
    </div>
        <div style="border:solid 1px; padding:5px">
        <p>?search=안경</p>
        <p>query</p>
    </div>
        <div style="border:solid 1px; padding:5px">
        <p>#nose</p>
        <p>fragment</p>
    </div>

</div>

- URL 구성 요소
    - `scheme`
    자원에 접근하는 방법(사용할 프로토콜)  
    e.g. ‘http://’ => HTTP를 사용하여 자원에 접근 
    
    - `authority`
    IP 주소나 도메인 네임 + 포트 번호

    -  `path`
    자원이 위치하고 있는 경로

    - `query`
    물음표(?)로 시작되는 <키=값> 형태의 데이터, 앰퍼샌드(&)를 사용해 여러 쿼리 문자열을 연결

    - `fragment`
    일반적으로 HTML 파일과 같은 자원에서 특정 부분을 가리키는 데 사용


### HTTP의 특징과 메시지 구조

- HTTP의 특징 
    - `요청 응답 기반 프로토콜` : HTTP는 요청/응답 기반 동작  
        클라이언트와 서버가 서로 HTTP 요청 메시지와 HTTP 응답 메시지를 주고받는 구조로 작동
        
    - `미디어 독립적 프로토콜` : HTTP는 미디어 독립적  
        다양한 종류의 자원을 주고받을 수 있다. HTTP는 단순히 인터페이스의 역할만 수행한다.  
        `미디어 타입media type` : HTTP에서 메시지로 주고받는 자원의 종류


    - `스테이트리스(stateless) 프로토콜` : HTTP는 상태를 유지하지 않는다.  
        - 서버는 HTTP 요청을 보낸 클라이언트 관련 상태를 기억 => 클라이언트의 모든 HTTP 요청은 기본적으로 독립적인 요청으로 간주  
        - 서버가 상태를 유지하지 않고 모든 요청을 독립적인 요청으로 처리하면 특정 클라이언트가 특정 서버에 종속되지 않아 따라서 서버의 추가나 대체가 용이


    - `지속 연결 프로토콜` : HTTP는 지속 연결을 지원  
        - HTTP 1.1 이상에서는 `지속 연결(persistent connection, keep-alive` 제공 => 하나의 TCP 연결 상에서 여러 개의 요청-응답을 주고받는다.

```md
HTTP 버전별 특징

1. HTTP 1.1 
비지속 연결을 기반으로 동작, 평문 데이터 기반 송수신

2. HTTP 2.0
바이너리 데이터 기반 송수신, 헤더 압축(이동 효율 증가), 서버 푸시(server push, 예측으로 자원 미리 응답),  
HTTP 멀티플렉싱(multiplexing) 기법: 여러 개의 독립적인 스트림(stream)을 바탕으로 요청-응답 메시지를 병렬적으로 주고받는 기술 => HOL 블로킹(Head-Of-Line blocking, HOL 블로킹이란 ‘같은 큐에 대기하며 순차적으로 처리되는 여러 패킷이 있을 때, 첫 번째 패킷의 처리 지연으로 인해 나머지 패킷들의 처리도 모두 지연되는 문제 상황) 해결

3. HTTP 3.0 
UDP 기반(QUIC, Quick UDP Internet Connections) 프로토콜 동작
```


### HTTP 메시지 구조

HTTP 메시지는 시작 라인, 필드 라인, 메시지 본문으로 구성되어 있다.

1. 시작 라인

    - 요청 라인(request line)  
        - **메서드** : ET, HEAD, POST, PUT, PATCH, DELETE ...
                        
            > `GET` : 자원 조회  
            > `HEAD`: GET 과 유사(+ 응답 메시지에 메시지 본문 X)  
            > `POST` : 특정 작업(보통 서버에 새로운 자원 생성)을 처리 요청  
            > `PUT` / `PATCH` : PUT = ‘덮어쓰기’(완전히 대체) / PATCH = ‘부분적 수정’   
            > `DELETE` : 자원 삭제  

        - 요청 대상 : path + query
        - HTTP 버전
    - 상태 라인(status line)
        - HTTP 버전
        - **상태 코드** e.g. 401, 200 등
        - 이유 구문
    
    `+` `상태 코드`
    - `1xx` : 정보 응답

        100 : Continue 요청의 일부를 받았으며 나머지를 계속 보내도 됨  

        101 : Switching Protocols 서버가 프로토콜 전환 요청을 수락함  

    - `2xx` : 성공

        200 : OK 요청이 성공적으로 처리됨

        201 : Created 요청 성공, 새 리소스가 생성됨

        202 : Accepted 요청이 수락되었지만 처리는 완료되지 않음(대용량 데이터 등 바로 응답하기 어려울 경우)

        204 : No Content 요청 성공, 응답할 콘텐츠 없음

    - `3xx` : `리다이렉션(redirection)`, 클라이언트가 요청한 자원이 다른 곳에 있을 때 다른 곳으로 요청을 이동시킨다.

        301 : Moved Permanently 요청한 리소스가 영구적으로 이동됨

        302 : Found 요청한 리소스가 임시로 다른 위치에 있음

        304 : Not Modified 캐시된 버전을 사용해도 무방함

        307 : Temporary Redirect

        308 : Permanent Redirect

        > `영구적 리다이렉션(permanent redirection)` : 자원이 완전히 새로운 곳으로 이동하여 경로가 영구적으로 재지정 => 항상 새로운 URL로 리다이렉트, 요청을 보낸 기존의 URL은 기억할 필요가 없다

        > `일시적 리다이렉션(temporary redirection)` : 자원의 위치가 임시로 변경되었거나 임시로 사용할 URL이 필요한 경우 => 요청을 보낸 기존의 URL을 기억해야 한다.

    - `4xx` : 클라이언트 오류

        400 : Bad Request 잘못된 요청 (문법 오류 등)

        401 : Unauthorized 인증이 필요함

        403 : Forbidden 요청은 이해했지만 권한이 없음

        404 : Not Found 요청한 리소스를 찾을 수 없음

        405 : Method Not Allowed 요청 방식이 허용되지 않음

        
        > `401(Unauthorized)`과 `403(Forbidden)`   
        > - 401(Unauthorized) : 인증authentication, 자신이 누구인지를 증명  
        > - 403(Forbidden) :  권한(authorization, 인가), 인증된 주체에게 허용된 작업  
        > e.g. 로그인(authenticaion), 관리자 페이지(authorization)

    - `5xx` : 서버 오류

        500 : Internal Server Error 서버 내부 오류

        501 : Not Implemented 서버가 요청을 수행할 기능을 구현하지 않음

        502 : Bad Gateway 게이트웨이 또는 프록시 서버의 잘못된 응답

        503 : Service Unavailable 서버가 과부하 또는 점검으로 사용 불가

        504 : Gateway Timeout 게이트웨이의 응답 시간이 초과됨

2. 필드 라인(field-line)

- `HTTP 헤더(HTTP header)` : HTTP 메시지 전송과 관련한 제어 정보  
    <헤더 이름(header-name) : 헤더 값(header-value)>
    - 요청 메시지 => Host, User-Agent, Referer
        - `Host`  
        : 요청을 보낼 호스트가 명시(도메인 네임이나 IP 주소 + 포트번호)
        - `User-Agent`  
        : 클라이언트의 프로그램과 관련한 정보  
        접속 수단(브라우저 등),  운영체제 및 아키텍처 정보, 렌더링 엔진의 종류 등  
            `유저 에이전트(user agent)` = HTTP 요청을 시작하는 클라이언트 측의 프로그램 (e.g. 웹 브라우저) 

        - `Referer`  
        클라이언트의 유입 경로(요청을 보낼 때 머무르던 URL)

    - 응답 메시지 => Server, Allow, Location
        - `Server`  
        : 서버 호스트와 관련된 정보(운영체제 정보 등)
        - `Allow`  
        : 처리 가능한 HTTP 헤더 목록  
        e.g. 상태 코드 405(Method Not Allowed)를 응답할 때 함께 사용


        - `Location`  
        : 클라이언트에게 자원의 위치를 알려 주는 용도  
        e.g. 리다이렉션 발생

    - 그 외
        - Date
        - Content-Length
        - Content-Type, Content-Language, Content-Encoding : `표현 헤더(representation header)`, 메시지 본문에 대한 정보
        - Connection : 송신하는 호스트가 희망하는 연결 방식 (keep-alive, close)

3. 메시지 본문  

## 6. 응용 계층 - HTTP의 응용
(465 ~ 480)

### 핵심 키워드
`쿠키`, `캐시`, `콘텐츠 협상`,`인증`, `보안`


### 쿠키(cookie)

- 서버에서 생성되어 클라이언트 측에 저장되는 <이름, 값> 쌍 형태의 데이터  
[개발자 도구] - [Application] - [Storage] - [Cookies]
이름(Name), 값(Value), 쿠키에 대한 부가 정보( Domain, Path, Expires / Max-Age 등 )

- 서버는 쿠키를 생성하여 클라이언트에 전송하고, 클라이언트는 쿠키를 저장해 두었다가 추후 같은 서버에 요청을 보낼 때 요청 메시지에 쿠키를 포함하여 전송한다.  
 서버 -> 클라이언트 : 응답 메시지의 Set-Cookie 헤더  
 클라이언트 -> 서버 : 요청 메시지의 Cookie 헤더  
`+` 서버로부터 쿠키를 전달받으면 해당 서버에 보내는 요청 메시지에는 자동으로 전달받은 쿠키가 포함된다.

- 쿠키의 속성
    - domain과 path : 쿠키를 전송할 도메인과 경로를 제한
    - Expires(만료 시점), Max-Age(초단위 유효기산) : 명시된 유효기간이 지나면 해당 쿠키는 삭제되어 사용 x
    - Secure과 HttpOnly : Secure(HTTPS를 통해서만 쿠키를 송수신 허락), HttpOnly(JS를 통한 쿠키 접근을 제한, HTTP 송수신을 통해서만 쿠키에 접근 가능)


> `웹 스토리지(web storage)` : 웹 브라우저 내의 저장 공간, 쿠키보다 더 큰 데이터 저장  
> 서버로 자동 전송 X 
> 종류 : `로컬 스토리지(local storage, 영구정 저장)`와 `세션 스토리지(session storage, 세션이 유지되는 동안 유지)`

### HTTP 캐시(웹 캐시)
- 응답받은 자원의 <u>사본</u>을 임시 저장하여 불필요한 대역폭 낭비와 응답 지연을 방지
- 저장 위치에 따른 분류
    - `개인 전용 캐시(private cache)` : 클라이언트(주로 웹 브라우저)에 저장
    - `공용 캐시(public cache)` : 중간 서버(클라이언트와 서버 사이)에 저장

- HTTP 캐시도 마찬가지로 `Expires` 헤더와 `Cache Control - MaxAge` 로 만료 시간 설정 가능
    - `캐시 신선도(cache freshness)`  
    : 원본 데이터와 캐시 내의 사본데이터의 유사(일관성)한 정도  
    만료된 자원을 재요청하여 캐시 신선도 검사, 자원 재응답받아 캐시 신선도를 높게 유지
    
    - 클라이언트는 캐시된 자원의 유효기간이 만료되었을 때, 서버에게 원본 자원이 변경된 적이 있는지 확인 -> 서버의 응답에 따라 유효기간을 연장 vs 새로운 자원 응답 할지 결정

        - `날짜` 기반 : `If-Modified-Since 헤더`  
            1. 서버가 요청받은 자원이 변경된 경우
                상태 코드 200(OK) + 새로운 자원을 반환
            2. 서버가 요청받은 자원이 변경되지 않은 경우
                상태 코드 304(Not Modified) + `Last-Modified 헤더`로 마지막 변경 시점 알림
            3. 서버가 요청받은 자원이 삭제된 경우
                상태 코드 404(Not Found)로 요청한 ‘자원이 존재하지 않음’을 알림

        - `엔티티 태그` 기반 : 엔티티 태그(Entity Tag, Etag) = ‘자원의 버전’을 식별하기 위한 정보
            자원이 변경될 때마다 자원의 버전을 식별하는 Etag 값이 변경  
            If-None-Match 헤더에 Etag 값이 명시

            1. 서버가 요청받은 자원이 변경된 경우
                상태 코드 200(OK) + 새로운 자원을 반환
            
            2. 서버가 요청받은 자원이 변경되지 않은 경우
                상태 코드 304(Not Modified) + 클라이언트는 캐시된 자원을 사용
            
            3. 서버가 요청받은 자원이 삭제된 경우
                상태 코드 404(Not Found)로 요청한 ‘자원이 존재하지 않음’을 알림


### 콘텐츠 협상

`콘텐츠 협상(content negotiation)` : 같은 자원에 대해 할 수 있는 여러 표현 중 클라이언트가 가장 적합한 자원의 표현을 제공하는 것

> HTTP 메시지를 통해 주고받는 것은 좀 더 엄밀히 말하자면 '자원의 표현'이다.
> `표현(representation)` : ‘송수신 가능한 자원의 형태’  
> e.g. 동일한 자원을 요청했더라도(동일한 URL) 한국어로 표현된 자원이 응답될 때가 있고, 영어로 표현된 자원이 응답될 때가 있음
> ‘자원 조회’ => ‘자원의 <u>특정 표현</u> 조회’

- 콘텐츠 협상 헤더입니다.
    - Accept: 선호하는 미디어 타입
    - Accept-Language: 선호하는 언어를 나타내는 헤더
    - Accept-Encoding: 선호하는 인코딩 방식을 나타내는 헤더

    > e.g.  
    >
    > GET /index.html HTTP/1.1    
    > Host: example.com  => example.com에서 요청을 보냈어!  
    > Accept-Language: ko-KR,ko;q=0.9,en-US;q= 0.8,en;q=0.7    
    => ko를 원하고, ko, en 순서대로 언어를 선호해 
    > Accept: text/html,application/xml;q= 0.9,text/plain;q=0.6,*/*;q= 0.5    
    => html과 xml, 일반 텍스트의 순으로 선호해  
    > `+` q값(Quality Value) : 0부터 1, 값이 클수록 우선순위가 높다.


### 보안: SSL/TLS와 HTTPS

`HTTPS(HTTP over TLS, HTTP Secure)` :  HTTP + SSL or TLS
- 웹사이트와 여러분의 브라우저 간에 SSL/TLS 기반 암호화 통신

- `SSL(Secure Sockets Layer)` : 인증과 암호화를 수행하는 프로토콜
    `TLS(Transport Layer Security)` : SSL을 계승한 프로토콜

- TLS 1.3 기반 HTTPS 메시지 송수신 과정  
TCP 쓰리 웨이 핸드셰이크 -> **TLS 핸드셰이크** -> 암호화된 메시지 송수신


- `TLS`에서의 포인트는 `암호화 통신을 위한 키를 생성/교환`, `인증서 송수신과 검증`

    - ‘암호화 통신을 위한 키’  
        `ClientHello 메시지`와 `ServerHello 메시지`를 주고받으며 암호화된 통신을 위해 사전 협의해야 할 정보들이 결정  
        ClientHello 메시지가 암호화 이전에 맞춰 봐야 할 정보들을 제시하는 메시지라면, ServerHello 메시지는 제시된정보들을 선택하는 메시지  
        > - `ClientHello 메시지` : 맞춰봐야 할 정보 제시  
        > 지원되는 TLS 버전 / 사용 가능한 암호화 알고리즘과 해시 함수(`암호 스위트(cipher suite)`) / 키를 만들기 위해 사용할 클라이언트의 난수 등  
        > 
        > - `ServerHello 메시지` : 제시된 정보들 중 선택한 것 전송  
        선택된 TLS 버전, 암호 스위트 등의 정보, 키를 만들기 위해 사용할 서버의 난수

    - `인증서 송수신과 검증`    
        - `인증서` : 공개 키 인증서(public key certificate)
            - 통신을 주고받는 대상이 의도한 대상이 맞다는 사실을 입증하기 위한 정보
            - 제3의 인증 기관(CA, Certification Authority)에서 인증서의 발급과 검증, 저장 등의 역할을 수행

        - `Certificate 메시지` : 인증서 내용(인증서 서명 값 등)이 포함  
            `CertificateVerify 메시지` : 인증서의 내용을 검증하기 위한 메시지 

서버와 클라이언트는 암호화에 사용할 키 획득  
-> 서로가 송수신 대상임을 인증  
-> Finished 메시지를 주고받고, TLS 핸드셰이크를 통해 얻어낸 키를 기반으로 암호화된 데이터를 주고받는다.

> TLS 1.2와 1.3의 차이
>
> `TLS 1.2 핸드셰이크 흐름`  
> TLS 1.2에서는 먼저 클라이언트가 `ClientHello` 메시지를 보내고, 서버는 `ServerHello`, 인증서, 키 교환 정보를 순차적으로 응답합니다. 클라이언트는 서버 인증서를 검증한 뒤, 세션 키 생성을 위한 `pre-master secret`을 서버의 공개키로 암호화해 전달하고, 이 값을 기반으로 양쪽이 세션 키를 생성합니다. 그 후 `Finished` 메시지를 주고받으며 핸드셰이크가 완료됩니다. 이 과정은 보통 `2-RTT` 이상 걸립니다.
> 
> `TLS 1.3 핸드세이크 흐름`  
> TLS 1.3에서는 클라이언트가 처음 `ClientHello` 메시지에 키 교환 정보까지 함께 보내며 시작하고, 서버는 `ServerHello`, 인증서, CertificateVerify, Finished 메시지를 한 번에 응답합니다. 클라이언트는 인증서를 검증하고 Finished 메시지를 보내며, 이 시점부터 암호화 통신이 시작됩니다. 이 과정은 암호화 키 교환과 인증을 병렬적으로 처리하기 때문에 기본적으로 `1-RTT`만에 핸드셰이크가 완료됩니다.
>
> ---
> TLS 1.2는 키 교환과 인증이 순차적으로 이루어져 시간이 더 걸리고, RSA 키 교환 같은 구식 방식도 사용됩니다. 반면 TLS 1.3은 키 교환과 인증이 동시에 병렬로 이루어지고, Forward Secrecy가 보장되는 ECDHE 기반 키 교환만 사용되며, 불필요한 요소들이 제거되어 보안성과 성능 모두 개선되었습니다.
>
> **추가 정보** : RSA, pre-master secret, RTT
> 
> RSA  
> RSA는 공개키 암호화 알고리즘 중 하나로, TLS 1.2에서는 서버가 공개키를 클라이언트에 전달하고, 클라이언트는 이 공개키로 암호화한 데이터를 서버에게 보냅니다. 대표적으로 TLS 1.2에서 pre-master secret을 암호화해서 전송할 때 사용되었습니다.
> 하지만 RSA 방식은 서버 개인키가 탈취될 경우 과거 세션까지 복호화가 가능하기 때문에, TLS 1.3에서는 보안성 강화를 위해 RSA 기반 키 교환이 제거되었습니다.
> 
> pre-master secret
> 
> pre-master secret은 TLS 핸드셰이크 과정에서 세션 키(대칭키)를 만들기 위한 중간 값입니다.
> 예를 들어 TLS 1.2에서는 클라이언트가 이 값을 생성한 후, 서버의 공개키로 암호화해 전송합니다.
> 이후 클라이언트와 서버는 서로 가지고 있는 pre-master secret과 난수(client_random, server_random)를 기반으로 같은 세션 키를 계산하게 됩니다.
> TLS 1.3에서는 이 pre-master secret이 Diffie-Hellman 기반 공유 비밀로 대체되어 forward secrecy를 보장합니다.
> 
> RTT(Round Trip Time)
> 
> **RTT (Round Trip Time)**는 클라이언트가 서버로 메시지를 보낸 후, 서버로부터 응답을 받아오는 데 걸리는 왕복 시간을 의미합니다.
> TLS에서는 몇 번의 RTT가 있어야 핸드셰이크가 완료되는지가 성능에 매우 중요한데,
> TLS 1.2는 키 교환과 인증이 순차적으로 진행되어 최소 2-RTT가 소요됩니다.
> 반면, TLS 1.3은 핸드셰이크 과정이 단순화되고 병렬화되어 1-RTT,
> 경우에 따라선 0-RTT까지도 가능합니다.
> RTT가 줄어들면 연결이 빨라지고 사용자 경험도 향상됩니다.


## 7. 프록시와 안정적인 트래픽
(481 ~ 494)

### 핵심 키워드
트래픽, 오리진 서버, 중간 서버, 고가용성, 게이트웨이, 로드 밸런싱, 

### 오리진 서버와 중간 서버

일반적으로 클라이언트와 서버 사이에는 다양한 네트워크 장비와 중간 서버가 존재한다.
이를 분류하기 위해서 자원을 생성하고 클라이언트에게 권한이 있는 응답을 보낼 수 있는 HTTP 서버를 `오리진 서버(originserver)`라 하고, 그 사이의 서버들을 중간 서버로 분리한다.

### 가용성과 고가용성

- `가용성(availability)` : 주어진 특정 기능을 실제로 수행할 수 있는 시간의 비율
- `uptime` (정상적인 사용 시간)과 `downtime`(어떠한 이유로 정상적인 사용이 불가능한 시간)을 통한 비율값을 통해 안정성을 평가한다.

<p style="text-align:center;">가용성 = (업타임) / (업타임 + 다운타임)</p>

>  ‘파이브 나인스’ : 99.999% (9가 다섯 개)

- `고가용성(HA, High Availability, 가용성의 비율값이 높음)`을 유지하기 위해서는 문제를 없애는 것보다 <u>문제가 발생하더라도 계속 기능할 수 있도록 설계하는 것</u>에 집중해야한다.
- `결함 감내(fault tolerance)` : 문제가 발생하더라도 기능할 수 있는 능력  
=> 서비스나 인프라가 결함을 감내할 수 있도록 설계하기! e.g. 서버를 다중화하기

> `페일오버(failover)` : 동작하는 시스템에 문제가 생겼을 때 예비된 시스템으로 자동 전환되는 기능

### 중간서버 : 프록시와 게이트웨이

- `프록시(proxy)` : 클라이언트에 가까운 중간 서버, 주로 캐시 저장, 클라이언트 암호화 및 접근 제한 등의 기능 제공

- `게이트웨이(gateway)` : 서버에 가까운 중간 서버, 캐시 저장, 부하 분산 등의 로드 밸런서로 동작

- `헬스 체크(health check)` : 다중화된 서버 환경에서 서버의 상태를 주기적으로 검사하는 것, 주로 로드 밸런서에 의해 수행, 다양한 프로토콜 활용 가능

- `하트비트(heartbeat)` : 서버 간에 주기적으로 하트비트 메시지를 주고받으며 메시지가 끊겼을 때 문제의 발생을 감지하는 방법

-------


### 로드 밸런싱

- 과도한 트래픽은 서버의 가용성을 떨어뜨린다. (발열 문제와 레이스컨디션, 메모리 부족)  
=> 다중화된 서버에서도 트래픽을 올바르게 분산하여 수신하는 것이 중요(로드 밸런싱)

- `로드 밸런싱(load balancing)`  
    - 여러 서버에 네트워크 트래픽(요청)을 고르게 분산시켜 시스템의 성능 및 안정성을 높이는 기술
    - `로드 밸런서(load balancer)`에 의해 수행  
    - 로드 밸런서는 다중화된 서버와 클라이언트 사이에 위치하며 클라이언트의 요청(들)을 각 서버에 균등하게 분배  
    - 로드 밸런서는 네트워크 장비(L4 스위치, L7 스위치)로도 가능, 로드 밸런싱 기능을 제공하는 소프트웨어를 설치하면 일반 호스트도 로드 밸런서로 사용 가능 (e.g. HAProxy, Envoy, Nginx에도 로드 밸런싱 기능 내장)
    - 로드 밸런싱 알고리즘 : 로드 밸런서가 부하를 균등하게 분산되도록 요청을 전달할 서버를 선택하는 방법
        e.g. `라운드 로빈 알고리즘(round robin algorithm)`(단순히 서버를 돌아가며 부하를 전달), `최소 연결 알고리즘(least connection algorithm)`(연결이 적은 서버부터 우선적으로 부하를 전달)  
    > `+` 단순히 다중화된 모든 서버에 균일한 부하를 부여하는 전략은 모든 서버의 성능이 동일하다는 전제가 있을 때만 유효하다는 것 유의하기
    > 그래서 이를 개선하기 위해 가중치를 부여하기도 한다.(가중치 알고리즘)


### 스케일링: 스케일 업 스케일 아웃

오토스케일링

`스케일링(scaling)` : 시스템의 성능, 용량, 처리 능력 등을 확장하거나 줄이는 과정

`+` 여기서의 시스템은 서버 또는 컴퓨터 한 대를 의미

- `스케일 업(scale-up)` : 기존 부품을 더 나은 사향으로 교체, 

||`스케일 업(scale-up)`|`스케일 아웃(scale-out)`|
|----|-----|----|
|설명|기존 부품을 더 나은 사향으로 교체| 부품을 여러 개로 추가|
||`수직적 확장(vertical scaling)`|`수평적 확장(horizontal scaling)`|
|장점|설치와 구성의 단순함|유연한 확장 및 축소 |

> `+` `오토스케일링(autoscaling)` : 필요할 때마다 시스템을 동적으로 확장 및 축소  
> e.g.티켓팅, 수강신청, 여행 사이트  
> 웹 서버나 데이터베이스와 같은 자원을 임대하는 클라우드 서비스 업체의 경우 대부분 이러한 오토스케일링 서비스를 제공하고 있습니다. 

### Nginx로 알아보는 로드 밸런싱

`Nginx` : 웹 서버 프로그램, 포워드 프록시나 리버스 프록시로서의 기능도 제공 (콘텐츠 캐싱, 보안을 위한 접근 제한, 로드 밸런싱)

- 흐름이 중심이 되는 경우
    - `업스트림(upstream)` : 클라이언트 ->  오리진 서버로 향하는 트래픽
    - `다운스트림(downstream)` : 오리진 서버 -> 클라이언트로 향하는 트래픽 

- 기준점이 중심이 되는 경우
    - `인바운드(inbound)` 트래픽 : 네트워크 외부에서 내부로 들어오는 트래픽  
    e.g. 외부 사용자가 내부 네트워크의 서버나 서비스에 접근하려는 요청(외부 인터넷 사용자들이 회사 웹사이트에 접속하는 트래픽)
    - `아웃바운드(outbound)` 트래픽 : 내부 네트워크에서 외부로 나가는 트래픽  
    e.g. 내부 시스템이나 사용자들이 외부 서버나 서비스에 요청(회사 직원이 외부 웹사이트를 방문하는 트래픽)

## 면접 질문 리스트(교재 버전)
<div style="font-family: sans-serif; line-height: 1.6;">
    <div>네트워크(1)</div>
    <details>
    <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">브로드캐스트가 무엇이며, 언제 사용하는지 설명해 보세요.</strong></summary>
    <p><strong style="color: #999;">A.</strong> 브로드캐스트란 네트워크 내 모든 호스트에게 패킷을 전송하는 전송 방식을 말합니다. 브로드캐스트가 사용되는 대표적인 상황에는 ARP request를 보내는 상황이 있습니다.</p>
    </details>
    <details>
    <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">캡슐화가 무엇인지 설명해 보세요.</strong></summary>
    <p><strong style="color: #999;">A.</strong> 네트워크 송신 과정에서 네트워크 참조 모델의 상위 계층 패킷은 하위 계층의 트레일러가 되어 헤더가 덧붙는 과정이 반복됩니다. 네트워크를 통한 송신 과정에서 여러 프로토콜 헤더가 덧붙는 이 과정을 캡슐화라고 합니다. 이때 덧붙은 헤더는 수신지에서 역캡슐화를 거쳐 제거됩니다.</p>
    </details>
    <details>
    <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">MAC 주소와 IP 주소가 각각 무엇인지, 왜 두 주소를 함께 사용하는지 설명해 보세요.</strong></summary>
    <p><strong style="color: #999;">A.</strong> MAC 주소는 네트워크 인터페이스에 할당되는 물리적 주소로, 로컬 네트워크 내에서 장치를 식별하는 데 사용합니다. IP 주소는 네트워크 간 통신에서 호스트를 식별하는 논리적 주소입니다. MAC 주소만으로는 라우팅이 불가능하므로, 네트워크 간 통신을 위해 IP 주소도 함께 사용합니다.</p>
    </details>
    <details>
    <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">서브네팅을 하는 이유를 설명해 보세요.</strong></summary>
    <p><strong style="color: #999;">A.</strong> 서브네팅은 IP 주소를 기반으로 네트워크를 더 작은 서브네트워크로 나누기 위해 사용됩니다. 이를 통해 IP 주소 공간을 효율적으로 활용하고, 네트워크를 체계적으로 관리할 수 있습니다.</p>
    </details>
    <details>
    <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">NAT에 대해 설명해 보세요.</strong></summary>
    <p><strong style="color: #999;">A.</strong> NAT는 IP 주소를 변환하는 기술로, 사설 IP 주소와 공인 IP 주소 간의 변환을 수행합니다. 하나의 공인 IP를 여러 사설 IP와 매핑할 수 있어, IP 주소 부족 문제를 해결하고 보안성도 향상됩니다.</p>
    </details>
    <details>
    <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">TCP와 UDP의 차이점이 무엇인지, 두 방식을 사용하는 경우가 어떻게 다른지 설명해 보세요.</strong></summary>
    <p><strong style="color: #999;">A.</strong> TCP는 신뢰성 있는 연결형 프로토콜로, 데이터 순서 보장과 오류 제어가 가능합니다. UDP는 비연결형으로 빠르지만, 데이터 유실 가능성이 있습니다. 신뢰성이 중요한 경우 TCP, 실시간성이 중요한 경우 UDP를 사용합니다.</p>
    </details>
    <details>
    <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">TCP의 연결 수립 과정을 설명해 보세요.</strong></summary>
    <p><strong style="color: #999;">A.</strong> TCP 연결 수립은 쓰리 웨이 핸드셰이크 과정을 거칩니다. 클라이언트가 SYN 패킷을 보내고, 서버가 SYN-ACK로 응답한 후, 클라이언트가 ACK를 보내면 연결이 성립됩니다.</p>
    </details>
    <details>
    <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">포트 번호란 무엇이며, 왜 포트 번호가 존재해야 하는지 설명해 보세요.</strong></summary>
    <p><strong style="color: #999;">A.</strong> 포트 번호는 IP 주소를 가진 장치 내에서 특정 프로세스를 식별하는 데 사용됩니다. 이를 통해 여러 프로세스가 동시에 네트워크를 사용할 수 있습니다.</p>
    </details>
    <details>
    <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">HTTP가 스테이트풀한지, 스테이트리스한지에 대해 그 이유와 함께 설명해 보세요.</strong></summary>
    <p><strong style="color: #999;">A.</strong> HTTP는 스테이트리스 프로토콜입니다. 서버는 클라이언트의 상태를 저장하지 않으며, 각 요청은 독립적으로 처리됩니다. 이로 인해 서버 확장성과 유지 관리가 용이해집니다.</p>
    </details>
    <details>
    <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">‘https://www.google.com’을 입력해 웹사이트가 뜨기까지의 과정을 설명해 보세요.</strong></summary>
    <p><strong style="color: #999;">A.</strong> 먼저 DNS를 통해 도메인에 대한 IP를 조회하고, TCP 쓰리 웨이 핸드셰이크로 연결을 수립합니다. HTTPS인 경우 TLS 핸드셰이크로 보안 연결을 설정하고, 이후 HTTP GET 요청을 보내고 서버의 응답을 받아 웹 페이지를 렌더링합니다.</p>
    </details>
    <details>
    <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">‘www.example.com’을 ‘1.2.3.4’ IP에 연결하는 과정을 설명해 보세요.</strong></summary>
    <p><strong style="color: #999;">A.</strong> DNS 서비스 제공자의 관리 페이지에서 A 레코드를 추가하여 ‘www.example.com’을 ‘1.2.3.4’ IP 주소와 매핑합니다. 이렇게 하면 사용자가 도메인을 입력했을 때 해당 IP로 연결됩니다.</p>
    </details>
    <div>네트워크(2)</div>
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">[오늘 하루 그만보기] 기능은 어떻게 구현할 수 있나요?</strong></summary>
        <p><strong style="color: #999;">A.</strong> 쿠키를 사용하여 클라이언트의 상태를 저장함으로써 구현할 수 있습니다. 일정 시간이 지나기 전까지 동일한 쿠키가 존재하면 해당 기능을 다시 표시하지 않습니다.</p>
    </details>
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">HTTP의 킵 얼라이브란 무엇인가요?</strong></summary>
        <p><strong style="color: #999;">A.</strong> 킵 얼라이브는 클라이언트와 서버 간의 연결을 일정 시간 동안 유지하여, 같은 TCP 연결로 여러 요청과 응답을 처리할 수 있도록 해주는 기능입니다.</p>
    </details>
    <details>
    <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">HTTP 1.1과 HTTP 2.0의 차이점을 설명해 보세요.</strong></summary>
    <p><strong style="color: #999;">A.</strong> HTTP 2.0은 바이너리 프레이밍을 사용하고, 헤더 압축, 서버 푸시, 멀티플렉싱 등을 통해 성능을 향상시켰습니다. HTTP 1.1은 텍스트 기반이며 HOL 블로킹 문제가 존재합니다.</p>
    </details>
    <details>
    <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">HTTP 메서드인 GET과 POST의 차이를 예시와 함께 설명해 보세요.</strong></summary>
    <p><strong style="color: #999;">A.</strong> GET은 데이터를 조회할 때 사용되며 URL에 데이터가 포함됩니다. 예: 검색 쿼리 전달. POST는 데이터를 전송할 때 사용되며 본문에 데이터를 담습니다. 예: 로그인 정보 제출.</p>
    </details>
    <details>
    <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">HTTP 메서드인 PUT과 PATCH의 차이를 예시와 함께 설명해 보세요.</strong></summary>
    <p><strong style="color: #999;">A.</strong> PUT은 전체 자원을 수정(덮어쓰기)할 때 사용하고, PATCH는 자원의 일부만 수정할 때 사용합니다.</p>
    </details>
    <details>
    <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">리다이렉션의 정확한 의미를 설명해 보세요.</strong></summary>
    <p><strong style="color: #999;">A.</strong> 리다이렉션은 클라이언트가 요청한 자원이 다른 위치로 이동했을 때, 웹 서버가 새로운 위치로 클라이언트를 자동으로 이동시키는 기능입니다.</p>
    </details>
    <details>
    <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">HTTP 요청 메시지를 보낸 클라이언트들이 이전에 접속한 URL을 알고 싶을 때는 어떻게 해야 할까요?</strong></summary>
    <p><strong style="color: #999;">A.</strong> Referer 헤더를 확인하면 클라이언트가 이전에 접속했던 URL 정보를 확인할 수 있습니다.</p>
    </details>
    <details>
    <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">HTTP 요청 메시지를 보낸 클라이언트들의 접속 정보를 알고 싶을 때는 어떻게 해야 할까요?</strong></summary>
    <p><strong style="color: #999;">A.</strong> User-Agent 헤더를 통해 클라이언트의 브라우저 종류, 운영체제, 아키텍처 등 정보를 확인할 수 있습니다.</p>
    </details>
    <details>
    <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">같은 URL에 접속해도 환경에 따라 다른 언어로 응답되는 이유는 무엇인가요?</strong></summary>
    <p><strong style="color: #999;">A.</strong> HTTP 콘텐츠 협상(Content Negotiation) 기능 때문입니다. 클라이언트는 Accept-Language 헤더를 통해 선호 언어를 명시하고, 서버는 그에 따라 응답 언어를 결정합니다.</p>
    </details>
    <details>
    <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">HTTP 캐시가 오래될 경우 원본 데이터와 차이가 발생할 수 있습니다. 이를 해결하는 방법은 무엇인가요?</strong></summary>
    <p><strong style="color: #999;">A.</strong> If-Modified-Since 또는 If-None-Match 헤더를 사용하여 서버에 변경 여부를 확인합니다. 변경이 없으면 304 Not Modified를, 변경되었다면 새로운 데이터를 반환받습니다.</p>
    </details>
    <details>
    <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">HTTPS의 동작에 대해 HTTP와 비교하여 설명해 보세요.</strong></summary>
    <p><strong style="color: #999;">A.</strong> HTTPS는 HTTP 위에 TLS를 추가하여 암호화된 통신을 제공합니다. TCP 연결 후 TLS 핸드셰이크를 통해 인증서 검증 및 키 교환이 이루어집니다.</p>
    </details>
    <details>
    <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">포워드 프록시와 리버스 프록시의 차이를 설명해 보세요.</strong></summary>
    <p><strong style="color: #999;">A.</strong> 포워드 프록시는 클라이언트 가까이에 있어 요청을 서버에 전달하고, 리버스 프록시는 서버 가까이에 있어 요청을 받아 서버로 전달한 후 응답을 클라이언트에 전달합니다.</p>
    </details>
    <details>
    <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">스케일 업과 스케일 아웃의 차이를 설명해 보세요.</strong></summary>
    <p><strong style="color: #999;">A.</strong> 스케일 업은 기존 서버의 성능을 높이는 방식이고, 스케일 아웃은 서버의 수를 늘리는 방식입니다. 전자는 간단하지만 한계가 있고, 후자는 확장성과 고가용성이 높습니다.</p>
    </details>
    <details>
    <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">웹 서버와 웹 애플리케이션의 차이점 및 함께 사용하는 이유를 설명해 보세요.</strong></summary>
    <p><strong style="color: #999;">A.</strong> 웹 서버는 정적 콘텐츠를 제공하고, 웹 애플리케이션 서버는 동적 콘텐츠를 생성합니다. 둘을 함께 사용하면 부하 분산과 성능 향상이 가능합니다.</p>
    </details>
</div>

## 면접 예상 질문 : 추가 질문

### 네트워크(1)
<div>
    <!-- 첫번째 질문 -->
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">IP 주소가 무엇이고, OSI 7계층 중에 어느 계층에서 사용하는지 설명해주세요.</strong></summary> 
        <p>
            <strong style="color: #999;">A.</strong>
            IP 주소는 인터넷 프로토콜(Internet Protocol) 주소의 약자로, 네트워크 상의 장치를 식별하기 위한 고유한 주소입니다. 마치 집 주소처럼, 네트워크에서 데이터의 목적지를 지정하는 데 사용됩니다. 
            IP 주소는 OSI 7계층 중 ‘3계층인 네트워크 계층(Network Layer)’에서 사용됩니다. 이 계층은 데이터를 목적지까지 전달하는 경로를 결정(라우팅)하고,  목적지 호스트를 식별하기 위해 IP 주소를 사용합니다.
        </p>
    </details>
    <!-- 두번째 질문 -->
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">TCP와 UDP의 차이점은 무엇인가요?</strong></summary> 
        <p>
            <strong style="color: #999;">A.</strong>
            TCP와 UDP는 전송 계층(OSI 4계층)의 프로토콜로, 데이터를 전송하는 방식에 따라 큰 차이점이 있습니다.
            TCP는 연결형 프로토콜로 데이터의 순서, 무결성, 신뢰성을 보장합니다. 웹(HTTP/HTTPS), 이메일(SMTP), 파일 전송(FTP) 등 정확한 전송이 중요한 서비스에 사용됩니다.
            UDP는 비연결형 프로토콜로 사전 연결 없이 데이터를 빠르게 전송합니다. 속도는 빠르지만 신뢰성은 낮습니다. 실시간 스트리밍, 온라인 게임, VoIP 등 지연보다 속도가 중요한 서비스에 사용됩니다.
        </p>
    </details>
    <!-- 세번째 질문 -->
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">TCP 송수신 중 연결은 어떻게 맺어지나요?</strong></summary> 
        <p>
            <strong style="color: #999;">A.</strong>
            TCP 연결은 3-way handshake 과정을 통해 맺어집니다. 먼저 클라이언트가 서버에 SYN 패킷을 보내 연결을 요청하고, 서버는 이를 수신한 뒤 SYN-ACK 패킷으로 응답합니다. 그 다음 클라이언트가 ACK 패킷을 보내면 연결이 성립됩니다. 이 과정을 통해 양측 모두 연결 의사를 확인하고, 초기 시퀀스 번호를 교환하여 통신을 시작하게 됩니다.
        </p>
    </details>
    <!-- 네번째 질문 -->
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">같은 공유기를 사용하는 두 컴퓨터에서 같은 포트를 사용하는 클라이언트 프로그램이 실행될 경우, 어떻게 통신이 구분되나요?</strong></summary> 
        <p>
            <strong style="color: #999;">A.</strong>
            NAPT(Network Address Port Translation)를 통해 문제없이 통신이 가능합니다. 각 컴퓨터는 서로 다른 사설 IP 주소를 가지고 있고, 공유기는 이 사설 IP와 내부 포트 번호를 자신의 공인 IP 주소 + 고유한 외부 포트 번호로 매핑하여 NAT 테이블에 기록합니다. 서버에 요청을 보낼 때는 이 공인 IP + 외부 포트 조합이 발신지로 사용되기 때문에, 같은 내부 포트를 사용하더라도 공유기 차원에서는 서로 다른 연결로 인식할 수 있습니다.
        </p>
    </details>
    <!-- 다섯번째 질문 -->
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">공유기가 내부와 외부 통신을 관리할 때 어떤 정보를 기반으로 NAT 테이블을 만드나요?</strong></summary> 
        <p>
            <strong style="color: #999;">A.</strong>
            공유기는 사설 IP 주소, 내부 포트 번호, 공인 IP, 변환된 외부 포트, 목적지 IP와 포트 등의 정보를 기반으로 NAT 테이블을 구성합니다. 이 테이블을 통해, 외부에서 응답이 도착하면 어떤 내부 장치에게 전달해야 하는지를 정확히 파악할 수 있습니다. 이러한 매핑 덕분에 다수의 장치가 동시에 동일한 외부 서버에 요청을 보내더라도 충돌 없이 응답을 받을 수 있습니다.
        </p>
    </details>
    <!-- 여섯번째 질문 -->
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">포트포워딩은 어떤 경우에 꼭 필요한가요? 소켓 통신의 경우와 비교해서 설명해주세요.</strong></summary> 
        <p>
            <strong style="color: #999;">A.</strong>
            외부에서 내부 네트워크로 먼저 접속하려고 할 때 외부에서는 공유기까지만 볼 수 있고, 공유기 뒤에 있는 컴퓨터는 직접적으로 접근할 수 없습니다. 따라서 외부에서 특정 컴퓨터로 접근하기 위해서는 공유기에 "해당 공유 IP와 포트로 통신이 오면 내가 설정한 사설 IP의 포트번호로 전달해줘"하고 설정해줘야합니다. 이러한 설정을 포트 포워딩이라고 합니다.
        </p>
    </details>
    <!-- 여섯번째 질문에서 연결되는 문제 -->
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">집에서 웹 서버를 로컬에서 실행 중인데, 외부에서 접속하려면 어떻게 해야 하나요?</strong></summary> 
        <p>
            <strong style="color: #999;">A.</strong>
            네, 내부 네트워크에서 실행 중인 웹 서버에 외부에서 접속하려면 포트 포워딩 설정이 필요합니다. 예를 들어, 제 컴퓨터의 IP가 192.168.0.5이고, 웹 서버가 3000번 포트에서 실행 중이라면, 공유기 설정 페이지에 접속해 포트 포워딩 설정을 통해 내부 장치와 포트 매핑을 정확히 지정하여야합니다.
        </p>
    </details>
    <!-- 여덟번째 질문 -->
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">WebSocket처럼 서버가 클라이언트에게 데이터를 보낼 수 있는 통신에서, 클라이언트는 사설 IP인데도 왜 포트포워딩이 필요하지 않나요?</strong></summary> 
        <p>
            <strong style="color: #999;">A.</strong>
            WebSocket은 클라이언트가 먼저 서버에 연결을 생성하면서 통신이 시작됩니다.
            이 과정에서 클라이언트의 NAT(공유기)는 서버와의 연결 정보를 NAT 테이블에 저장하게 됩니다. 이 TCP 연결이 유지되는 동안에는 서버도 해당 연결을 통해 클라이언트에게 데이터를 전송할 수 있기 때문에,별도의 포트포워딩 없이도 양방향 통신이 가능합니다. 즉, 서버가 먼저 클라이언트에 접속하는 것이 아니라,클라이언트가 먼저 연결을 열어둔 상태에서만 서버의 푸시 메시지가 가능한 구조이기 때문입니다.
        </p>
    </details>
    <!-- 아홉번째 질문 -->
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">서버에서 클라이언트에게 데이터를 "먼저" 보내는 방식과, 포트포워딩과의 관계를 설명해주세요.</strong></summary> 
        <p>
            <strong style="color: #999;">A.</strong>
            일반적으로 서버가 클라이언트에게 먼저 데이터를 보내는 것은 기존에 연결이 생성된 상태에서만 가능합니다. 예를 들어, WebSocket이나 TCP 소켓 통신에서는 클라이언트가 먼저 서버에 연결 요청을 보내고, 이로 인해 양방향 통신 가능한 TCP 연결이 생성됩니다. 이 연결을 통해 서버는 클라이언트에게 데이터를 보낼 수 있으며, 이 경우에는 포트포워딩이 필요하지 않습니다. 반면, 서버가 클라이언트에게 직접 새로운 연결을 생성해서 접근하려는 경우에는, 클라이언트가 NAT 환경에 있다면 포트포워딩이 필요합니다. 왜냐하면 외부에서 내부 네트워크로의 직접 접근은 공유기에서 어떤 장치로 보낼지 판단할 수 없기 때문입니다.
        </p>
    </details>
    <!-- 열번째 질문 -->
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">네트워크에서의 ‘캡슐화(encapsulation)’와 ‘역캡슐화(decapsulation)’에 대해 설명해주세요.</strong></summary> 
        <p>
            <strong style="color: #999;">A.</strong>
            캡슐화란 상위 계층에서 받은 데이터를 하위 계층으로 전달할 때, 각 계층이 필요한 제어 정보(헤더, 때로는 트레일러)를 붙여서 하나의 데이터 단위로 만드는 과정을 말합니다. 역캡슐화는 수신 측에서 데이터를 받을 때 각 계층이 자신에게 해당하는 헤더와 트레일러를 제거하고 원래의 데이터(페이로드)를 추출하는 과정입니다.
        </p>
    </details>
    <!-- 열한번째 질문 -->
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">패킷이란 무엇이며, 패킷 교환 네트워크의 특징은 무엇인가요?</strong></summary> 
        <p>
            <strong style="color: #999;">A.</strong>
            패킷은 네트워크에서 송수신되는 데이터 단위로, 페이로드와 헤더(때로는 트레일러)로 구성됩니다. 패킷 교환 네트워크는 데이터를 작은 패킷으로 쪼개 송수신하고, 수신지에서 재조립하는 방식으로 동작합니다.
        </p>
    </details>
    <!-- 열두번째 질문 -->
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">MAC 주소란 무엇인가요?</strong></summary> 
        <p>
            <strong style="color: #999;">A.</strong>
            MAC 주소는 네트워크 인터페이스마다 부여되는 48비트 길이의 물리적 주소로, 같은 LAN 내에서 호스트를 구분하는 데 사용됩니다.
        </p>
    </details>
    <!-- 열세번째 질문 -->
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">VLAN이란 무엇인가요?</strong></summary> 
        <p>
            <strong style="color: #999;">A.</strong>
            VLAN은 하나의 스위치에 연결된 호스트들을 논리적으로 나누어 서로 다른 네트워크처럼 구성하는 기술로, 브로드캐스트 도메인을 분리할 수 있습니다.
        </p>
    </details>
    <!-- 열네번째 질문 -->
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">허브와 스위치의 차이를 설명해주세요.</strong></summary> 
        <p>
            <strong style="color: #999;">A.</strong>
            허브는 물리 계층 장비로 수신한 신호를 모든 포트로 브로드캐스트하며 반이중 통신만 지원합니다. 반면 스위치는 데이터 링크 계층 장비로, MAC 주소 학습을 통해 목적지 포트로만 전송하며 전이중 통신을 지원합니다.
        </p>
    </details>
</div>


### 네트워크(2)

<div style="font-family: sans-serif; line-height: 1.6;">
    <details>
        <summary>
            <strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">수강 신청같이 특정 시점에만 트래픽이 증가하는 경우에는 어떠한 스케일링 방법을 선택하는 것이 좋을까요?</strong>
        </summary>
        <p>
            <strong style="color: #999;">A.</strong>특정 시점에만 트래픽이 증가하는 경우 모든 자원을 해당 시점에 맞추어 세팅하는 것은 비경제적일 수 있습니다. 따라서 오토 스케일링을 통해 필요할 때에만 시스템을 동적으로 확장 및 축소하는 것이 좋습니다.
        </p>
    </details>
<details>
    <summary>
        <strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">쿠키는 세션이 종료되면 자동으로 삭제되나요?</strong>
    </summary>
    <p>
        <strong style="color: #999;">A.</strong>기본적으로 만료 시간이 명시되지 않은 쿠키(session cookie)는 브라우저 세션이 종료될 때 자동으로 삭제됩니다. 반면, 만료 시간이 설정된 쿠키는 브라우저를 닫아도 지정된 시간까지 유지됩니다.
    </p>
</details>
    <details>
        <summary>
            <strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">쿠키와 세션, 웹 스토리지(LocalStorage, SessionStorage)의 차이를 설명해주세요.</strong>
        </summary>
        <p>
            <strong style="color: #999;">A.</strong>먼저 **쿠키(Cookie)**는 클라이언트에 저장되며, 매 요청마다 자동으로 서버에 전송되는 특징이 있습니다. 따라서 인증 정보나 사용자 식별자 등 서버가 계속해서 확인해야 하는 정보를 저장하는 데 자주 사용됩니다. 용량은 약 4KB로 작고, 만료 시간을 설정할 수 있습니다. 반면 **세션(Session)**은 클라이언트가 아닌 서버 측에 저장되는 데이터입니다. 클라이언트는 보통 세션 ID만을 쿠키 형태로 보관하며, 이 ID를 통해 서버에서 해당 사용자의 상태나 데이터를 식별합니다. 쿠키보다 보안성이 높고, 서버에 부하가 더 크다는 특징이 있습니다. 그리고 웹 스토리지는 HTML5에서 제공하는 클라이언트 측 저장소로, 쿠키와는 달리 서버로 자동 전송되지 않습니다. LocalStorage는 브라우저에 영구적으로 저장되며, 명시적으로 제거하지 않는 한 유지됩니다. SessionStorage는 브라우저 탭 단위로 관리되며, 탭을 닫으면 삭제됩니다. 용량도 쿠키보다 훨씬 크며 보통 5~10MB 정도 저장할 수 있습니다.
        </p>
    </details>
    <details>
        <summary>
            <strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">쿠키의 Secure, HttpOnly 속성은 각각 어떤 역할을 하나요?</strong>
        </summary>
        <p>
            <strong style="color: #999;">A.</strong>먼저 Secure 속성을 설정하면, 해당 쿠키는 HTTPS 연결을 통해서만 전송됩니다. 즉, 암호화되지 않은 HTTP 요청에서는 쿠키가 전송되지 않아 중간자 공격(Man-in-the-Middle) 같은 위협을 줄일 수 있습니다.HttpOnly 속성은 쿠키를 자바스크립트에서 접근하지 못하도록 제한합니다. 이를 통해 XSS(Cross-Site Scripting) 공격으로부터 쿠키를 보호할 수 있습니다. 예를 들어 공격자가 악성 스크립트를 삽입하더라도 document.cookie로 HttpOnly 쿠키를 탈취할 수 없습니다. 이 두 속성을 적절히 설정하면 쿠키의 기밀성과 무결성을 보장하는 데 도움이 되며, 특히 인증 토큰이나 세션 ID를 다룰 때 필수적인 보안 설정입니다.
        </p>
    </details>
    <details>
        <summary>
            <strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">HTTP 프로토콜의 특징 네 가지를 말씀해주세요.</strong>
        </summary>
        <p>
            <strong style="color: #999;">A.</strong> 요청 응답 기반, 미디어 독립적, 스테이트리스(stateless) 프로토콜, 지속 연결 프로토콜이라는 네 가지 특징을 가지고 있습니다.
        </p>
    </details>
    <details>
        <summary>
            <strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">최근에는 SSL은 사용되지 않고 TLS만 사용된다고 하는데 그 이유에 대해서 설명해주실 수 있나요?</strong>
        </summary>
        <p>
            <strong style="color: #999;">A.</strong>최근에는 SSL은 알려진 보안 취약점 때문에 더 이상 사용되지 않고, 대신 개선된 프로토콜인 TLS가 표준으로 사용됩니다. 현재 우리가 흔히 말하는 ‘SSL 인증서’도 사실은 TLS 기반입니다. 이런 취약점을 통해 중간자 공격(Man-in-the-Middle, MITM)이 가능하기 때문에 안전한 통신을 보장하지 못합니다.<br> 중간자 공격이란 공격자가 클라이언트와 서버 사이에 몰래 끼어들어, 양쪽 통신 내용을 엿보거나 조작하는 공격입니다. 예시로는 사용자가 은행 사이트에 로그인하려고 할 때, 공격자가 네트워크 중간에서 가짜 서버를 만들어 사용자의 ID/PW를 가로채는 경우가 있습니다.
        </p>
    </details>
    <details>
        <summary>
            <strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">GET과 POST의 차이를 설명해주세요.</strong>
        </summary>
        <p>
            <strong style="color: #999;">A.</strong>GET은 데이터를 조회할 때 주로 사용하고, 요청 파라미터가 URL에 노출됩니다. 반면 POST는 데이터를 생성하거나 수정할 때 사용하며, 요청 본문에 데이터를 담기 때문에 보안과 데이터 전송량 측면에서 더 적합합니다.
        </p>
    </details>
    <details>
        <summary>
            <strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">왜 GET에서는 요청 파라미터를 메시지 본문이 아닌 URL query string으로 전달할까요?</strong>
        </summary>
        <p>
            <strong style="color: #999;">A.</strong>GET은 리소스를 요청할 때 사용하는 메서드로, URL 자체가 리소스의 위치와 상태를 나타내는 식별자 역할을 하기 때문에 본문이 필요하지 않으며, URL이 동일하면 캐싱된 응답을 재사용할 수 있고, 북마크 및 공유에 용이합니다. 
        </p>
    </details>
      <details>
        <summary>
            <strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">RESTful API에 대해서 설명해주세요.</strong>
        </summary>
        <p>
            <strong style="color: #999;">A.</strong>RESTful API는 HTTP 프로토콜을 기반으로 리소스를 자원 단위로 표현하고, 그 자원에 대한 행위를 HTTP 메서드로 구분하여 설계한 API입니다. URL은 자원을 나타내고, 메서드는 동작을 의미하도록 설계하는 것이 핵심입니다.<br> 예를 들어 user를 생성하는 API의 URL은 '/createUser'이 아닌 'user'로 행위는 URL에 담기지 않고 POST라는 메서드로만 표현되어야합니다.
        </p>
    </details>
</div>


## :질문:스터디에서 논의하고 싶은 질문

## :링크: 참고 자료