# CH05. 네트워크

## 목차

- [1. 네트워크의 큰 그림](#1-네트워크의-큰-그림)
- [2. 물리 계층과 데이터 링크 계층](#2-물리-계층과-데이터-링크-계층)
- [3. 네트워크 계층 - IP](#3-네트워크-계층---ip)
- [4. 전송 계층 - TCP와 UCP](#4-전송-계층---tcp와-udp)
- [5. 응용 계층 - HTTP의 기초]()
- [6. 응용 계층 - HTTP의 응용]()
- [7. 프록시와 안정적인 트래픽]()
- [면접 예상 질문](#면접-예상-질문)

## 1. 네트워크의 큰 그림

### 네트워크(Network)

- 여러 대의 장치가 연결되어 정보를 주고받는 통신망  
  노드(네트워크 기기)와 간선(네트워크 기기 간 정보 주고받는 유무선의 통신 매체)으로 이루어진 그래프 형태

- `네트워크 토폴로지(network topology)`  
  : 네트워크 상에서 노드와 노드 사이의 연결 구조  
   e.g. 망형, 트리형, 링형

- `호스트(host)`  
  : 주고받는 정보를 최초로 송신하고 최종 수신하는 노드  
   대부분의 네트워크 기기(노트북과 구글의 서버 컴퓨터) - `클라이언트(client)` : `요청(request)`을 보내는 호스트  
   - `서버(server)` : `응답(response)`을 보내는 호스트  
   노트북(클라이언트)이 구글의 서버 컴퓨터에게 웹 페이지를 가져다달라는 요청을 보내면 구글의 서버 컴퓨터(서버)가 노트북에게 웹 페이지로 응답한다.
- 그 외 노드 : 중간 역할을 하는 스위치와 라우터, 공유기

### 네트워크 구분

- `LAN(Local Area Network)`  
  : 근거리 네트워크  
  e.g. 같은 공유기에 연결된 네트워크 기기들은 `모두 같은 네트워크(LAN)에 속해 있다`

- `WAN(Wide Area Network)`  
  : LAN 간의 통신이 이루어지는 네트워크  
  `ISP(Internet Service Provider)` : 인터넷 서비스 업체 e.g. KT, LG유플러스, SK브로드밴드

### 패킷 교환 네트워크

`패킷 교환 네트워크` : 패킷 단위로 정보를 쪼개거나 재조립하며 데이터를 송수신하는 네트워크

`패킷(packet)` : 네트워크를 통해 송수신되는 데이터의 단위  
 = `페이로드(payload)` + `(헤더header)` ( + `트레일러(trailer)` )

> 페이로드는 패킷에서 송수신하고자 하는 데이터  
> 헤더와 트레일러는 패킷에 추가되는 부가 정보

### 주소의 개념과 전송 방식

`주소(address)` : 패킷의 헤더에 명시되는 정보

- 수신지 유형에 따른 분류
  - `유니캐스트(unicast)` : 송신지와 수신지가 <u>일대일 통신</u>
  - `브로드캐스트(broadcast)` : 네트워크상의 <u>모든 호스트에게</u> 메시지를 전송  
     `브로드캐스트 도메인(broadcast domain)` : 브로드캐스트가 전송되는 범위  
     => 같은 브로드캐스트 도메인 == 같은 LAN에 속해 있다
  - `멀티캐스트(multicast)` : 네트워크 내의 <u>동일 그룹에</u> 속한 호스트에게만 전송
  - `애니캐스트(anycast)` : 네트워크 내의 <u>동일 그룹에 속한 호스트 중 가장 가까운</u> 호스트에게 전송

### 두 호스트가 패킷을 주고받는 과정

패킷을 주고받는 호스트와 네트워크 장비들이 서로 주고받는 정보를 이해하려면 같은 프로토콜을 이해해야 하고, 같은 프로토콜로 통신해야 합니다.

`프로토콜(protocol)`

- 네트워크에서 통신을 주고받는 노드 간의 합의된 규칙이나 방법, 네트워크에서는 여러 프로토콜을 함께 사용

### OSI 7계층과 TCP/IP 4계층

`네트워크 참조 모델(network reference model)`  
: 통신이 이루어지는 단계를 계층적으로 표현한 모델  
패킷을 송신하는 쪽에서는 상위 계층에서 하위 계층으로 정보를 보내고, 패킷을 수신하는 쪽에서는 하위 계층에서 상위 계층으로 정보를 받아들이게 되는 것이죠.

| OSI 7계층        | TCP/IP 4계층             | 설명                                            |
| ---------------- | ------------------------ | ----------------------------------------------- | --- |
| 응용 계층        | 응용 계층                | 사용자 인터페이스 및 응용 프로그램과의 상호작용 | ... |
| 표현 계층        | ...                      | 데이터 형식, 인코딩, 암호화 등                  |
| 세션 계층        | ...                      | 세션 설정, 유지 및 종료                         |
| 전송 계층        | 전송 계층                | 종단 간 연결, 오류 제어, 흐름 제어 (TCP/UDP)    |
| 네트워크 계층    | 인터넷 계층              | 논리적 주소 지정(IP), 경로 설정                 |
| 데이터 링크 계층 | 네트워크 인터페이스 계층 | 물리적 주소(MAC), 프레임 전송, 오류 감지        |
| 물리 계층        |                          | 전기적 신호, 케이블, 커넥터 등 물리적 전송 매체 |

`OSI Model`(7계층)

- `물리 계층(physical layer)`

  - 비트 신호(0과 1만으로 이루어진 신호)를 유무선 통신 매체를 통해 운반하는 계층
  - 패킷의 이름 : 심볼(symbol) 또는 비트(bit)

- `데이터 링크 계층(data link layer)`
  - 같은 LAN에 속한 호스트끼리 올바르게 정보를 주고받기 위한 계층
  - `MAC 주소`를 사용
  - 물리 계층을 통해 주고받는 정보에 오류가 없는지 확인
  - 패킷의 이름 : 프레임(frame)

=> 물리 계층과 데이터 링크 계층은 서로 밀접하게 연관된 계층이며, 하드웨어와 밀접하게 맞닿아 있는 계층

- `네트워크 계층(network layer)`

  - 네트워크 계층은 LAN을 넘어 다른 네트워크와 통신을 주고받기 위해 필요한 계층
  - `IP 주소`를 사용
  - 패킷의 이름 : 패킷(이하 IP 패킷) 또는 데이터그램
  - 대표 프로토콜 : IP

- `전송 계층(transport layer)`

  - 패킷 전송 도중 유실되거나 순서가 뒤바뀔 때를 대비하여 신뢰성 있는 전송을 가능하게 하는 계층
  - `포트(port)`라는 정보를 통해 특정 응용 프로그램과의 연결 다리 역할을 수행
  - 패킷의 이름 : `TCP 기반(세그먼트)` `UDP 기반 (데이터그램)`
  - 대표 프로토콜 : TCP와 UDP

- `세션 계층(session layer)`

  - `세션(session)`(응용 프로그램 간의 연결 상태)을 관리하기 위한 계층
  - 응용 프로그램 간의 연결 상태를 유지 _ 생성 _ 중단
  - 패킷의 이름 : 데이터 또는 메시지

- `표현 계층(presentation layer)`
  - 인코딩과 압축, 암호화와 같은 작업을 수행합니다.

=> 세션 계층과 표현 계층은 다른 계층과 달리, 두 계층을 명확하게 구분하지 않거나 응용 계층에 포함하여 간주하는 경우가 많다.

- `응용 계층(application layer)`
  - 사용자와 가장 밀접하게 맞닿아 있어 여러 네트워크 서비스를 제공하는 계층
  - 중요한 프로토콜들이 다수 포함
  - 대표 프로토콜 : HTTP, HTTPS, DNS

### 캡슐화와 역캡슐화

> 패킷을 송신하는 쪽에서는 상위 계층에서 하위 계층으로 정보를 보내고, 패킷을 수신하는 쪽에서는 하위 계층에서 상위 계층으로 정보를 받아들인다.

- `상위 계층의 패킷` == `하위 계층의 페이로드`  
  각 계층에서는 상위 계층으로부터 내려받은 패킷을 페이로드로 삼아, 각 계층에 포함된 프로토콜의 각기 다른 목적과 특징에 따라 헤더 혹은 트레일러를 덧붙인 다음 하위 계층으로 전달한다.

`캡슐화(encapsulation)` : 송신 과정에서 헤더(및 트레일러)를 추가해 나가는 과정을 의미합니다.

`역캡슐화(decapsulation)` : 수신 과정에서 캡슐화 과정에서 붙인 헤더(및 트레일러)를 각 계층에서 확인한 뒤 제거하는 과정

### 네트워크 지도 그리기

(363페이지 참고)

<div style="display:flex; ">
    <div style="flex:1">
    <p>물리 계층과 데이터 링크 계층</p>
    </div>
    <div style="flex:3">
    <ul>
        <li>이더넷</li>
        <li>유무선 통신 매체</li>
        <li>이더넷 프레임</li>
        <li>다양한 네트워크 장비 (NIC, 허브, 스위치)</li>
    </ul>
    </div>
</div>

<div style="display:flex; ">
    <div style="flex:1">
    <p>네트워크 계층</p>
    </div>
    <div style="flex:3">
    <ul>
        <li>IP의 목적과 특징</li>
        <li>IP 구조(구조, 종류, 할당 방식)</li>
        <li>ICMP</li>
        <li>ARP</li>
    </ul>
    </div>
</div>

<div style="display:flex; ">
    <div style="flex:1">
    <p>전송 계층</p>
    </div>
    <div style="flex:3">
    <ul>
        <li>TCP</li>
        <li>UDP</li>
    </ul>
    </div>
</div>

## 2. 물리 계층과 데이터 링크 계층

### `이더넷(Ethernet)`

- LAN 내의 호스트들이 올바르게 정보를 주고받을 수 있게 해주는 다양한 기술 중 하나
- 통신 매체를 통해 신호를 송수신하는 방법, 데이터 링크 계층에서 주고받는 데이터(프레임) 형식 등이 정의된 기술
  현대 대부분의 (유선)LAN은 이더넷을 기반으로 구현되어 있습니다.

- `이더넷 표준`
  - 오늘날의 (유선)LAN 대부분이 이더넷 표준을 따르기 때문에 대다수의 LAN 장비들이 특정 이더넷 표준(IEEE 802.3)을 따른다.
  - 이더넷 표준이 달라지면 통신 매체의 종류를 비롯한 신호 송수신 방법, 나아가 최대 지원 속도도 달라질 수 있다.
- `이더넷 프레임Ethernet frame`  
   이더넷 기반의 네트워크에서 주고받는 프레임 (e.g Ethernet II 프레임)
  사실상 ‘프레임’이 이더넷 프레임을 지칭한다고 보아도 무방

  이더넷 프레임의 구성 요소
  `프리앰블preamble`
  송수신지 동기화를 위해 사용되는 8바이트(64비트) 크기의 정보
  수신지는 프리앰블 비트를 통해 현재의 이더넷 프레임이 수신되고 있다는 사실을 알아차리게 된다.

  `송수신지 MAC 주소`

  - 프레임에는 송신지와 수신지를 특정할 수 있는 6바이트(48비트) 길이의 `MAC 주소mac address`(네트워크 인터페이스마다 하나씩 부여되는 물리적 주소)가 명시  
    콜론(:)으로 구분된 12자리 16진수 (e.g. ab:cd:ab:cd:00:01 )  
    `네트워크 인터페이스`란 네트워크를 향하는 통로, 연결 매체와의 연결 지점
    보통 NIC라는 장치가 네트워크 인터페이스를 담당합니다.
    따라서 NIC가 여러 개인 상황처럼 네트워크 인터페이스가 여럿이라면 한 호스트가 여러 개의 MAC 주소를 가질 수 있습니다.

  - `타입/길이type/length 필드`

  타입/길이 필드에 명시된 크기가

  - 1500 이하(16진수 05DC) = 프레임의 크기
  - 1536 이상(16진수 0600) = 타입

  타입은 캡슐화된 상위 계층의 정보를 의미하기 때문에 타입을 통해 어떤 상위 계층 프로토콜이 캡슐화되었는지를 알 수 있죠. 예를 들어 IP(IPv4)가 캡슐화된 정보를 운반한다면 타입에는 16진수 0800이 명시되고, ARP 프로토콜이 캡슐화된 정보를 운반한다면 타입에는 16진수 0806이 명시됩니다

  - `데이터 필드`
    - 페이로드(상위 계층으로 전달하거나 전달받을 데이터)가 명시된다.
    - 데이터 필드에 포함될 수 있는 데이터의 최대 크기(일반적으로 1500바이트)가 정해져 있다는 점입니다.
      최대 크기보다 큰 데이터를 보낼 경우에는 여러 패킷으로 나뉘어 보내진다.

  > 흔히 ‘1500바이트’는 이더넷 프레임으로 전송 가능한 최대 데이터의 크기이자, 네트워크 계층 패킷(헤더 + 페이로드)의 최대 크기를 지칭하는 데 사용되기 때문입니다. 이 크기를 MTU라고 부릅니다. MTU에 대해서는 다음 절 00쪽에서 한 번 더 언급하겠습니다.
  > NOTE 데이터 필드에 명시 가능한 최대 페이로드의 크기는 일반적으로 1500바이트지만, 더 큰 데이터를 포함할 수
  > 있는 특별한 프레임도 있습니다. 이를 점보 프레임(jumbo frame)이라고 합니다.

  `FCSFrame Check Sequence`  
   프레임의 오류가 있는지의 여부를 확인하기 위한 필드로, `CRCCyclic Redundancy Check`라는 오류 검출용 값이 명시  
   송신지에서 전송할 데이터와 더불어 전송할 데이터에 대한 CRC 값을 계산하여 보내면 수신지에서는 전달받은 데이터에 대한 CRC 값을 계
  산해, 그 값을 전달받은 CRC 값과 대조합니다. 두 값이 같을 경우 프레임에 오류가 없다고 판단하는 것입니다.

### 유무선 통신 매체

호스트가 아무리 빠르게 데이터를 처리할 수 있어도 그를 뒷받침하는 연결 매체의 성능이 뒷받침되지 않으면 호스트의 빠른 속도는 아무런 효용
이 없기 떄문에 이러한 하드웨어도 중요하다.

- 유선 매체 : 트위스티드 페어 케이블
  `트위스티드 페어 케이블twisted pair cable`  
  구리선을 통해 전기적으로 신호를 주고받는 통신 매체 => 전기 신호에 왜곡을 줄 수 있는 주변 잡음(`노이즈(noise)`)에 취약하다.

`카테고리category` 트위스티드 페어 케이블의 성능을 구분하는 일종의 등급 역할  
카테고리에 따라 대응되는 주요 이더넷 표준이 다르고, 표준에 따른 최대 지원 속도도 달라질 수 있습니다.
특정 카테고리를 영문 표기인 ‘Category’의 앞글자를 따서 ‘Cat’이라고 표현한다는 점에 유의해 주세요. 가령 카테고리7은 Cat7(혹은 Cat.7)로, 카테고리8은 Cat8(혹은 Cat.8)로 표기합니다.

> 실드의 상세한 표기
> 트위스티드 페어 케이블을 그물 모양의 철사나 포일foil로 감싸 노이즈를 방지하는 경우가 많습니다. 구리선 주변을 보호
> 해 노이즈를 감소시키는 방식은 차폐shielding라고 하며, 차폐에 사용된 그물 모양의 철사와 포일은 각
> 각 브레이드 실드braided shield와 포일 실드foil shield라고 합니다. 이 브레이드 실드로 노이즈를 감소시킨 케이
> 블을 STPShielded Twisted Pair 케이블이라고 하고, 포일 실드로 노이즈를 감소시킨 케이블을 FTPFoil Twisted Pair
> 케이블이라고 합니다. 반면, 아무것도 감싸지 않아 구리선만 있는 케이블은 UTPUnshielded Twisted Pair 케
> 이블이라고 부르죠

> 트위스티드 페어 케이블은 기본적으로 실드의 사용 여부 혹은 사용된 실드의 종류에 따라 STP, FTP, UTP로
> 나누지만, 최근에는 더 상세하게 다음과 같은 형식으로 실드를 표기합니다.
> [ ] / [ ] TP
> 첫 번째와 두 번째 괄호 안에 U, S, F를 명시할 수 있습니다. 이때 U는 실드 없음, S는 브레이드 실드, F는 포일
> 실드를 의미합니다. 첫 번째 괄호에는 케이블의 외부를 감싸는 실드의 종류를 명시하고, 두 번째 괄호에는 꼬
> 아 놓은 구리선을 감싸는 실드의 종류를 명시합니다. 예를 들어 보겠습니다.
> ● S/FTP 케이블: 브레이드 실드로 케이블 외부를 보호하고, 포일 실드로 꼬아 놓은 구리선을 감싼 케이블
> ● F/FTP 케이블: 케이블 외부와 꼬아 놓은 구리선을 모두 포일 실드로 감싼 케이블
> ● SF/FTP 케이블: 케이블 외부는 브레이드 실드와 포일 실드로 감싸고, 각각의 구리선은 포일 실드로 감싼
> 케이블
> ● U/UTP 케이블: 아무것도 감싸지 않은 케이

- 무선 매체
  `전파와 WiFi`
  `전파` : 약 3kHz부터 3THz 사이의 진동수를 갖는 전자기파를 의미합니다.
  개발자 입장에서 진동수 자체를 암기하거나 전파 통신의 물리학적 원리를 이해해야 할 일은 많지 않습니다. 다만, 진
  동수 2.4GHz와 5GHz(3kHz부터 3THz 사이에 속한 진동수로, 다음과 같이 와이파이를 사용할 때 주로 활용)

`와이파이Wi-Fi`

- 표준 : ‘IEEE 802.11’ + 숫자 / 표준 규격에 따라 지원되는 최대 속도나 주파수 대역 등이 달라질 수 있다.
- 와이파이 뒤에 붙는 숫자(e.g. 와이파이 4, 와이파이 5)로 세대를 구분하고, 세대에 따라 지원되는 표준 규격, 최대 속도나 주파수가 달라질 수 있다.

앞서 와이파이에서 주로 사용되는 주파수 대역은 2.4GHz 혹은 5GHz라고 했는데요. 이때 같은 주파수 대역을 사용하는 여러 무선 네트워크가 존재할 수 있습니다. 같은 지역 내에 2.4GHz 대역을 사용하는 무선 네트워크가 여러 개 존재하거나 5GHz 대역을 사용하는 무선 네트워크가 여러 개 존재할 수 있다는 것입니다.하지만 전파 통신을 주고받을 때 주파수 대역이 겹치면 신호의 간섭이 발생할 수 있습니다. 특정 지역에서 2개의 무전기가 같은 주파수를 사용할 경우, 다른 무전기 소리가 섞여 들릴 수 있는 것처럼 말이죠. 따라서 별개의 무선 네트워크는 같은 주파수 대역을 사용하더라도 서로의 신호에 간섭하지 않아야 합니다.
그래서 주파수 대역은 같은 대역을 사용하는 서로 다른 무선 네트워크를 구분하기 위해 `채널channel`이라는 하위 주파수 대역으로 세분화되고, 해당 채널 대역에서 무선 통신이 이루어집니다.
다음은 2.4GHz, 5GHz 대역의 일부 채널과 채널 번호를 표현한 그림입니다. 채널에는 번호가 할당되어 있습니다. 일반적으로 채널은 자동 설정되지만, 특정 채널을 사용하도록 수동으로 설정할 수도 있습니다.그림에서 2.4GHz 대역의 채널을 살펴보면 1, 6, 11번 채널의 주파수는 서로 중첩되지 않습니다. 따라서 1, 6, 11번 채널을 사용하는 무선 네트워크는 아무리 많은 통신이 이루어지더라도 신호 간섭으로 인한 성능 저하가 발생하지 않습니다. 반면, 1, 2, 3번 채널을 사용하는 무선 네트워크는 신호가 중첩될 여지가 많아 자주 발생하는 신호 간섭으로 인해 성능이 현저히 저하될 수 있습니다. 이렇듯 무선 네트워크의 성능 저하를 방지하려면 신호가 중첩되지 않는 채널을 사용하는 것이 중요합니다

> AP와 SSID
> 여러 무선 통신 기기를 연결해 무선 네트워크를 구성하는 장비로 AP(Access Point)가 있습니다.
> 일상에서 흔히 볼 수 있는 무선 공유기가 AP의 역할을 담당하는 대표적인 네트워크 장비라고 할 수 있죠.
> AP를 중심으로 구성된 무선 네트워크는 서비스 셋(Service Set)이라고 하고,
> 서비스 셋을 식별하는 정보는 ‘서비스 셋 식별자’를 줄여서 SSID(Service Set Identifier)라고 합니다.
> 와이파이 이름으로 사용되는 정보가 바로 SSID입니다. 따라서 와이파이에 접속했다면 네트워크 설정에서 SSID를 확인해 볼 수 있습니다

```
네트워크 = 도로망

장치(컴퓨터 등) = 자동차

데이터 = 자동차 안의 택배(정보)

페이로드가 택배(패킷)를 통해 송수신하고자 하는 물품이라면, 헤더와 트레일러는 택배 앞뒤로 붙이는 송장(부가 정보)과 같습니다

프로토콜 = 교통법규
```

### 네트워크 인터페이스와 NIC

- `네트워크 인터페이스network interface`  
  : 네트워크 상에서 노드와 통신 매체가 연결되는 지점, 노드와 네트워크 사이의 통로
  노드가 네트워크를 통해 송수신하는 정보가 네트워크 인터페이스를 거치는 셈이죠.
  네트워크 인터페이스마다 물리적 주소라고 불리는 MAC 주소가 부여되고,

- `NICNetwork Interface Controller`라는 하드웨어가 네트워크 인터페이스의 역할을 담당하는 것이 일반적입니다.
  NIC는 네트워크 인터페이스 카드, 네트워크 어댑터, LAN 카드, 네트워크 카드, (이더넷 네트워크의 경우)이더넷 카드 등 다양한 명칭으로 불리는 하드웨어입니다. 통신 매체의 신호를 호스트가 이해하는 프레임으로 변환하거나 호스트가 이해하는 프레임을 통신 매체의 신호로 변환하는 역할을 수행하죠.
  때로는 MAC 주소를 토대로 잘못 전송된 패킷이 없는지 확인하기도 합니다.
  NIC는 본래 다음 그림처럼 확장 카드 형태의 장비였지만, 최근에는 USB 연결이나 메인 보드 내장 등 다양한 형태로 변화했습니다. 만약 여러분이 추가 장치를 연결하지 않고도 네트워크에 연결되는 컴퓨터를 사용하고 있다면 높은 가능성으로 마더 보드에 내장된 NIC를 사용 중일 것입니다

NIC가 앞서 학습한 여느 입출력장치와 다르지 않다는 점에 유의해야 합니다.동작하는 방식도 여느 입출력 과정과 다르지 않죠.
패킷을 송신하는 동작을 ‘출력’, 패킷을 수신하는 동작을 ‘입력’이라고 생각해 보세요. NIC의 동작은 2장 ‘컴퓨터 구조’와 3장 ‘운영체제’에서 설명한 입출력 방식과 동일합니다.
NIC를 작동시키는 시스템 콜이 호출되면 (커널 모드로 전환된 뒤에)송수신이 수행되고, 입출력이 완료되면 인터럽트를 통해 CPU에게 작업이 완료되었음을 알리게 됩니다. 대부분 DMA도 지원합니다.
그리고 NIC는 여느 입출력장치와 마찬가지로 각각의 성능이 다릅니다. 즉, NIC의 지원 속도가 저마다 다르고, 이는 네트워크의 속도에 큰 영향을 끼칩니다. 그래서 고대역폭을 감당해야 하는 환경에서는 메인 보드에 내장된 NIC가 있더라도 고가의 고속 NIC를 추가로 구비하기도 합니다.

> `티밍(teaming) 혹은 본딩(bonding)`
> 고가의 NIC를 구비하는 방법 외에도 NIC 단계의 성능 향상을 위해 사용하는 방식이 있습니다. 여러 물리적인 NIC를 마치 하나의 고속 NIC처럼 구성하는 것입니다. 티밍은 윈도우 운영체제에서 주로 사용하는 용어이고, 본딩은 리눅스 운영체제에서 주로 사용하는 용어입니다(사실 티밍과 본딩의 자세한 정의는 다르지만, 여러 물리적인 NIC를 하나의 고속 NIC처럼 구성하는 방식이라는 점에서는 같습니다).
> 저성능의 여러 물리적인 입출력장치를 고성능의 논리적 입출력장치 하나로 묶어 사용한다는 점에서 2장 ‘컴퓨터 구조’에서 학습했던 RAID와 유사합니다. 실제로 RAID를 통해 빠르고 안정적인 입출력이 가능한 것처럼 티밍과 본딩을 통해 송수신 성능을 향상시킬 수 있고, 하나의 NIC에 문제가 발생하더라도 다른 NIC를 통해 송수신되도록 하여 안정적으로 송수신할 수 있습니다

### 허브와 스위치

- 둘 다 네트워크 장비로, 하드웨어임!!
  허브와 스위치는 물리 계층과 데이터 링크 계층의 중간 노드입니다.

허브가 전이중/반이중 통신, 브로드캐스트 통신의 특징을 잘 보여주는 네트워크 장비 / 허브는 오늘날 네트워크에서 잘 사용하지 않습니다. 허브 대신 스위치를 사용하는 경우가 많죠.

`허브`

- 물리 계층의 대표적인 네트워크 장비로, 여러 대의 호스트를 연결하는 장치입니다.
  `리피터 허브repeater hub`라고 부르기도 하고, 특히 이더넷 네트워크의 허브는 `이더넷 허브Ethernet hub`라고 부르기도 합니다.
  다음과 같이 허브에서 케이블의 커넥터가 꽂히는 부분, 통신 매체를 연결하는 지점은 `포트port`라고 합니다

허브에는 2가지 중요한 특징이 있습니다.

1. 전달받은 신호를 모든 포트로 내보낸다
   허브는 신호를 전달받으면 해당 신호에 대한 어떠한 조작이나 판단도 하지 않고, 모든 포트에 단순하게 신호를 내보냅니다.

2. 반이중 통신
   `반이중 통신` : `반이중half duplex 모드`로 송수신하는 것 = 송신 또는 수신을 번갈아 가면서 수행해야 하는 통신 방식
   == 동시 송수신이 불가능한 상태 e.g. 무전기와 같이 어느 한 쪽이 송신할 때 다른 쪽은 송신이 불가능합니다.

`전이중 통신` : `전이중full duplex 모드란`로 송수신하는 것 = 동시 송수신이 가능한 상태 e.g. 전화기

허브는 반이중 모드로 통신하기 때문에 어느 한 호스트가 허브를 향해 정보를 전달하면 다른 호스트는 정보를 전송할 수 없습니다. 만일 허브를 향해 동시에 메시지를 보내면 `충돌(collision)`이라는 문제가 발생하며, 충돌이 발생할 수 있는 영역을 `콜리전(충돌) 도메인(collision domain)`이라고 합니다.
앞서 허브는 전달받은 신호를 모든 포트로 내보내는 동시에 반이중 모드로 통신하므로 허브에서 충돌이 발생할 수 있는 영역(콜리전 도메인)은 다음과 같이 ‘허브에 연결된 모든 호스트’가 됩니다.

`스위치`

스위치switch는 허브의 한계를 보완하기 위한 네트워크 장비  
스위치는 허브와 달리 전달받은 신호를 목적지 호스트가 연결된 포트로만 내보내고, 전이중 모드를 지원하므로 허브와 비교해 콜리전 도메인이 좁습니다.
여기서 설명하는 스위치는 2계층(데이터 링크 계층)에서 사용한다는 점에서 L2 스위치라고도 부릅니다.
데이터 링크 계층의 상위 계층에서 사용되는 L3 스위치, L4 스위치 등도 있지만, 책에서는 혼동을 방지하기 위해 ‘스위치’라는 용어를 L2 스위치와 동일한 의미로 사용하겠습니다.

스위치가 전달받은 신호를 원하는 포트에만 내보낼 수 있는 이유는 스위치에 `MAC 주소 학습MAC address learning 기능`이 있기 때문입니다.
프레임 헤더에는 주소(MAC 주소)가 명시됩니다. 스위치는 데이터 링크 계층에 속한 장비이므로 주소(MAC 주소)를 이해할 수 있습니다. 스위치는 프레임 속 MAC 주소를 토대로 현재 어떤 포트에 어떤 MAC 주소를 가진 호스트가 연결되어 있는지 파악하고, ‘포트, 연결된 호스트의 MAC 주소’의 대응 관계를 테이블의 형태로 메모리에 저장합니다. 이 정보를 `MAC 주소 테이블MAC address table`이라고 합니다. <u>즉, 스위치가 전달받은 신호를 목적지 호스트가 연결된 포트로만 내보낼 수 있는 이유는 MAC 주소 테이블을 생성하고 참조할 수 있기 때문입니다.</u>

`VLANVirtual LAN` : 가상(Virtual)의 LAN을 의미합니다. 이 기능은 대표적으로 같은 스위치에 연결된 모든 호스트를 하나의 네트워크로 간주하고 싶지 않을 때, 여러 논리적인 네트워크로 나누고 싶을 때 사용됩니다. 다음과 같이 스위치에 연결된 호스트 A~I를 2개의 논리적인 네트워크(VLAN)로 나누는 경우를 예로 들 수 있습니다. 호스트 A~D와 호스트 E~I는 서로 다른 VLAN에 속해 있으므로 서로 다른 네트워크로 간주되며, 브로드캐스트 도메인도 겹치지 않아 VLAN1의 브로드캐스트 메시지가 VLAN2에 도달하지 않습니다. 호스트 A~D와 호스트 E~I가 서로 통신을 주고받으려면 네트워크 계층 이상의 장비가 필요합니다.
(382 페이지)

## 3. 네트워크 계층 - IP

LAN을 넘어서 다른 네트워크와 통신을 주고받으려면 네트워크 계층 이상의 기술이 필요합니다.
네트워크 계층의 가장 핵심적인 프로토콜이라고 할 수 있는 `IPInternet Protocol`를 중심으로 네트워크 간의 통신이 이루어지는 방법을 알아보겠습니다.

### IP의 목적과 특징

- 목적

  - `주소 지정addressing`
    : 네트워크 간의 통신 과정에서 호스트를 특정하는 것, IP 주소를 통해 이루어지며, IP 패킷 헤더를 통해 알 수 있다.

  송신지 IP 주소 수신지 IP 주소 : 송수신지를 식별할 수 있는 IP 주소
  크기 : 4바이트(32비트), 숫자당 8비트로 표현되므로 0~255 범위의 10진수 4개로 표기됩니다.
  각각의 10진수는 점(.)으로 구분하는데, 여기서 점으로 구분된 하나의 10진수를 `옥텟octet`이라고 합니다.
  가령 ‘192.168.0.1’이라는 IP 주소가 있다면 ‘192’, ‘168’, ‘0’, ‘1’ 각각이 8비트로 표현 가능한 옥텟인 셈입니다.

  > 오늘날의 IP는 IPv4와 IPv6 2가지 종류가 있습니다.
  > 둘 중 더 빈번히 사용되는 버전이 IPv4이므로 특별한 언급이 없는 한 이후에 등장하는 ‘IP’라는 용어는 ‘IPv4’를 지칭하는 것으로 설명하겠습니다.

  e.g.

  MAC 주소 = 택배 배송 과정의 수신인과 발신인 / IP 주소 = 수신 주소와 발신 주소에 빗댈 수 있다.
  택배를 제대로 배송하기 위해 수신인과 발신인의 정보, 그리고 수신 주소와 발신 주소의 정보가 모두 필요
  => 패킷을 올바르게 전송하기 위해서는 MAC 주소와 IP 주소가 모두 필요합니다.
  또한 택배 배송 기사가 배송 과정에서 수신인과 발신인의 정보보다는 수신 주소와 발신 주소를 우선적으로 활용하듯, 패킷의 송수신 과정에서도 MAC 주소보다는 IP 주소가 우선적으로 활용됩니다.

  `라우팅routing` : 이때 라우터는 IP 패킷을 전달할 최적의 경로를 결정하고 해당 경로로 패킷을 내보내는 과정
  `라우터router` : IP 주소를 기반으로 패킷의 최적 경로를 결정하여 목적지까지 전달(`라우팅`)하는 네트워크 장비 e.g. 공유기

  `IPv6`

  `IPv4 주소`는 총 4바이트(32비트)로 고갈될 여지가 있음.
  => `IPv6 주소`는 16바이트(128비트)로 주소를 표현하여 할당 가능한 IPv6 주소는 2^128개, 콜론(:)으로 구분된 8개 그룹의 16진수로 표기
  IPv4 주소 : 192.168.1.1
  IPv6 주소 : 2001:0230:abcd:ffff:0000:0000:ffff:1111

  - `단편화fragmentation`
    `단편화`는 데이터를 여러 IP 패킷으로 올바르게 쪼개어 보내는 것

  `MTUMaximum Transmission Unit` : 최대 전송 단위

  전송하고자 하는 IP 패킷(IP 헤더와 페이로드)의 크기가 MTU라는 단위보다 클 경우에는 패킷을 MTU 이하의 여러 패킷으로 쪼개서 전송하고, 이렇게 쪼개서 전송된 패킷들은 수신지에서 재조합된다.
  일반적인 MTU 크기는 1500바이트입니다. 앞서 프레임에 실릴 수 있는 최대 데이터의 크기가 일반적으로 1500바이트라고 언급했는데요. 따라서 MTU는 프레임을 통해 주고받을 수 있는 최대 페이로드의 크기라고 보아도 무방합니다.

  IP 패킷 헤더에서 단편화와 관련된 필드

  - 식별자(identifier): 특정 패킷이 어떤 데이터에서 쪼개진 패킷인지를 식별하기 위해 사용되는 필드  
    같은 식별자 = 같은 정보에서 쪼개진 패킷

  - 플래그(flag): 3비트로 구성된 필드로, 첫 번째 비트를 제외한 나머지 2개의 비트는
    첫 번째 비트는 항상 0으로 설정되어 오늘날 사용되지 않고, 나머지 2개의 비트는 각각 DF(‘IP 단편화를 수행하지 말라(Don’t Fragment)’) 또는 MF(‘단편화된 패킷이 더 있다(More Fragment)’)

  - 단편화 오프셋(fragment offset): 특정 패킷이 초기 데이터에서 얼마나 떨어져 있는지가 명시된 필드로, 단편화되어 전송되는 패킷을 목적지에서 재조합하기 위해 패킷의 올바른 순서를 나타내는 데 사용된다.

- 특징 : ‘신뢰할 수 없는 통신’과 ‘비연결형 통신’

신뢰할 수 없는 통신과 비연결형 통신

- `신뢰할 수 없는 프로토콜unreliable protocol` : 패킷이 수신지까지 제대로 전송되었다고 보장하지 않는 프로토콜
  패킷이 유실되거나 목적지에 순서대로 전송되지 않더라도 이에 대한 조치를 취하지 않는다.
  신뢰할 수 없는 프로토콜의 송수신은 신뢰할 수 없는 통신, 신뢰성이 낮은 통신 혹은 `최선형 전달best effort delivery`

- `비연결형 프로토콜connectionless protocol` : 패킷을 주고받기 전에 사전 연결 과정을 거치지 않는다는 것
  상대 호스트의 수신 가능 여부는 고려하지 않고, 수신지를 향해 그저 패킷을 전송할 뿐입니다.

(책에 실제 값을 통해 IP 주소를 세부적으로 분석한 내용이 있다.)

> 잦은 IP 단편화는 네트워크에 여러 악영향을 미칠 수 있습니다. 단편화된 패킷들이 많아지면 전송해야 할 패킷의 헤더들이 많아지기 때문에 불필요한 트래픽 증가와 대역폭 낭비를 초래하고, 단편화된 패킷을 재조립하는 과정에서 발생하는 부하도 성능 저하로 이어질 수 있습니다.
> IP 단편화를 피하려면 IP 패킷을 주고받는 경로에 존재하는 모든 호스트의 ‘처리 가능한 MTU 크기’를 고려해야 합니다.
> ‘IP 단편화 없이 주고받을 수 있는 최대 크기’만큼만 전송해야 하죠.
> 이 크기를 `경로 MTU(Path MTU)`라고 합니다. 다음 그림의 경로 MTU는 1000바이트인 셈입니다. 호스트가 1500바이트씩 주고받을 수 있더라도 단편화를 피하려면 1000바이트씩 주고받아야 하는 것이죠
> 이렇게 주고받을 수 있는 경로 MTU를 구하고 해당 크기만큼만 송수신하여 IP 단편화를 회피하는 기술을 `경로 MTU 발견(Path MTU discovery)`이라고 합니다. 오늘날의 네트워크에서는 대부분 경로 MTU 발견을 지원하고, 처리 가능한 최대 MTU 크기도 균일하기 때문에 IP 단편화가 자주 발생하지 않습니다.

### IP 주소의 구조

IP 주소 = ‘네트워크 주소’ + ‘호스트 주소’로 이루어져 있습니다.

네트워크 주소는 네트워크 ID, 네트워크 식별자 등으로 불리며, 호스트가 속한 네트워크를 특정하기 위해 사용됩니다.
호스트 주소는 호스트 ID, 호스트 식별자host identifier 등으로 불리며, 네트워크에 속한 호스트를 특정하기 위해 사용되죠

하나의 IP 주소에서 네트워크 주소를 표현하는 크기와 호스트를 표현하는 크기가 유동적일 수 있다
이를 테면 다음 그림의 (a)처럼 네트워크 주소의 공간을 작게, 호스트 주소의 공간을 크게 표현할 수도 있고, (c)처럼 네트워크 주소의 공간을 크게, 호스트 주소의 공간을 작게 표현할 수도 있습니다

`클래스풀 주소 체계classful addressing` : 클래스를 바탕으로 IP 주소를 관리하는 주소 체계
IP 주소에서 네트워크 주소와 호스트 주소를 구분하는 범위가 유동적일 수 있다면 네트워크 주소와 호스트 주소의 크기는 각각 어느 정도가 적당할까요? 답은 ‘상황에 따라 다르다’입니다.
`IP 주소의 클래스class` : 네트워크의 크기에 따라 유형별로 IP 주소를 분류하는 기준
A, B, C, D, E (이 중 D와 E 클래스는 각각 멀티캐스트를 위한 클래스로, 특수한 목적을 위해 예약된 클래스)

첫 옥텟의 주소만 보고도 A, B, C 클래스 중 어떤 클래스에 속한 IP 주소인지를 알 수 있습니다

● A 클래스: 0.0.0.0 ~ 127.255.255.255 => 8비트 중에서 앞이 "0"으로 시작
A 클래스의 네트워크 주소는 비트 ‘0’으로 시작해 1옥텟으로 구성되며, 호스트 주소는 3옥텟으로 구성됩니다.

● B 클래스: 128.0.0.0 ~ 191.255.255.255 => 8비트 중에서 앞으 "10'으로 시작
B 클래스의 네트워크 주소는 비트 ‘10’으로 시작해 2옥텟으로 구성되고,호스트 주소도 2옥텟으로 구성됩니다.

● C 클래스: 192.0.0.0 ~ 223.255.255.255 => "8비트 중에서 앞이 110"으로 시작 (192 ~ 223)
C 클래스의 네트워크 주소는 비트 ‘110’으로 시작해 3옥텟으로 구성되며, 호스트 주소는 1옥텟으로 구성됩니다.

> Note.
> 네트워크/브로드캐스트 주소와 예약 주소호스트의 주소 공간을 모두 사용할 수 있는 것은 아닙니다. 호스트 주소가 전부 0인 IP 주소와 호스트 주소가 전부 1인 IP 주소는 특정 호스트를 지칭하는 데 사용될 수 없습니다. 전자는 해당 네트워크 자체를 의미하는 주소로 사용되고, 후자는 브로드캐스트를 위한 주소로 사용되기 때문입니다. 가령 다음과 같은 IP 주소를 가정해 보겠습니다.
> 호스트 주소가 모두 0인 ‘172.16.0.0’은 네트워크 자체를 지칭하기 위한 주소, 호스트 주소가 모두 1인 ‘172.16.255.255’는 브로드캐스트를 위한 주소로 사용됩니다. 따라서 두 주소는 호스트 주소 할당에 사용할 수 없습니다. 또한 특수한 목적을 위해 예약된 IP 주소도 있습니다. 자주 접할 수 있는 대표적인 예약 주소의 종류는 다음과 같습니다
> 이 중 루프백 주소(loopback address)는 자기 자신을 가리키는 특별한 주소입니다. 가장 일반적으로 사용되는 루프백 주소는 ‘127.0.0.1’로, 로컬호스트(localhost)라고도 부릅니다. 루프백 주소로 전송된 패킷은 자기 자신에게 되돌아오므로 자기 자신을 마치 다른 호스트인 양 간주하여 패킷을 전송할 수 있습니다. 인터넷 표준 공식 문서(RFC 6890)에 따르면 ‘예약 IP 주소의 범위 ‘0.0.0.0 ~ 0.255.255.255는 이 네트워크의 이 호스트(This host on this network)를 지칭하도록 예약되었다’고 명시되어 있는데요. 가장 일반적으로 사용되는 주소는 ‘0.0.0.0’입니다. 이주소는 주로 호스트가 IP 주소를 할당받기 전에 임시로 사용하거나 마땅히 자신을 지칭할 IP 주소가 없을 때 사용하는 경우가 많습니다. 사설 네트워크와 관련한 내용은 00쪽에서 좀 더 알아보겠습니다

클래스리스 주소 체계와 서브넷 마스크
클래스풀 주소 체계 하에서는 클래스별 네트워크 크기가 고정 => 고정된 크기 이외에 다른 크기의 네트워크를 구성할 수 없어 IP 주소가 낭비될 수 있다
C 클래스를 사용하기에는 호스트의 수가 조금 부족해서 B 클래스를 이용하게 되면 많은 IP 주소를 낭비할 수 있다.
클래스풀 주소 체계보다 더 정교하고 유동적으로 네트워크 영역을 나눌 수단인 `클래스리스 주소 체계classless addressing`
클래스를 이용하지 않고(classless) 네트워크와 호스트를 구분하는 방식입니다. 네트워크와 호스트를 구분하는 수단으로 `서브넷 마스크`를 이용합니다.

`서브넷 마스크(subnet mask)`란 IP 주소상에서 네트워크 주소를 1로 표기하고, 호스트 주소를 0으로 표기한 비트열입니다.
그리고 `서브네트워크(서브넷, subnetwork)`는 IP 주소에서 네트워크 주소로 구분할 수 있는 네트워크의 부분집합, 서브넷 마스크는 곧 서브넷을 구분(마스크mask)하는 비트열인 셈입니다.

또 이러한 서브넷 마스크를 이용해 원하는 크기로 클래스를 더 잘게 쪼개어 사용하는 것은 `서브네팅subnetting`
클래스풀 주소 체계에서 A 클래스의 네트워크 주소는 8비트, B 클래스의 네트워크 주소는 16비트, C 클래스의 네트워크 주소는 24비트로 이루어져 있기 때문에 A, B, C 클래스의 기본 서브넷 마스크는 다음과 같이 표현할 수 있습니다
서브넷 마스크와 IP 주소 간에 비트 AND 연산을 수행하면 IP 주소 내의 네트워크 주소를 알아낼 수 있습니다.

> CIDR 표기 - 서브넷 마스크 표기법
> 서브넷 마스크를 ‘255.255.255.0’, ‘255.255.255.252’와 같이 10진수로 직접 표기하는 방법도 있지만, ‘IP 주소/서브넷 마스크상의 1의 개수’의 형식으로 표기하는 방법도 있습니다. 후자의 방식을 `CIDR 표기법(Classless Inter-Domain Routing notation)`이라고 부르며, IP 주소와 서브넷 마스크를 함께 표현할 수 있는 간단한 표기로 많이 활용합니다.
> 예를 들어 보겠습니다. ‘192.168.20.3/30’이라고 표기한 서브넷 마스크가 있다고 가정해 봅시다. ‘/30’은 서브넷 마스크 상에서 1이 총 30개가 있다는 것을 의미하므로 서브넷 마스크는 ‘11111111.11111111.11111111.11111100’이 됩니다. 즉, ‘/30’은 ‘255.255.255.252’와 같은 표기입니다

### 공인 IP 주소와 사설 IP 주소

`IP 주소는 유일하고 고유한 주소?` = 고유한 IP 주소도 있고, 고유하지 않은 IP 주소도 있습니다. 그리고 이 두 종류의 IP 주소는 함께 사용되는 경우가 많습니다.

`공인 IP 주소` 고유한 IP 주소
`사설 IP 주소` 고유하지 않은 IP 주소

` 공인 IP 주소public IP address`는 전 세계에서 고유한 IP 주소입니다.
인터넷을 비롯한 네트워크 간 통신에서 사용되는 IP 주소가 바로 공인 IP 주소입니다.
앞서 우리가 검색 사이트를 통해 확인했던 IP 주소가 바로 공인 IP 주소입니다.
구글이나 네이버 등의 검색 사이트의 서버와 패킷을 주고받으려면 호스트가 속한 네트워크 밖에서 사용할 공인 IP 주소를 사용해야 하기 때문입니다. 공인 IP 주소는 ISP나 공인 IP 주소 할당 기관을 통해 할당받을 수 있습니다

`사설 IP 주소private IP address`는 사설 네트워크에서 사용하기 위한 IP 주소를 말합니다. 사설 네트워크란 외부 네트워크에 공개되지 않은 네트워크를 의미합니다. 사설 IP 주소는 일반적으로 라우터(공유기)를 통해 할당되기 때문에 공유기(라우터)를 중심으로 구성된 LAN 대부분은 사설 네트워크에 해당합니다. IP 주소 공간 중에서 사설 IP 주소로 사용하도록 특별히 예약된 IP 주소 공간이 있습니다.
사설 IP 주소는 해당 호스트가 속한 사설 네트워크상에서만 유효한 주소이므로 얼마든지 다른 네트워크상의 사설 IP 주소와 중복될 수 있다는 점에 유의하세요.

### IP 주소의 할당

이번에는 호스트에 IP 주소를 할당하는 방법을 알아봅시다.

- `정적 할당`
  직접 수작업으로 IP 주소를 부여하는 방식
  `정적 IP 주소static IP address` : 정적 할당을 통해 할당된 IP 주소
  운영체제의 종류를 막론하고 IP 주소를 수동으로 설정하는 설정 혹은 명령어가 있습니다

  정적 IP 주소를 부여하기 위해 입력해야 하는 값(정적 IP 주소를 부여하기 위해 필요한 값)에 유의해야 합니다.
  일반적으로는 정적 IP 주소를 부여하고자 하는 IP 주소와 서브넷 마스크, 게이트웨이(라우터) 주소, DNS 주소 등이 필요한데,
  이 값은 운영체제에 관계없이 대체적으로 유사합니다.

  - `게이트웨이gateway`는 일반적으로 서로 다른 네트워크를 연결하는 하드웨어적/소프트웨어적 수단
    `기본 게이트웨이default gateway`는 호스트가 속한 네트워크의 외부로 나가기 위한 첫 기본 경로
    => 기본 게이트웨이는 네트워크 외부와 연결된 라우터(공유기)의 주소를 의미하는 경우가 많다.

  IP 할당의 맥락에서 사용되는 ‘게이트웨이’라는 용어는 기본 게이트웨이를 의미하므로 게이트웨이(라우터) 주소에는 기본 게이트웨이의 역할을 하는 라우터(공유기)의 주소를 적어 주면 됩니다.

  - `DNS 주소`는 호스트가 도메인 네임을 토대로 IP 주소를 알아내기 위해 질의하는 서버의 주소.
    기본적으로 호스트끼리 패킷을 주고받기 위해서는 IP 주소가 사용되지만, 통신을 주고받는 모든 호스트의 IP 주소를 기억하기는 어렵죠.
    `도메인 네임` :IP 주소에 대응되는 기억할 수 있는 호스트를 식별할 수 있는 문자열 e.g. ‘google.com, hanbit.co.kr, minchul.net’
    호스트가 DNS 서버에 질의하여 도메인 네임에 대응되는 IP 주소를 알아낸다.
    `DNS 서버` : <도메인 네임, IP 주소> 쌍을 저장하는 서버

`동적 할당`
프로토콜을 통해 자동으로 IP 주소를 부여하는 방식
동적 할당을 통해 할당된 IP 주소를 `동적 IP 주소dynamic IP address`라고 합니다.
이 과정에서 가장 흔히 사용되는 프로토콜이 `DHCPDynamic Host Configuration Protocol`인데요.
호스트에 수동으로 직접 IP 주소를 할당하지 않고도 호스트에 IP 주소가 부여되어 있다면 IP 주소가 동적으로 할당되었기 때문입니다.

일상적으로 동적 IP 주소가 많이 사용되는 만큼, DHCP 또한 빈번히 사용됩니다.
IP 주소를 동적으로 할당받고자 하는 호스트는 DHCP 서버와 메시지를 주고받으며 동적 IP 주소를 할당받을 수 있습니다.
`DHCP 서버` : 호스트에 할당 가능한 IP 주소 목록을 관리하다가, IP 주소 할당 요청을 받았을 때 IP 주소를 할당해 주는 호스트 일반적으로 라우터(공유기)가 DHCP 서버 역할을 수행하죠.

1. 동적 IP 주소에는 사용 가능한 기간(임대 기간)이 정해져 있다.
2. 동적 IP 주소는 할당받을 때마다 다른 주소를 받을 수 있다.
   => 컴퓨터의 진짜 정보를 보내는 게 아니라, 공유기가

DHCP로 할당받은 IP 주소는 사용할 기간(일반적으로 수 시간에서 수 일)이 정해져 있고, 사용되지 않을 경우 회수됩니다.
사용 기간이 끝난 IP 주소는 DHCP 서버로 반납되고, 새롭게 IP 주소를 할당받는 경우 다른 IP 주소를 할당받을 수 있습니다.
DHCP를 통한 IP 주소의 동적 할당은 이런 점에서 ‘IP 주소의 임대’라고 표현하기도 합니다.
참고로, IP 주소의 임대 기간이 끝나기 전에 임대 기간을 연장할 수도 있습니다.
이를 임대 갱신lease renewal이라고 하며, 기본적으로 임대 갱신은 자동으로 두 차례가 수행되고, 두 번의 임대 갱신이 모두 실패하면 그때 IP 주소는 DHCP 서버로 반납됩니다

| 유형                     | 설명                                                    | 사용 예시                            |
| ------------------------ | ------------------------------------------------------- | ------------------------------------ |
| **정적 IP (Static IP)**  | 고정된 IP 주소. 변경되지 않음.                          | 서버(웹사이트 운영, 프린터, CCTV 등) |
| **동적 IP (Dynamic IP)** | DHCP 서버가 자동으로 할당. 일정 시간 후 변경될 수 있음. | 일반 가정용 컴퓨터, 스마트폰 등      |

### Q. IP 주소의 정적할당에 DNS가 들어가면, 내가 웹사이트에서 네트워크 통신을 요청하면 그건 정적 할당인가 동적할당인가?

🌐 www.google.com 입력 → 요청이 전송되는 전체 흐름

1. 도메인 입력
   사용자가 브라우저 주소창에 www.google.com을 입력합니다.
2. DNS 질의 (Domain Name System)
   컴퓨터는 먼저 DNS 서버에 요청해서 www.google.com이 어떤 IP 주소인지 물어봐요.
   예: www.google.com → 142.250.206.132 (이건 예시 IP예요)
   이 IP 주소는 보통 정적 IP 주소입니다.
   구글처럼 항상 같은 주소를 써야 하는 서버는 IP가 바뀌면 안 되니까요.
3. IP 주소로 패킷 생성
   DNS로 얻은 IP 주소를 **수신지(destination)**로 설정해서 요청 패킷을 만듭니다.
   이 패킷은 TCP/IP 계층을 거쳐 네트워크로 전송됩니다.
4. 라우팅 & 전송
   IP 주소를 기반으로 라우터들이 목적지를 찾아서,
   결국 구글의 웹 서버까지 요청이 도달합니다.
5. 응답 수신
   서버는 요청을 받고, 응답(예: HTML 웹 페이지)을 다시 **당신의 컴퓨터 IP 주소(발신지)**로 보내줘요

### Q. 공유기를 사용한 통신

```
동적 IP 주소를 보면서 떠오른건데, 공유기를 통해 서로 다른 LAN이 통신할 때에, 공유기가 컴퓨터의 요청을 받고 해당 기기의 주소를 동적으로 할당해서 공유기가 할당한 주소를 발신지로 설정해 서버에 요청을 보낸다. 이후에 서버에서 응답을 받으면 패킷의 헤더에 담긴 주소에 해당하는 컴퓨터를 구분하여 데이터를 보내준다! 그래서 동적 IP 주소가 같은 장치더라도 요청때마다 다를 수 있다! 이게 맞나
```

🧠 상황 요약 (공유기 아래 여러 컴퓨터가 있을 때)
📌 용어 정리
LAN (Local Area Network): 집이나 사무실 내부의 네트워크

    공유기(Router): 외부 인터넷과 내부 네트워크(LAN)를 연결하는 장치

    NAT (Network Address Translation): 공유기가 내부 IP ↔ 외부 IP 주소를 매핑해주는 기술

    DHCP (Dynamic Host Configuration Protocol): 장치에게 동적으로 IP 주소를 할당해주는 프로토콜

📍 정확한 흐름 정리
✅ 1. 내부 IP 주소 (동적 할당)

    공유기 내부에는 여러 기기(컴퓨터, 스마트폰 등)가 연결되어 있어요.

    이때 공유기는 각 장치에게 **내부 IP 주소(예: 192.168.0.10)**를 **동적으로 할당(DHCP)**합니다.

    이 주소는 일정 시간 뒤 변경될 수 있음 = 동적 IP

    동일 장치라도 재접속하거나 시간이 지나면 다른 IP를 받을 수 있어요.

✅ 2. 외부 요청 시 (NAT 동작)

    컴퓨터가 인터넷(예: www.google.com)으로
    요청을 보내면,

    공유기는 외부 IP(공인 IP) 하나만 갖고 있기 때문에,

    컴퓨터의 내부 IP → 공유기의 외부 IP로 **변환(NAT)**해서 요청을 보냅니다.

    이때 공유기는 포트 번호 등을 이용해 누가 보낸 요청인지 기록해둡니다. (NAT 테이블)

✅ 3. 서버 응답 시

    서버는 요청을 보낸 공유기의 공인 IP로 응답을 돌려보냅니다.

    공유기는 NAT 테이블을 참고해:

    어떤 내부 IP + 포트 번호로 보내야 할지 확인하고

    정확히 해당 컴퓨터로 응답을 전달합니다.

🧾 질문 요약에 대한 피드백
✔ 맞는 부분

    ✅ 공유기가 각 컴퓨터에 동적 IP 주소를 할당(DHCP)
    ✅ 요청을 받을 때 해당 기기의 주소를 기반으로 NAT 변환
    ✅ 서버에 요청을 보낼 때 공유기의 공인 IP + 포트 번호 조합을 발신지로 사용
    ✅ 서버 응답은 NAT 테이블을 통해 정확한 내부 장치로 전달

⚠ 수정이 필요한 부분

    "공유기가 할당한 주소를 발신지로 설정해 서버에 요청을 보낸다"

    → 공유기가 서버에 보내는 발신지는 “공유기의 공인 IP 주소 + 포트 번호”입니다,
    내부 장치의 동적 IP는 직접 노출되지 않아요.

📌 비유로 간단히 설명하면

    공유기 = 회사 리셉션

    내부 컴퓨터들 = 직원들

    외부 인터넷 서버 = 외부 거래처

    직원이 거래처에 문서를 보내려고 하면,

    리셉션이 대신 문서를 전달하고,

    문서에는 직원의 이름 대신 리셉션의 주소 + 코드번호만 써요.

    거래처는 리셉션으로 답장을 보내고,

    리셉션이 코드번호를 보고 누가 보냈는지 파악해서 직원에게 전달합니다.

✅ 결론

    동적 IP 주소는 공유기 내부 네트워크에서 사용되는 주소이고,
    외부로 요청을 보낼 땐 공유기의 공인 IP를 사용하며,
    공유기는 NAT를 통해 내부 장치와의 연결을 추적하고 응답을 정확히 되돌려줍니다.

### IP 전송 특징의 보완: ICMP

IP : 신뢰할 수 없는 프로토콜이자, 비연결형 프로토콜 => 빠른 송수신 가능
신뢰성 + 연결형 통신이 필요하다면?

1. 신뢰할 수 있는 연결형 통신을 지원하는 상위 계층의 프로토콜을 이용하기
   TCP를 통해 패킷을 송수신하면 신뢰성과 연결형 통신을 보장할 수 있다.

2. `ICMP(Internet Control Message Protocol)`
   IP 패킷의 전송 과정에 대한 피드백 메시지(이하 ICMP 메시지)를 얻기 위해 사용하는 프로토콜
   ICMP 메시지를 통해 패킷이 상대방에게 어떻게 전송되었는지를 알려줄 수 있어 IP 전송의 결과를 엿볼 수 있습니다.

[네트워크 도달 불가] ICMP 메시지를 : 패킷의 발신지\*수신지를 모를 경우
[단편화가 필요하지만 DF가 1로 설정되어 단편화할 수 없음]을 나타내는 ICMP 메시지를 : 처리하기에 너무 큰 패킷을 전달받았는데, DF 플래그가 설정되어 있어 단편화가 불가능할 경우

[시간 초과Time Exceeded] ICMP 메시지가 전송됩니다 : `TTLTime To Live(패킷의 수명)` 필드가 있습니다. 패킷은 멀리 떨어진 호스트끼리 통신할 때 여러 라우터를 거쳐 이동할 수 있는데, 패킷이 하나의 라우터를 거칠 때(`홉hop`)마다 TTL이 1씩 감소하고, TTL 필드가 0이 되면 해당 패킷은 폐기되고 전송되는 메시지.

### IP 주소와 MAC 주소의 대응: ARP

`앞서 IP의 목적과 특징을 설명하며 MAC 주소는 택배 배송 과정의 수신인과 발신인, IP 주소는 수신 주소와 발신 주소에 빗댈 수 있다고 설명했습니다. 택배 배달 과정에서 수신인과 발신인, 수신/발신 주소를 모두 사용하되 주소를 우선적으로 활용하듯, 패킷의 송수신 과정에서도 IP 주소와 MAC 주소를 함께 사용하지만 MAC 주소보다 IP 주소를 우선적으로 활용한다고도 했습니다.`
이때 상대 호스트의 IP 주소는 알고, MAC 주소는 모르는 상황에서 사용되는 프로토콜이 ARP입니다.
`ARP(Address Resolution Protocol)`  
IP 주소와 MAC 주소를 함께 활용하는 통신 과정에서 동일 네트워크 내에 있는 송수신 대상의 IP 주소를 통해 MAC 주소를 알아내는 프로토콜입니다.
다음과 같이 호스트 A와 B가 동일한 네트워크에 속한 상태를 가정해 보겠습니다. 패킷을 보내는 호스트 A가 호스트 B의 IP 주소는 알고, MAC 주소는 모르는 상황입니다. 통신 과정에서는 IP 주소와 MAC 주소가 함께 사용되기 때문에 호스트 A가 호스트 B의 MAC 주소를 알기 전에는 올바르게 패킷을 송신하기가 어렵습니다. 이럴 때 사용되는 프로토콜이 바로 ARP입니다

ARP 프로토콜은 동작 과정을 이해하는 것이 중요합니다.

ARP의 동작 과정, 즉, IP 주소를 통해 모르는 MAC 주소를 알아내는 과정은 ARP 요청 메시지와 ARP 응답 메시지를 통해 이루어집니다. ARP 요청은 브로드캐스트 메시지(네트워크 내에 있는 모든 호스트에게 보내는 메시지)입니다. ARP 요청 메시지에는 알고 싶은 MAC 주소에 대응되는 IP 주소가 포함되어 있습니다. 그렇기 때문에 ARP 메시지를 브로드캐스트하는 것은 마치 ‘이 IP 주소를 가진 호스트와 통신하고 싶은데, 이 호스트의 MAC 주소가 무엇인가요?’라고 소리치는 것과 같습니다.
ARP 요청 메시지는 브로드캐스트 메시지이기 때문에 네트워크 내 모든 호스트가 이를 수신합니다.
=> ARP 요청 메시지에 포함된 IP 주소를 확인해 자신과 관련이 없는 IP 주소일 경우에는 무시,
=> 자신의 IP 주소일 경우에는 ARP 응답 메시지(응답 메시지를 보내는 호스트의 MAC 주소가 포함) 전달
따라서 ARP 요청 메시지를 보낸 호스트가 ARP 응답 메시지를 수신하면 IP 주소를 통해 MAC 주소를 알아낼 수 있는 것입니다.
나중에 같은 호스트에게 패킷을 보내야 할 때마다 브로드캐스트(ARP 요청) 메시지를 보내지 않기 위해서 ARP를 활용하는 호스트는 `ARP 테이블ARP Table`이라는 정보를 유지합니다.
ARP 테이블은 < IP 주소, MAC 주소 >의 항목들로 구성된 표 형태의 정보로, ARP 요청 메시지와 ARP 응답 메시지를 통해 알게 된 < IP 주소, MAC 주소 > 쌍은 ARP 테이블에 추가되죠.
ARP 테이블 항목은 일정 시간이 지나면 삭제되고, 임의로 삭제할 수도 있습니다.

------------------------------------------(여기까지!!!!)******************\_\_\_******************

## 4. 전송 계층 - TCP와 UDP

이제 전송 계층에 대해 학습할 차례입니다. 네트워크 계층에서 가장 중요한 프로토콜이 IP라면, 전
송 계층에서 가장 중요한 프로토콜은 TCP와 UDP입니다. TCP와 UDP는 매우 중요한 프로토콜이
므로 각각 어떤 목적과 특징이 있는지 잘 기억해 두는 것이 좋습니다.
TCP와 UDP의 목적과 특징
TCP와 UDP의 패킷 구조와 동작 원리를 이해하면 전송 계층의 핵심을 이해할 수 있습니다. IP에
관련해 그 목적과 특징을 먼저 알아봤듯, TCP와 UDP가 어떤 기능과 차이점이 있는지 각각의 목적
과 특징에 유의하며 학습해 보겠습니다.

포트를 통한 프로세스 식별
IP 주소와 MAC 주소는 패킷을 송수신하는 호스트를 특정할 수 있습니다. 그런데 사실 패킷의 최종
송수신 대상은 호스트가 아니라 호스트가 실행하는 프로세스입니다. 가령 하나의 호스트는 웹 브라우
저, 게임, 채팅 프로그램 등 다양한 프로세스를 동시에 실행할 수 있고, 네트워크를 통해 주고받는 패
킷은 최종적으로 이러한 프로세스에 전달되어야 합니다. 그렇다면 네트워크 상에서 호스트가 실행
하는 프로세스는 어떻게 식별할 수 있을까요?
포트port 번호를 통해 식별할 수 있습니다. 네트워크 패킷을 주고받는 프로세스에는 포트 번호가 할당
됩니다. 즉, IP 주소와 포트 번호의 조합을 통해 ‘특정 호스트가 실행하는 특정 프로세스’를 식별할
수 있습니다. 그래서 IP 주소와 포트 번호는 다음과 같이 ‘IP 주소:포트 번호’의 형식으로 함께 표기되
는 경우가 많습니다

포트를 통한 프로세스 식별은 전송 계층(TCP, UDP)의 주된 목적입니다. 전송 계층의 핵심 프로토
콜인 TCP와 UDP는 모두 포트를 통해 프로세스를 식별할 수 있습니다. 다음의 TCP와 UDP 헤더
를 살펴보면 TCP와 UDP 모두 포트 번호 필드인 송신지 포트 번호와 수신지 포트 번호를 포함하고
있다는 것을 알 수 있습니다.

포트 번호는 개발자가 자주 다루는 정보 중 하나이므로 조금 더 자세히 알아 두는 것이 좋습니다.
16비트로 표현할 수 있는 포트 번호의 총 개수는 216, 즉 65536개입니다. 0번부터 할당되므로 0번
부터 65535번까지의 포트 번호를 할당할 수 있죠. 그리고 65536개의 포트 번호는 번호의 범위에
따라 3가지 종류로 나뉩니다. 각각 ‘잘 알려진 포트’, ‘등록된 포트’, ‘동적 포트’입니다

0번부터 1023번까지는 잘 알려진 포트well known port의 번호입니다(영문 그대로 웰 노운 포트라고 부르
는 경우가 많습니다). 잘 알려진 포트는 이름 그대로 가장 대중적으로 사용되는 애플리케이션을 위
한 포트 번호입니다. 범용적으로 사용되는 프로토콜이 주로 사용하는 포트 번호 목록이라고 보아도
무방합니다.

또 1024번부터 49151번까지는 등록된 포트registered port의 번호입니다. 등록된 포트는 잘 알려진 포트
에 비해서는 덜 범용적이지만, 다음과 같이 흔하게 사용되는 애플리케이션 프로토콜에 할당하기 위
한 포트 번호입니다.

잘 알려진 포트와 등록된 포트는 서버로 동작하는 프로그램 환경에서 자주 볼 수 있습니다. 예를 들
어 다음과 같이 MySQL 데이터베이스 서버를 연결할 때 등록된 포트의 3306번이 활용되는 것을 볼
수 있습니다

다음은 HTTP 서버 프로그램 중 하나인 아파치 HTTP 서버의 설정 파일 일부입니다. ’Listen 80’
은 ‘이 웹 서버는 80번 포트를 통해 패킷을 송수신한다’는 의미이고, ‘Listen 443’은 ‘이 웹 서버는
(HTTPS 기반 기술인 SSL, TLS 관련 모듈이 있을 경우)443번 포트를 통해 패킷을 송수신한다’는
의미입니다. 포트 번호 80번과 443번은 잘 알려진 포트 번호로, 각각 HTTP와 HTTPS에 주로 할
당되는 포트입니다. 실제로 이 웹 서버는 HTTP 프로토콜로 송수신할 경우 80번 포트를 이용하고,
HTTPS 프로토콜로 송수신할 경우 443 포트를 이용합니다

남은 포트 번호 49152번부터 65535번까지는 사설 포트private port 또는 임시 포트ephemeral port라고도 불리
는 동적 포트dynamic port로, 비교적 자유롭게 사용 가능한 포트 번호입니다. 서버로서 동작하는 프로그
램의 경우 주로 잘 알려진 포트와 등록된 포트가 할당되는 경우가 많지만, 클라이언트로서 동작하는
프로그램의 경우에는 동적 포트 번호 중에서 임의의 번호가 할당되는 경우가 많습니다. 그 대표적인
예시가 웹 브라우저입니다. 웹 브라우저를 통해 특정 웹사이트에 접속하는 경우를 생각해 보죠. 이
는 웹 브라우저 프로그램과 서버 프로그램이 서로 패킷을 주고받는 상황과 같습니다. 이 경우, 웹 브
라우저 프로그램에는 동적 포트 내 임의의 포트 번호가 자동으로 할당됩니다

NAT와 NAPT
포트와 관련해 한 가지 더 알아 둘 개념이 있습니다. 바로 공인 IP 주소와 사설 IP 주소 간 변환을 위해 사용하
는 기술인 NAT인데요. 앞서 우리는 네트워크 외부에서 주로 사용되는 공인 IP 주소와 네트워크 내부에서 주
로 사용되는 사설 IP 주소에 대해 학습했습니다. 네트워크 내부에서 사설 IP 주소를 사용하는 호스트가 네트워
크 외부에 있는 호스트와 패킷을 주고받기 위해서는 공인 IP 주소와 사설 IP 주소 간 변환이 필요합니다. 이때
사용되는 기술이 바로 NAT(Network Address Translation)입니다.
대부분의 라우터와 (가정용)공유기는 NAT 기능을 내장하고 있기 때문에 사설 네트워크에서 만들어진 패킷
이 네트워크 외부로 전송될 때는 다음 그림 속 ➊의 과정을 거치고(사설 IP 주소 → 공인 IP 주소 변환), 네트
워크 외부의 패킷이 사설 네트워크 속 호스트에 이를 때는 ➋의 과정을 거칩니다(공인 IP 주소 → 사설 IP 주
소 변환)

그림에서는 네트워크 내부에 있는 사설 IP 주소 하나는 공인 IP 주소 하나로 일대일 대응되어 변환됩니다. 그
러나 이와 같이 사설 IP 주소와 공인 IP 주소를 일대일로 변환하면 사설 IP 주소 수만큼의 공인 IP 주소가 필요
하므로 많은 공인 IP 주소가 필요할 수 있습니다. 그래서 오늘날 대중적으로 활용되고 있는 NAT는 변환하고
자 하는 IP 주소를 일대일로 대응하지 않고, 다수의 사설 IP 주소를 그보다 적은 수의 공인 IP 주소로 변환합니
다. 사설 IP 주소를 사용하는 여러 호스트가 적은 수의 공인 IP 주소를 공유하는 것입니다. 그렇다면 여러 개의
사설 IP 주소는 어떻게 고유한 주소인 공인 IP 주소 하나로 변환될 수 있을까요? 여기서 활용되는 것이 바로
포트입니다.
서로 다른 사설 IP 주소가 같은 공인 IP 주소로 변환되더라도 다른 포트 번호로 변환된다면 네트워크 내부
의 호스트를 특정할 수 있습니다. 가령 ‘1.2.3.4’라는 동일한 공인 IP 주소로 변환되더라도 포트 번호 6200번
으로 변환되는지, 6201번으로 변환되는지에 따라 내부 IP 주소를 구분할 수 있습니다. 이처럼 IP 주소 변환
과정에서 변환할 IP 주소의 쌍과 더불어, 포트 번호도 함께 고려하는 포트 기반의 NAT를 NAPT(Network
Address Port Translation)라고 합니다.
요컨대, NAPT는 변환할 IP 주소 쌍과 더불어 포트 번호도 함께 기록하고 변환함으로써 하나의 공인 IP 주소
를 여러 사설 IP 주소가 공유할 수 있도록 하는 NAT의 일종입니다. NAPT는 네트워크 내부에서 사용할 IP
주소와 네트워크 외부에서 사용할 IP 주소를 N:1로 관리할 수 있다는 점에서, 공인 IP 주소 수의 부족 문제를
개선하는 기술로도 간주되고 있습니다

(비)신뢰성과 (비)연결형 보장
192.168.0.6
192.168.0.5
TCP를 통해 신뢰할 수 있는 연결형 송수신이 가능하고, UDP를 통해 신뢰할 수 없는 비연결형 송
수신이 가능합니다. 다시 말해, TCP는 신뢰할 수 있는 프로토콜이자 연결형 프로토콜이고, UDP는
신뢰할 수 없는 프로토콜이자 비연결형 프로토콜입니다.
TCP는 패킷을 주고받기 전에 연결 수립 과정을 거치며, 연결 수립 이후 패킷을 주고받을 때 신뢰성
보장을 위해 상태 관리, 흐름 제어, 오류 제어, 혼잡 제어 등의 각종 기능을 제공합니다. 그리고 패킷
의 송수신이 모두 끝나면 연결을 종료하죠. 반면, UDP는 연결의 수립이나 종료 단계를 거치지 않
고, 신뢰성을 높이기 위한 기능들도 제공하지 않습니다

물론 신뢰할 수 있는 연결형 송수신에는 시간과 연산이 소요되기 때문에 일반적으로 TCP가 UDP
에 비해 송수신 속도가 느립니다. 따라서 패킷의 유실 없는 송수신을 원한다면 UDP보다 TCP를 선
택하는 것이 유리하고, 비교적 빠른 송수신을 원한다면 TCP보다 UDP를 선택하는 것이 유리합니다.
TCP와 UDP의 특징은 헤더를 살펴보면 이해할 수 있습니다. UDP 헤더부터 먼저 살펴보죠. UDP
헤더에는 다음과 같이 포트 번호가 명시되는 필드가 있습니다. 송신지 포트Source Port에는 송신 프로세
스가 할당된 포트 번호, 수신지 포트Destination Port에는 수신 프로세스가 할당된 포트 번호가 명시됩니다.
나머지 길이length 필드에는 헤더를 포함한 UDP 패킷(UDP 데이터그램)의 바이트 크기가 명시되고,
체크섬checksum 필드에는 송수신 과정에서의 데이터그램 훼손 여부를 알 수 있는 정보가 명시됩니다

TCP 헤더 필드의 수는 UDP보다 훨씬 많습니다. TCP가 UDP와 달리 연결의 수립과 종료, 신뢰
성 보장을 위한 여러 기능을 제공하기 때문입니다(사실상 UDP 헤더는 IP 헤더를 감싸는 일종의
껍데기와 같습니다). UDP 헤더에 있는 모든 필드가 TCP 헤더에 포함되어 있죠. 이 중 우리가 우
선적으로 알아야 하는 필드는 3가지입니다. 순서 번호 필드와 확인 응답 번호 필드, 일부 제어 비트
(ACK 플래그, SYN 플래그, FIN 플래그)입니다.

각각 순서 번호와 확인 응답 번호가 명시되는 순서 번호 필드와 확인 응답 번호 필드는 함께 사용되
므로 한 쌍처럼 기억해 두는 것이 좋습니다. 순서 번호sequence number란 TCP 패킷(TCP 세그먼트)의
올바른 송수신 순서를 보장하기 위해 세그먼트 첫 바이트에 매겨진 번호입니다. 순서 번호를 통해
현재 주고받는 TCP 세그먼트가 송수신하고자 하는 데이터의 몇 번째 바이트에 해당하는지 알 수 있
는 셈입니다.
확인 응답 번호acknowledgment number는 상대 호스트가 보낸 세그먼트에 대한 응답으로, 다음으로 수신하길
기대하는 순서 번호입니다. 일반적으로 ‘올바르게 수신한 순서 번호에 1이 더해진 값’으로 설정되죠.
예를 들어 다음과 같이 상대 호스트인 A가 순서 번호 100인 세그먼트를 전송했고 호스트 B가 이를
잘 수신한 뒤, 그 다음으로 101번 세그먼트를 받고자 하는 경우를 가정해 보겠습니다. 그럼 호스트
B는 상대 호스트 A에게 ‘다음으로 101번 세그먼트를 받기를 희망함’을 알리기 위해 확인 응답 필드
에 ‘101’을 명시합니다.

이때 호스트 B는 상대 호스트 A에게 ‘이 세그먼트는 확인 응답 번호를 포함하고 있음’을 알리기 위
해 ACK 플래그를 1로 설정해야 합니다. ACK 플래그는 제어 비트에서 ‘승인’을 나타내는 비트입
니다. 다시 말해, 확인 응답 번호 값을 보내기 위해서는 제어 비트의 ACK 플래그가 1로 설정되어
있어야 합니다. 앞선 예시에서 호스트 B는 ACK 플래그를 1로 설정한 뒤, 확인 응답 번호 필드에
‘101’을 명시한 세그먼트를 전송하게 됩니다

즉, 호스트 B는 확인 응답 번호를 통해 상대 호스트 A에 보낸 패킷에 상대 호스트가 어떻게 반응했
는지, 상대 호스트가 다음으로 받고자 하는 패킷이 무엇인지를 알 수 있습니다. 이렇듯 TCP의 신뢰
성 보장은 거의 대부분 확인 응답 번호를 통해 이루어진다고 해도 과언이 아닙니다.
이번에는 제어 비트를 살펴볼까요? 제어 비트control bits는 현재 세그먼트에 대한 부가 정보를 나타내는
정보로, 플래그 비트flag bits라고도 부릅니다. 제어 비트는 기본적으로 8비트로 구성되며, 각 자리의 비
트가 각기 다른 의미를 가집니다. 이후 언급될 TCP의 기본 송수신을 이해하기 위해서는 기본적으
로 다음 3가지 제어 비트에 대해 알고 있어야 합니다. 아직은 각각의 의미가 와닿지 않더라도 뒤에
서 설명할 예정이므로 지금은 가볍게 읽어 보고 학습을 이어가기 바랍니다

ACK: 세그먼트의 승인을 나타내기 위한 비트
● SYN: 연결을 수립하기 위한 비트
● FIN: 연결을 종료하기 위한 비트

TCP의 연결부터 종료까지
TCP는 UDP와 달리 송수신 이전에 연결을 수립하고, 송수신 이후에는 연결을 종료합니다. 송수신
전후로 ‘상태’라는 값을 관리하기도 하죠. TCP의 연결부터 종료까지 일련의 송수신 과정을 차례로
톺아보면서 TCP의 동작을 이해해 보겠습니다

TCP의 연결 수립
TCP의 연결 수립은 쓰리 웨이 핸드셰이크를 통해 이루어집니다. 쓰리 웨이 핸드셰이크three-way handshake
는 쓰리 웨이라는 이름처럼 세 단계로 이루어진 TCP의 연결 수립 과정을 뜻합니다. 가령 호스트 A가
호스트 B에게 처음 연결 요청을 보낸다고 가정했을 때 각각의 단계는 다음과 같습니다.
➊ [송수신 방향 A → B] SYN 세그먼트 전송
호스트 A는 SYN 비트가 1로 설정된 세그먼트(이하 SYN 세그먼트)를 호스트 B에게 전송합니다.
이때 세그먼트의 순서 번호에는 호스트 A의 순서 번호가 포함되어 있습니다.
➋ [송수신 방향 B → A] SYN + ACK 세그먼트 전송
➊에 대한 호스트 B의 응답입니다. 호스트 B는 ACK 비트와 SYN 비트가 1로 설정된 세그먼트(이
하 SYN+ACK 세그먼트)를 호스트 A에게 전송합니다. 세그먼트의 순서 번호에는 호스트 B의 순
서 번호와 ➊에서 보낸 세그먼트에 대한 확인 응답 번호가 포함되어 있습니다.
➌ [송수신 방향 A → B] ACK 세그먼트 전송
호스트 A는 ACK 비트가 1로 설정된 세그먼트(이하 ACK 세그먼트)를 호스트 B에게 전송합니다.
세그먼트의 순서 번호에는 호스트 A의 순서 번호와 ➋에서 보낸 세그먼트에 대한 확인 응답 번호가
포함되어 있습니다.
SYN 비트는 연결을 수립하기 위한 비트입니다. TCP 연결 수립 과정에서 SYN 비트가 설정된 패킷
을 처음으로 보내는 호스트가 곧 처음으로 연결 요청을 보내는 호스트입니다. ➊에서 SYN 비트가 1
로 설정된 패킷을 처음으로 보내는 호스트 A가 연결 요청을 처음으로 보내는 호스트인 셈입니다. 호
스트 A처럼 처음 연결을 시작하는 과정은 액티브 오픈active open이라고 하고, 반대로 호스트 B처럼 연
결 요청을 수신한 뒤 그에 대한 연결을 수립하는 과정은 패시브 오픈passive open이라고 합니다. 서버 -
클라이언트 관계에서 액티브 오픈은 주로 클라이언트에 의해 수행되고, 패시브 오픈은 주로 서버에
의해 수행됩니다. 지금까지 설명한 TCP의 연결 수립 과정은 다음과 같은 그림으로 표현할 수 있습
니다

실제 패킷을 통해 쓰리 웨이 핸드셰이크를 관찰해 봅시다. SYN 세그먼트 전송과 SYN + ACK 세
그먼트 전송, ACK 세그먼트 전송으로 이어지는 쓰리 웨이 핸드셰이크의 단계를 하나씩 살펴보겠습
니다.
➊ SYN 세그먼트 전송
다음은 호스트 ‘192.168.0.1’이 호스트 ‘10.10.10.1’에게 첫 SYN 세그먼트를 보내는 예시 화면입
니다. 송신지 포트 번호(Source Port)는 49859이고, 수신지 포트 번호(Destination Port)는 80
인 것을 볼 수 있는데요. 포트 번호 49859는 동적 포트이고, 포트 번호 80은 잘 알려진 포트 번호로
써 HTTP에 해당하는 포트 번호입니다. 즉, 해당 세그먼트는 송신 호스트 ‘192.168.0.1’의 클라이
언트 프로세스가 임의의 동적 포트 번호 49859를 할당받아 HTTP 서버로서 동작하는 ‘10.10.10.1’
에게 연결 요청을 보낸 상황이라고 추측할 수 있습니다.

순서 번호(Sequence Number)도 볼 수 있는데요. 제시된 화면 속 프로그램에서는 보기 편하도
록 상대적인 순서 번호(relative sequence number)를 매기기는 했지만, 실제 순서 번호(raw)
는 3588415412입니다. 또한 플래그 값(Flags)을 보면 쓰리 웨이 핸드셰이크를 시작하는 세그먼
트인 SYN 비트가 1로 설정되어 있는 것을 볼 수 있습니다.
➋ SYN + ACK 세그먼트 전송
다음은 쓰리 웨이 핸드셰이크 과정의 두 번째 세그먼트로, 80번 포트에서 동작하는 호스트
‘10.10.10.1’의 프로세스가 499859번 포트에서 동작하는 호스트 ‘192.168.0.1’의 프로세스에게
전송하는 세그먼트입니다. 명시된 순서 번호 697411256는 연결 요청을 받은 호스트 ‘10.10.10.1’
의 순서 번호입니다. 확인 응답 번호(Acknowledgement Number)를 보면 다음으로 받길 기대
하는 순서 번호가 3588415413임을 알 수 있습니다. 이는 ➊의 세그먼트를 통해 받은 순서 번호인
3588415412에 1이 더해진 숫자입니다. 또한 쓰리 웨이 핸드셰이크의 두 번째 과정에 맞게 플래그
(Flags)의 SYN 비트와 ACK 비트가 1로 설정되어 있는 것도 확인할 수 있습니다

➌ ACK 세그먼트 전송
다음은 쓰리 웨이 핸드셰이크의 마지막 과정으로, ➋의 두 번째 세그먼트에 대한 ACK 세그먼트입
니다. 두 번째 세그먼트의 확인 응답 번호(다음으로 받길 기대하는 순서 번호)가 3588415413이었
기 때문에 순서 번호가 3588415413이고, 두 번째 패킷의 순서 번호가 697411256이었기 때문에
확인 응답 번호가 697411257입니다. 플래그(Flags)의 ACK 비트가 1로 설정되어 있다는 것도 볼
수 있습니다. 이렇게 마지막 세그먼트까지 올바르게 수신되면 TCP 연결이 수립됩니다

지금까지의 과정을 그림으로 표현하면 다음과 같습니다. 그림을 통해 어떻게 TCP 연결 수립이 이루
어지는지, 순서 번호와 확인 응답 번호 필드에는 어떤 값들이 명시되는지 확인해 봅시다.

TCP의 오류·흐름·혼잡 제어
TCP는 송수신하는 패킷의 신뢰성을 보장하기 위해 크게 3가지 기능을 제공합니다. 각각 오류 제어
와 흐름 제어, 혼잡 제어입니다. TCP는 재전송을 기반으로 다양한 오류를 제어하고, 송수신의 흐름
을 제어해 처리할 수 있을 만큼의 데이터만을 주고받으며, 혼잡 제어를 통해 네트워크의 혼잡 정도
에 따라 데이터의 전송량을 조절합니다. 각각의 기능에 대해 좀 더 자세히 알아보겠습니다.
➊ 재전송을 통한 오류 제어
TCP는 송수신 과정에서 잘못 전송된 세그먼트가 있을 경우, 이를 재전송하여 오류를 제어합니다. 그
렇다면 TCP는 ‘언제 잘못 전송된 세그먼트가 있음’을 인지할까요? 여기에는 크게 2가지 상황이 있
습니다. 하나는 중복된 ACK 세그먼트가 도착했을 때이고, 다른 하나는 타임아웃이 발생했을 때입
니다.
TCP의 송수신은 기본적으로 (제시된 그림처럼)순서 번호를 담은 세그먼트를 보내고, 그에 대한 확
인 응답이 담긴 세그먼트를 받고, 다음 순서 번호를 담은 세그먼트를 보내고, 다시 그에 대한 확인
응답이 담긴 세그먼트를 받고, 다시 보내고 받는 과정을 반복하며 이루어집니다. 이때 ‘중복된 ACK
세그먼트를 수신’하는 상황이란 다음 그림과 같이 송신한 세그먼트의 일부가 전송 중 유실되어 중복
으로 ACK 세그먼트를 수신하게 되는 상황을 말합니다

그렇다면 타임아웃이 발생한 상황이란 무엇일까요? TCP 세그먼트를 송신하는 호스트는 모두 재전
송 타이머retransmission timer라는 특별한 값을 유지하는데, 호스트는 세그먼트를 전송할 때마다 이 재전송
타이머를 시작합니다. 이 타이머의 카운트다운이 끝난 상황을 타임아웃timeout이라고 하며, 타임아웃
발생 시점까지 ACK 세그먼트를 받지 못하면 세그먼트 전송 과정에 문제가 발생했다고 간주하여 세
그먼트를 재전송합니다.

파이프라이닝 전송
TCP의 송수신은 ‘기본적으로’ 순서 번호를 담은 세그먼트를 보내고, 그에 대한 확인 응답을 담은 세그먼트를
받고, 다음 순서번호를 담은 세그먼트를 보내고, 그에 대한 확인 응답을 담은 세그먼트를 받고, 보내고 받는 일
련의 과정을 반복하며 이루어진다고 설명했습니다. 이는 TCP의 기본적인 송수신 양상입니다. 다만, 이러한 방
식에는 단점이 있습니다. 한 번에 여러 세그먼트를 보낼 수 있는 상황에서도 확인 응답을 받기 전까지는 보낼
수 없다는 점입니다. 다시 말해, 한 번에 하나의 세그먼트만 주고받아야 하는 비효율이 있습니다.
한 번에 여러 세그먼트를 보낼 수 있다면 한 번에 송신하고 한 번에 각 세그먼트에 대한 확인 응답을 받는 것
이 더 효율적이겠죠. 그래서 오늘날의 TCP는 다음 그림과 같이 확인 응답을 받기 전이라도 여러 메시지를 보
내는 방식으로 송신하며, 이를 파이프라이닝(pipelining) 전송이라고 부릅니다(2장에서 학습한 명령어 파이
프라이닝과는 관련이 없습니다).

➋ 흐름 제어

수신 호스트가 한 번에 n개의 바이트를 받아서 처리할 수 있다면 송신 호스트는 (n 바이트 이상을
보낼 수 있어도)n개의 바이트를 넘지 않는 선에서 송신해야 합니다. TCP의 흐름 제어flow control는 이
처럼 수신 호스트가 한 번에 받아 처리할 수 있을 만큼만 전송하는 것을 의미합니다. 즉, 흐름 제어
는 송신 호스트가 수신 호스트의 처리 속도를 고려하며 송수신 속도를 균일하게 맞추는 기능입니다.
NOTE 수신 호스트가 한 번에 받을 수 있는 전송량은 TCP 수신 버퍼의 크기에 의해 결정됩니다. 수신 버퍼는 수신된
세그먼트가 애플리케이션 프로세스에 의해 읽히기 전에 임시 저장되는 공간으로, 커널에 정의되어 있습니다.
그렇다면 송신 호스트는 수신 호스트가 한 번에 처리할 수 있는 양을 어떻게 알고 보내줄 수 있을까
요? 352쪽 TCP 헤더를 보면 윈도우(window)라는 필드를 볼 수 있습니다. 이 윈도우 필드에는
수신 호스트가 한 번에 처리할 수 있는 수신 윈도우receiver window 크기가 명시됩니다. 수신 호스트는 윈
도우 필드를 통해 송신 호스트에게 한 번에 처리 가능한 양을 알려 주고, 송신 호스트는 전달받은 해
당 값을 토대로 세그먼트를 전송합니다.
➌ 혼잡 제어
혼잡congestion이란 많은 트래픽으로 인해 패킷의 처리 속도가 느려지거나 유실될 수 있는 상황을 의미
합니다. 사람이 많은 카페 등에서 네트워크 속도가 느려지는 혼잡 상황을 경험해 본 적이 있을 것입니다. 혼잡 제어congestion conrol는 바로 이러한 혼잡을 제어하기 위한 기능입니다. 흐름 제어의 주체가 수
신 호스트였다면 혼잡 제어의 주체는 송신 호스트입니다. 송신 호스트가 주체적으로 얼마나 네트워
크가 혼잡한지를 판단할 수 있어야 하고, 판단된 혼잡의 정도에 따라 세그먼트의 전송량을 조절할
수 있어야 하죠.
그렇다면 송신 호스트는 어떻게 네트워크의 혼잡을 판단하고, 혼잡의 정도에 맞는 데이터만큼만 송
신할 수 있을까요? 네트워크 혼잡 여부를 판단하는 기준은 앞서 설명한 세그먼트의 전송 오류를 판
단하는 기준과 같습니다. 송신 호스트는 중복된 ACK 세그먼트가 도착했을 때, 그리고 타임아웃이
발생했을 때 ‘현재 네트워크가 혼잡할 수 있다’고 판단하게 됩니다.
네트워크의 혼잡 가능성을 검출한 송신 호스트는 전송할 수 있는 최대 전송량을 송신하는 것이 아니
라 ‘혼잡 없이 전송할 수 있을 정도의 양’만큼만 송신하게 됩니다. 이 ‘혼잡 없이 전송할 수 있을 정도
의 양’의 값을 혼잡 윈도우congestion window라고 합니다. 혼잡 윈도우가 크면 한 번에 전송할 수 있는 세그
먼트의 수가 많음을 의미하고, 반대로 혼잡 윈도우가 작으면 네트워크가 혼잡한 상황이므로 한 번에
전송할 수 있는 세그먼트의 수가 적음을 의미합니다. TCP의 혼잡 제어를 수행하는 호스트는 각자
혼잡 윈도우 값을 고려하며, 혼잡 윈도우의 값을 넘지 않는 선에서 전송하게 됩니다.
참고로, 흐름 제어에서 사용되는 수신 윈도우와 혼잡 제어에서 사용되는 혼잡 윈도우는 모두 커
널 내에 정의된 값입니다. 다음은 리눅스 커널의 소스 코드의 일부인데요. RWND(Receiver
WiNDow, 수신 윈도우)와 CWND(Congestion WiNDow, 혼잡 윈도우)가 변수 형태로 정의
되어 있는 것을 볼 수 있습니다.

송신 호스트의 입장에서 생각해 봅시다. 수신 윈도우의 크기는 수신 호스트가 TCP 헤더로 알려 주
기 때문에 송신 호스트는 수신 윈도우의 크기를 따로 고민할 필요가 없습니다. 하지만 혼잡 윈도우
의 크기는 송신 호스트가 직접 계산하여 알아내야 합니다. 혼잡 윈도우의 크기는 어느 정도가 적당
할까요? 혼잡 윈도우 크기를 연산하는 방법, 즉 혼잡 제어를 수행하는 일련의 과정을 혼잡 제어 알고
리즘congestion control algorithm이라고 합니다.
혼잡 제어 알고리즘에는 다양한 방법들이 있지만, 가장 기본적인 혼잡 제어 알고리즘으로는 AIMD
가 있습니다. AIMDAdditive Increase/Multiplicative Decrease를 번역하면 ‘합으로 증가, 곱으로 감소’라는 의미인데
요. AIMD는 세그먼트를 보내고, 그에 대한 응답이 오기까지 혼잡이 감지되지 않으면 혼잡 윈도우
를 1씩 선형적으로 증가시키고, 혼잡이 감지되면 혼잡 윈도우를 절반으로 떨어뜨리는 동작을 반복
하는 알고리즘을 말합니다. 그래서 AIMD의 혼잡 윈도우는 다음과 같은 톱니 모양으로 변화한다는
특징이 있습니다.
참고로, 패킷을 보내고 그에 대한 응답이 수신되기까지의 시간을 RTTRound Trip Time라고 합니다. 따라
서 AIMD는 ‘혼잡이 감지되지 않으면 혼잡 윈도우를 RTT마다 1씩 선형적으로 증가시키고, 혼잡이
감지되면 혼잡 윈도우를 절반으로 떨어뜨리는 알고리즘’이라고 정의할 수도 있습니다. RTT는 TCP
뿐만 아니라 네트워크 분야 전반에서 자주 언급되는 용어이므로 기억해 두는 것이 좋습니다.

TCP의 종료
TCP의 연결 종료는 송수신 호스트가 각자 한 번씩 FIN과 ACK를 주고받으며 이루어집니다. 가령
호스트 A가 호스트 B에게 처음 연결 종료 요청을 보낸다고 가정했을 때 TCP의 연결은 다음과 같은
단계를 거쳐 종료됩니다.
➊ [송수신 방향 A → B] FIN 세그먼트
호스트 A는 FIN 비트가 1로 설정된 FIN 세그먼트를 호스트 B에게 전송합니다.
➋ [송수신 방향 B → A] ACK 세그먼트
➊에 대한 호스트 B의 응답입니다. 호스트 B는 ACK 세그먼트를 호스트 A에게 전송합니다.
➌ [송수신 방향 B → A] FIN 세그먼트
호스트 B는 FIN 세그먼트를 호스트 A에게 전송합니다.
➍ [송수신 방향 A → B] ACK 세그먼트
➌에 대한 호스트 A의 응답입니다. 호스트 A는 ACK 세그먼트를 호스트 B에게 전송합니다.
앞서 TCP 연결 수립 과정에서 먼저 연결 요청을 보낸 호스트의 동작을 액티브 오픈, 연결 요청을 받
아들이는 호스트의 동작을 패시브 오픈이라고 배웠습니다. 이와 유사하게 TCP의 연결 종료 과정에
는 액티브 클로즈와 패시브 클로즈가 있습니다. 액티브 클로즈active close란 먼저 연결을 종료하려는 호
스트에 의해 수행되는 동작을 의미합니다. 제시된 예시에서 먼저 연결 종료를 요청한 호스트는 A이
므로 호스트 A에 의해 액티브 클로즈가 수행되었다고 할 수 있습니다. 반대로, 패시브 클로즈passive
close는 예시의 호스트 B와 같이 연결 종료 요청을 받아들이는 호스트에 의해 수행되는 동작을 말합
니다.

TCP의 상태 관리
TCP의 또 다른 중요한 특징은 상태를 유지한다는 점입니다. TCP는 상태를 유지하고 관리하는 프
로토콜이라는 점에서 스테이트풀 프로토콜stateful protocol이라고도 부르는데요. 여기서 상태state란 현재 어
떤 통신 과정에 있는지를 나타내는 정보를 말합니다. TCP의 상태는 각종 네트워크 명령어에서 심심
찮게 찾아볼 수 있습니다. TCP의 상태 정보를 토대로 현재 TCP 송수신 현황을 판단할 수 있고, 디
버깅의 힌트로도 활용할 수 있습니다

TCP에는 다양한 상태가 존재하고, 호스트는 TCP를 통한 송수신 과정에서 다음과 같이 다양한 상
태를 오가게 됩니다.
처음부터 TCP의 모든 상태를 기억하기는 어렵지만, 다음과 같은 항목화를 통해 한결 수월하게 정리
할 수 있습니다.
➊ 연결이 수립되지 않았을 때 주로 활용되는 상태
➋ 연결 수립 과정에서 주로 활용되는 상태
➌ 연결 종료 과정에서 주로 활용되는 상태  
➊ 연결이 수립되지 않았을 때는 주로 다음과 같은 CLOSED와 LISTEN 상태가 활용됩니다.

➊ 연결이 수립되지 않았을 때는 주로 다음과 같은 CLOSED와 LISTEN 상태가 활용됩니다
➋ 연결 수립 과정에서는 주로 다음과 같은 SYN-SENT, SYN-RECEIVED, ESTABLISHED 상
태가 활용됩니다. TCP의 연결 수립은 쓰리 웨이 핸드셰이크를 통해 이루어지므로 쓰리 웨이 핸드셰
이크를 기준으로 각 호스트가 거치는 상태를 이해해 보기 바랍니다.
마지막으로 ➌ 연결 종료 과정에서는 주로 다음과 같은 FIN-WAIT-1, CLOSE-WAIT, FIN
WAIT-2, LAST-ACK, TIME-WAIT 상태가 활용됩니다.
유의할 점은 패시브 클로즈 호스트가 마지막 ACK 세그먼트를 수신하면 CLOSED 상태가 되는 반
면, TIME-WAIT 상태에 접어든 액티브 클로즈 호스트는 일정 시간을 기다린 뒤 CLOSED 상태가
된다는 점입니다. 일정 시간을 대기하는 이유는 마지막 ACK 세그먼트가 올바르게 전송되지 않았을
수 있고, 이 경우 재전송이 필요하기 때문입니다.

CLOSING 상태
CLOSING이라는 상태도 있습니다. CLOSING은 서로가 FIN 세그먼트를 보내고 받은 뒤 각자 그에 대한
ACK 세그먼트를 보냈지만, 아직 자신의 FIN 세그먼트에 대한 ACK 세그먼트를 받지 못했을 때 접어드는 상
태입니다. 다음과 같이 양쪽이 동시에 연결 종료를 요청하고 서로의 종료 응답을 기다릴 경우에 발생하는 상태
입니다

## 면접 예상 질문

<div>
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">아이노드(i-node)에 대해 설명해보세요</strong></summary> 
        <p><strong style="color: #999;">A.</strong>아이노드는 파일의 메타데이터를 저장하는 구조체로, 파일의 위치, 크기, 권한, 생성 시간 등의 정보를 담고 있습니다. 파일 이름은 디렉터리 엔트리에 저장되고, 실제 내용은 아이노드가 관리합니다.</p>
    </details>
</div>

- 프록시 서버와 CORS
  : CORS 에러일 때는?

브라우저가 CORS 정책 위반 시 서버 응답 본문을 차단하기 때문에, 자바스크립트에서는 ‘내용’을 알 수 없어요.

따라서, 일반적인 에러 처리처럼
response.status나 response.body를 읽어서 에러를 구분할 수 없습니다.

대신, 네트워크 오류(network error) 또는 CORS 에러로만 감지되죠.

Q. 그러니까, Same origin 일 때는 애초에 확인도 안할거고, cross origin일 때에는 서버에 preflight를 보내서 확인할거라는거지?

## :질문:스터디에서 논의하고 싶은 질문

- RB 트리, 얼마나 알고 있어야할까요?

## :링크: 참고 자료

- [CS 정리 블로그](https://example.com)
