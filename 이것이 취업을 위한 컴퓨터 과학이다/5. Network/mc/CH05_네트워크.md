# CH05. 네트워크

## 목차

- [1. 네트워크의 큰 그림](#1-네트워크의-큰-그림)
- [2. 물리 계층과 데이터 링크 계층](#2-물리-계층과-데이터-링크-계층)
- [3. 네트워크 계층 - IP](#3-네트워크-계층---ip)
- [4. 전송 계층 - TCP와 UCP](#4-전송-계층---tcp와-udp)
- []()
- []()
- []()
- [면접 예상 질문](#면접-예상-질문)

## 1. 네트워크의 큰 그림

### 네트워크(Network)

- 여러 대의 장치가 연결되어 정보를 주고받는 통신망

- 노드(네트워크 기기)와 간선(네트워크 기기 간에 정보를 주고받는 유무선의 통신 매체)으로 이루어진 그래프 형태

- `네트워크 토폴로지(network topology)`  
  : 네트워크 상에서 노드와 노드 사이의 연결 구조
  e.g.망형, 트리형, 링형

- `호스트(host)`  
  : 네트워크의 가장자리에 위치해 주고받는 정보를 최초로 송신하고 최종 수신하는 노드  
   대부분의 네트워크 기기(노트북과 구글의 서버 컴퓨터) - `클라이언트(client)` : `요청(request)`을 보내는 호스트
  - `서버(server)` : `응답(response)`을 보내는 호스트  
    노트북(클라이언트)이 구글의 서버 컴퓨터에게 웹 페이지를 가져다 달라는 요청을 보내면 구글의 서버 컴퓨터(서버)가 노트북에게 웹 페이지로 응답한다.
- 그 외 노드 : 중간 역할을 하는 스위치와 라우터, 공유기

- `프로토콜(protocol)` : 네트워크에서 통신을 주고받는 노드 간의 합의된 규칙이나 방법


### 네트워크 구분

- `LAN(Local Area Network)`  
  : 근거리 네트워크  
  공유기를 통해 네트워크 기기가 통신 => LAN이 공유기를 기준으로 구축  
  공유기와 연결된 네트워크 기기들은 `모두 같은 네트워크(LAN)에 속해 있다`고 인식

- `WAN(Wide Area Network)`  
  : LAN 간의 통신이 이루어지는 네트워크
  `ISP(Internet Service Provider)` : 인터넷 서비스 업체 e.g. KT, LG유플러스, SK브로드밴드

### 패킷 교환 네트워크

`패킷 교환 네트워크` : 패킷 단위로 주고받는 정보를 쪼개서 송수신하고 수신지에서 재조립하며 패킷을 주고받는 네트워크

`패킷(packet)` : 이렇게 네트워크를 통해 송수신되는 데이터의 단위  
`헤더(header)` : 패킷에 추가되는 부가 정보  
<p style="text-align:center;">= `페이로드(payload)` + `헤더(header)` ( + `트레일러(trailer)` )</p>  
 
### 주소의 개념과 전송 방식

`주소(address)` : 패킷의 헤더에 명시되는 정보 (`IP 주소`와 `MAC 주소`)

- 주소를 바탕으로 다양한 수신지 유형을 지정해 패킷을 전송  
  수신지를 특정 호스트 하나로 지정할 수도 있고, 네트워크 내 모든 호스트로 지정할 수도 있다.
  - `유니캐스트(unicast)` : 송신지와 수신지가 일대일 통신

  - `브로드캐스트(broadcast)` : 네트워크상의 모든 호스트에게 메시지를 전송

    `브로드캐스트 도메인(broadcast domain)` : 브로드캐스트가 전송되는 범위  

     => 호스트가 같은 브로드캐스트 도메인에 속해 있는 경우에는 같은 LAN에 속해 있다고 간주

  - `멀티캐스트(multicast)` : 네트워크 내의 동일 그룹에 속한 호스트에게만 전송
  
  - `애니캐스트(anycast)` : 네트워크 내의 동일 그룹에 속한 호스트 중 가장 가까운 호스트에게 전송


### 네트워크 참조 모델

`네트워크 참조 모델(network reference model)`  
- 통신이 이루어지는 단계를 계층적으로 표현한 모델  

- 패킷을 송신하는 쪽에서는 상위 계층에서 하위 계층으로 정보를 보내고, 패킷을 수신하는 쪽에서는 하위 계층에서 상위 계층으로 정보를 받아들이게 되는 것이죠.

### OSI 7계층과 TCP/IP 4계층 비교표

| OSI 7계층        | TCP/IP 4계층 | 설명 |
| ---------------- | ------------------ | ----------- |
| 응용 계층        | 응용 계층                | 사용자 인터페이스 및 응용 프로그램과의 상호작용 |
| 표현 계층        | ...                      | 데이터 형식, 인코딩, 암호화 등                  |
| 세션 계층        | ...                      | 세션 설정, 유지 및 종료                         |
| 전송 계층        | 전송 계층                | 종단 간 연결, 오류 제어, 흐름 제어 (TCP/UDP)    |
| 네트워크 계층    | 인터넷 계층              | 논리적 주소 지정(IP), 경로 설정                 |
| 데이터 링크 계층 | 네트워크 인터페이스 계층 | 물리적 주소(MAC), 프레임 전송, 오류 감지        |
| 물리 계층        |                          | 전기적 신호, 케이블, 커넥터 등 물리적 전송 매체 |

> `+` 참고: TCP/IP 모델은 OSI보다 간략화되어 있고, 상위 3계층(응용/표현/세션 계층)은 TCP/IP의 "응용 계층"에 통합됩니다.

`OSI Model`(7계층)

- `물리 계층(physical layer)`
    - 비트 신호(0과 1만으로 이루어진 신호)를 유무선 통신 매체를 통해 운반하는 계층  
    - 패킷의 이름 : 심볼(symbol) 또는 비트(bit)

- `데이터 링크 계층(data link layer)`  
    - 같은 LAN에 속한 호스트끼리 올바르게 정보를 주고받기 위한 계층  
    - 같은 네트워크에 속한 호스트를 식별할 수 있는 주소(MAC 주소)를 사용  
    - 물리 계층을 통해 주고받는 정보에 오류가 없는지 확인
    - 패킷의 이름 : 프레임(frame)

    => 물리 계층과 데이터 링크 계층은 서로 밀접하게 연관된 계층이며, 하드웨어와 밀접하게 맞닿아 있는 계층

- `네트워크 계층(network layer)`  
    - 네트워크 간 통신을 가능하게 하는 계층
    - 데이터 링크 계층이 기본적으로 같은 LAN에 속한 호스트끼리 올바르게 정보를 주고받기 위해 필요한 계층이라면, 네트워크 계층은 LAN을 넘어 다른 네트워크와 통신을 주고받기 위해 필요한 계층
    - => 네트워크 간 통신 과정에서 호스트를 식별할 수 있는 주소(IP 주소)가 필요하죠.
    - 패킷의 이름 : 패킷(이하 IP 패킷) 또는 데이터그램
    - 대표 프로토콜 : IP

- `전송 계층(transport layer)`
    - 신뢰성 있는 전송을 가능하게 하는 계층  
    - `포트(port)` 정보를 통해 특정 응용 프로그램과의 연결 다리 역할을 수행하는 계층  
    - 패킷의 이름 : TCP 기반(세그먼트) UDP 기반 (데이터그램)  
    - 대표 프로토콜 : TCP와 UDP

- `세션 계층(session layer)`  
    - `세션(session)`(응용 프로그램 간의 연결 상태)을 관리하기 위한 계층  
    - 응용 프로그램 간의 연결 상태를 유지하거나 새롭게 생성하고, 필요하다면 연결을 끊는다.  
    - 이 이상의 계층에서는 패킷의 이름 : 데이터 또는 메시지

- `표현 계층(presentation layer)`
  인코딩과 압축, 암호화와 같은 작업을 수행  
  => 세션 계층과 표현 계층은 다른 계층과 달리, 두 계층을 명확하게 구분하지 않거나 응용 계층에 포함하여 간주하는 경우가 많다.

- `응용 계층(application layer)`
  사용자와 가장 밀접하게 맞닿아 있어 여러 네트워크 서비스를 제공하는 계층  
  중요한 프로토콜들이 다수 포함  
   대표 프로토콜 : HTTP, HTTPS, DNS

`TCP/IP Model` (4계층)

- `네트워크 액세스 계층(network access layer)`
- 링크 계층(link layer) 또는 네트워크 인터페이스 계층(network interface layer)이라고도 부른다.
    - `인터넷 계층(internet layer)`은 OSI 모델의 네트워크 계층과 유사하며,
    - `전송 계층(transport layer)`은 OSI 모델의 전송 계층,
    - `응용 계층(application layer)`은 OSI 모델의 세션 계층, 표현 계층, 응용 계층을 합친 것과 유사

### 캡슐화와 역캡슐화

> 패킷을 송신하는 쪽에서는 상위 계층에서 하위 계층으로 정보를 보내고, 패킷을 수신하는 쪽에서는 하위 계층에서 상위 계층으로 정보를 받아들인다.

● 네트워크 계층 구조를 이용하면 프로토콜을 계층별로 구성할 수 있다.  
● 하나의 패킷은 헤더와 페이로드(때로는 트레일러까지)를 포함하며, 프로토콜의 목적과 특징에 따라 헤더의 내용은 달라질 수 있다.

각 계층에서는 어떤 정보를 송신할 때 상위 계층으로부터 내려받은 패킷을 페이로드로 삼아, 각 계층에 포함된 프로토콜의 각기 다른 목적과 특징에 따라 헤더 혹은 트레일러를 덧붙인 다음 하위 계층으로 전달한다.  
상위 계층의 패킷 == 하위 계층의 페이로드

`캡슐화(encapsulation)` : 송신 과정에서 헤더(및 트레일러)를 추가해 나가는 과정

`역캡슐화(decapsulation)` : 수신 과정에서 캡슐화 과정에서 붙인 헤더(및 트레일러)를 각 계층에서 확인한 뒤 제거하는 과정

### 네트워크 지도 그리기
(363페이지 참고)

<div style="display:flex; ">
    <div style="flex:1">
    <p>물리 계층과 데이터 링크 계층</p>
    </div>
    <div style="flex:3">
    <ul>
        <li>이더넷</li>
        <li>유무선 통신 매체</li>
        <li>이더넷 프레임</li>
        <li>다양한 네트워크 장비 (NIC, 허브, 스위치)</li>
    </ul>
    </div>
</div>

<div style="display:flex; ">
    <div style="flex:1">
    <p>네트워크 계층</p>
    </div>
    <div style="flex:3">
    <ul>
        <li>IP의 목적과 특징</li>
        <li>IP 구조(구조, 종류, 할당 방식)</li>
        <li>ICMP</li>
        <li>ARP</li>
    </ul>
    </div>
</div>

<div style="display:flex; ">
    <div style="flex:1">
    <p>전송 계층</p>
    </div>
    <div style="flex:3">
    <ul>
        <li>TCP</li>
        <li>UDP</li>
    </ul>
    </div>
</div>

<div style="height: 5px; background:white"></div>

## 2. 물리 계층과 데이터 링크 계층

### `이더넷(Ethernet)`

- LAN 내의 호스트들이 올바르게 정보를 주고받을 수 있게 해주는 기술 표준(설계도와 같은 것)

> `이더넷 표준`  
> 오늘날의 (유선)LAN 대부분이 이더넷 표준을 따르기 때문에 대다수의 LAN 장비들이 특정 이더넷 표준(IEEE 802.3)을 따른다.
> 이더넷 표준이 달라지면 통신 매체의 종류를 비롯한 신호 송수신 방법, 나아가 최대 지원 속도도 달라질 수 있다.

`이더넷 프레임(Ethernet frame)`  
이더넷 기반의 네트워크에서 주고받는 프레임 (e.g Ethernet II 프레임)
사실상 ‘프레임’이 이더넷 프레임을 지칭한다고 보아도 무방

- 이더넷 프레임의 구성 요소

  - `프리앰블(preamble)`
    송수신지 동기화를 위해 사용되는 8바이트(64비트) 크기의 정보
    수신지는 프리앰블 비트를 통해 현재의 이더넷 프레임이 수신되고 있다는 사실을 알아차리게 된다.

  - `송수신지 MAC 주소`  
    : 프레임에는 송신지와 수신지를 특정할 수 있는 6바이트(48비트) 길이의 `MAC 주소(mac address)`(네트워크 인터페이스마다 하나씩 부여되는 물리적 주소)가 명시  
    콜론(:)으로 구분된 12자리 16진수 (e.g. ab:cd:ab:cd:00:01 )

  - `네트워크 인터페이스`
    : 네트워크를 향하는 통로, 연결 매체와의 연결 지점(NIC)  
    NIC가 여러 개인 상황처럼 네트워크 인터페이스가 여럿이라면 한 호스트가 여러 개의 MAC 주소를 가질 수 있다.

  - `타입/길이(type/length) 필드`  
     필드에 명시된 크기에 따라

    - 1500 이하(16진수 05DC) = 프레임의 크기
    - 1536 이상(16진수 0600) = 타입
      <u>타입 = 캡슐화된 상위 계층의 정보</u>  
      => 타입을 통해 어떤 상위 계층 프로토콜이 캡슐화되었는지를 알 수 있다.

  - `데이터 필드`  
     페이로드(상위 계층으로 전달하거나 전달받을 데이터)

    > NOTE : `MTU`
    > ‘1500바이트’는 이더넷 프레임으로 전송 가능한 최대 데이터의 크기이자, 네트워크 계층 패킷(헤더 + 페이로드)의 최대 크기를 지칭하는 데 사용
    > 점보 프레임(jumbo frame) : 일반적인 이더넷 프레임보다 더 큰 데이터를 포함할 수 있는 프레임

  - `FCS(Frame Check Sequence)`  
     프레임의 오류가 있는지의 여부를 확인하기 위한 필드  
     `CRC(Cyclic Redundancy Check)`라는 오류 검출용 값이 명시되어 있다.

    송신지 : (전송할 데이터 + 데이터에 대한 CRC 값) 전송  
     -(전송)-> 수신지 : (전달받은 데이터의 CRC 값 과 전달받은 CRC 값대조)하여 프레임의 오류 여부 확인

### 유무선 통신 매체

호스트의 데이터 처리 + `하드웨어의 성능` 도 필요!

- 유선 매체 : `트위스티드 페어 케이블(twisted pair cable)`
<div style="display:flex; margin:10px; gap:10px">
    <img src="./assets/트위스티드 페어 케이블.png" style="width:150px">
        <ul>
            <li>구리선을 통해 전기적으로 신호를 주고받는 통신 매체 => 전기 신호에 왜곡을 줄 수 있는 <u>주변 잡음(노이즈, noise)</u>에 취약하다.</li>
            <li>`카테고리(category)` <br>트위스티드 페어 케이블의 성능을 구분하는 일종의 등급 역할을 한다. 카테고리에 따라 대응되는 주요 이더넷 표준이 다르고, 표준에 따른 최대 지원 속도도 달라질 수 있습니다.</li>
        </ul>
</div>

> NOTE
> 트위스티드 페어 케이블을 그물 모양의 철사나 포일(foil)로 감싸 노이즈를 방지  
> 구리선 주변을 보호해 노이즈를 감소시키는 방식은 차폐(shielding)라고 하며, 차폐에 사용된 그물 모양의 철사와 포일은 각각 브레이드 실드(braided shield)와 포일 실드(foil shield)
> STP(Shielded Twisted Pair) 케이블 : 브레이드 실드로 노이즈를 감소시킨 케이블
> FTP(Foil Twisted Pair) 케이블 : 포일 실드로 노이즈를 감소시킨 케이블
> UTP(Unshielded Twisted Pair) 케이블 : 아무것도 감싸지 않아 구리선만 있는 케이블

- 무선 매체 : `전파와 WiFi`
- 진동수 2.4GHz와 5GHz(와이파이를 사용할 때 주로 활용)
- `와이파이(Wi-Fi)`
- 표준 : ‘IEEE 802.11’ + 숫자 / 표준 규격에 따라 지원되는 최대 속도나 주파수 대역 등이 달라질 수 있다.
- 와이파이 뒤에 붙는 숫자로 세대를 구분, 세대에 따라 지원되는 표준 규격/최대 속도나/주파수가 달라질 수 있다.

> 같은 대역을 사용하는 서로 다른 무선 네트워크를 구분하기 위해 `채널channel`이라는 하위 주파수 대역으로 세분화되고, 해당 채널 대역에서 무선 통신이 이루어진다.

> AP와 SSID
> `AP(Access Point)` : 여러 무선 통신 기기를 연결해 무선 네트워크를 구성하는 장비(e.g. 무선 공유기)
> `서비스 셋(Service Set)` : AP를 중심으로 구성된 무선 네트워크
> `SSID(Service Set Identifier)` : 서비스 셋을 식별하는 정보(서비스 셋 식별자)

### 네트워크 인터페이스와 NIC

`네트워크 인터페이스(network interface)`

- 네트워크 상에서 노드와 통신 매체가 연결되는 지점, 노드와 네트워크 사이의 통로
- 네트워크 인터페이스마다 물리적 주소라고 불리는 MAC 주소가 부여된다.

`NIC(Network Interface Controller)`

- 통신 매체의 신호를 호스트가 이해하는 프레임으로 변환하거나 호스트가 이해하는 프레임을 통신 매체의 신호로 변환하거나, MAC 주소를 토대로 잘못 전송된 패킷이 없는지 확인하는 역할을 한다.
- NIC를 작동시키는 시스템 콜 존재  
  대부분 DMA도 지원

> NOTE : `티밍(teaming) 혹은 본딩(bonding)`

### 허브와 스위치

둘 다 네트워크 장비(하드웨어), 허브와 스위치는 물리 계층과 데이터 링크 계층의 중간 노드이다.

| 항목                | 허브(Hub)                                                      | 스위치(Switch)                                                    |
| ------------------- | -------------------------------------------------------------- | ----------------------------------------------------------------- |
| 계층                | 물리 계층 (Layer 1)                                            | 데이터 링크 계층 (Layer 2, 일반적으로 L2 스위치 의미)             |
| 통신 방식           | 반이중 통신 (Half Duplex)<br>동시 송수신 불가능<br>e.g. 무전기 | 전이중 (Full Duplex)<br>동시 송수신 가능<br>e.g. 전화기           |
| 데이터 전달 방식    | 수신한 신호를 모든 포트로 브로드캐스트                         | 수신한 프레임의 목적지 포트로만 유니캐스트 전달                   |
| 충돌 도메인         | 전체 허브가 하나의 충돌 도메인                                 | 각 포트가 별도의 충돌 도메인                                      |
| 브로드캐스트 도메인 | 전체 허브가 하나의 브로드캐스트 도메인                         | 기본적으로 전체가 하나의 브로드캐스트 도메인 (VLAN으로 분리 가능) |
| MAC 주소 처리       | MAC 주소 인식 불가                                             | MAC 주소 학습 및 MAC 주소 테이블 저장 가능                        |
| 사용 현황           | 현재는 거의 사용하지 않음                                      | 현재 네트워크에서 표준적으로 사용                                 |
| 주요 용도           | 단순 신호 증폭 및 분배 (리피터 역할)                           | 지능적인 데이터 전송 및 분할된 네트워크 구성                      |
| VLAN 기능           | 지원하지 않음                                                  | VLAN 구성 가능 (논리적으로 네트워크 분리)                         |
| 추가 설명           |                                                                |                                                                   |

`허브`

- 물리 계층의 대표적인 네트워크 장비로, 여러 대의 호스트를 연결하는 장치

`포트(port)` : 허브에서 케이블의 커넥터가 꽂히는 부분, 통신 매체를 연결하는 지점

- 특징

  1. 보로드캐스트(전달받은 신호를 모든 포트로 내보낸다)
     허브는 신호를 전달받으면 해당 신호에 대한 어떠한 조작이나 판단도 하지 않고, 모든 포트에 단순하게 신호를 내보낸다.

  2. 반이중 통신
     `반이중 통신` : `반이중(half duplex) 모드`로 송수신하는 것  
     = 송신 또는 수신을 번갈아 가면서 수행해야 하는 통신 방식  
     = 동시 송수신이 불가능한 상태  
     e.g. 무전기와 같이 어느 한 쪽이 송신할 때 다른 쪽은 송신이 불가능

  허브는 반이중 모드로 통신 == 어느 한 호스트가 허브를 향해 정보를 전달하면 다른 호스트는 정보를 전송할 수 없다.  
   `콜리전(충돌) 도메인(collision domain)` : 충돌(허브를 향해 동시에 메시지를 보냈을 때 발생하는 문제)이 발생할 수 있는 영역

`스위치(switch)`

- 허브의 한계를 보완하기 위한 네트워크 장비
- 특징

  1. 유니 캐스트  
     `MAC 주소 학습(MAC address learning) 기능`을 통해 전달받은 신호를 목적지 호스트가 연결된 포트로만 내보낸다.
     - 프레임 헤더에 명시된 MAC 주소를 이해하고, 이를 토대로 현재 어떤 포트에 어떤 MAC 주소를 가진 호스트가 연결되어 있는지 파악하고, ‘포트, 연결된 호스트의 MAC 주소’의 대응 관계를 `MAC 주소 테이블(MAC address table)`에 저장하고 참조한다.
  2. 전이중 모드  
     전이중 모드를 지원해 동시 송수신이 가능하여 콜리전 도메인이 좁다.

- 데이터 링크 계층의 상위 계층에서도 사용되는 스위치가 있다.(L2 스위치, L3 스위치 ...)

`VLAN(Virtual LAN)`

- 가상(Virtual)의 LAN
- 같은 스위치에 연결된 모든 호스트를 하나의 네트워크로 간주하지 않고 여러 논리적인 네트워크로 나누고 싶을 때 사용된다.
- 서로 다른 VLAN에 속해 있으므로 서로 다른 네트워크로 간주되며, 브로드캐스트 도메인도 겹치지 않아 브로드캐스트 메시지가 서로에게 도달하지 않는다. 서로 통신을 주고받으려면 네트워크 계층 이상의 장비가 필요하다.

<div style="height: 5px; background:white"></div>

## 3. 네트워크 계층 - IP

> 같은 IP 대역 + 같은 서브넷 마스크 → LAN 내부 통신 (스위치 기반, 라우터 불필요)
> 같은 IP 대역이라도 VLAN이 다르면 → LAN 간 통신 (라우터 필요)
> 서로 다른 IP 대역 → 네트워크 간 통신 (라우터 필요)

### IP의 목적과 특징

> `IP 패킷` : IP 주소 정보를 담고, 네트워크 계층에서 전송되는 데이터 단위

`주소 지정(addressing)`

- 네트워크 간의 통신 과정에서 IP 주소를 통해 호스트를 특정하는 것,

- IP 패킷의 필드 요소

  1. 송신지 IP 주소/수신지 IP 주소

     - 4바이트의 점으로 구분된 10진수 4개(e.g. 0.0.0.0 ~ 255.255.255.255)
     - `옥텟(octet)` : 점으로 구분된 하나의 10진수  
        e.g. ‘192.168.0.1’ => 옥탯은 ‘192’, ‘168’, ‘0’, ‘1’

     - `라우터(router)` : IP 주소를 기반으로 IP 패킷의 최적 경로를 결정하여 목적지까지 전달(`라우팅(routing)`)하는 네트워크 장비 e.g. 공유기

     - `IPv4`와 `IPv6`  
        `IPv4 주소`는 총 4바이트(32비트)로 고갈될 여지가 있음.  
        => `IPv6 주소`는 16바이트(128비트)로 주소를 표현하여 할당 가능한 IPv6 주소는 2^128개, 콜론(:)으로 구분된 8개 그룹의 16진수로 표기

       > IPv4 주소 : 192.168.1.1  
       > IPv6 주소 : 2001:0230:abcd:ffff:0000:0000:ffff:1111

  2. 단편화와 관련된 필드

     > - `단편화(fragmentation)` : 데이터를 여러 IP 패킷으로 올바르게 쪼개어 보내는 것

     > - `MTU(최대 전송 단위, Maximum Transmission Unit)`  
     >   => 전송하고자 하는 IP 패킷(IP 헤더와 페이로드)의 크기가 MTU라는 단위보다 클 경우에는 패킷을 MTU 이하의 여러 패킷으로 쪼개서 전송하고, 이렇게 쪼개서 전송된 패킷들은 수신지에서 재조합된다.
     > - 일반적인 MTU 크기는 1500바이트

     - IP 패킷 헤더에서 단편화와 관련된 필드

       - `식별자(identifier)` : 특정 패킷이 어떤 데이터에서 쪼개진 패킷인지를 식별하기 위해 사용되는 필드  
         같은 식별자 = 같은 정보에서 쪼개진 패킷

       - `플래그(flag)`: 3비트로 구성된 필드 [0 / DF / MF]  
          DF(‘IP 단편화를 수행하지 말라(Don’t Fragment)’)  
          MF(‘단편화된 패킷이 더 있다(More Fragment)’)

       - `단편화 오프셋(fragment offset)`: 특정 패킷이 초기 데이터에서 얼마나 떨어져 있는지가 명시된 필드 단편화되어 전송되는 패킷을 목적지에서 재조합하기 위해 패킷의 올바른 순서를 나타내는 데 사용된다.

       - 특징 : ‘신뢰할 수 없는 통신’과 ‘비연결형 통신’

신뢰할 수 없는 통신과 비연결형 통신

- `신뢰할 수 없는 프로토콜(unreliable protocol)`  
  : 패킷이 수신지까지 제대로 전송되었다고 보장하지 않는 프로토콜
  패킷이 유실되거나 목적지에 순서대로 전송되지 않더라도 이에 대한 조치를 취하지 않는다.
  신뢰할 수 없는 통신 = 신뢰성이 낮은 통신 = `최선형 전달(best effort delivery)`

- `비연결형 프로토콜(connectionless protocol)`  
  : 패킷을 주고받기 전에 사전 연결 과정을 거치지 않는다는 것
  상대 호스트의 수신 가능 여부는 고려하지 않고 수신지를 향해 패킷을 전송

> 잦은 IP 단편화는 네트워크에 여러 악영향을 미칠 수 있습니다.
> 단편화된 패킷들이 많아지면 전송해야 할 패킷의 헤더들이 많아지기 때문에 **불필요한 트래픽 증가와 대역폭 낭비**를 초래하고, 단편화된 패킷을 재조립하는 과정에서 발생하는 부하도 성능 저하로 이어질 수 있다.
> IP 단편화를 피하려면 IP 패킷을 주고받는 경로에 존재하는 모든 호스트의 ‘처리 가능한 MTU 크기’를 고려해야 합니다.
> `경로 MTU(Path MTU)` : ‘IP 단편화 없이 주고받을 수 있는 최대 크기’
> `경로 MTU 발견(Path MTU discovery)` : 경로 MTU를 구하고 해당 크기만큼만 송수신하여 IP 단편화를 회피하는 기술

### IP 주소의 구조

- `IP 주소` = `네트워크 주소` + `호스트 주소`

  `네트워크 주소`  
   : 호스트가 속한 네트워크를 특정하기 위해 사용(= 네트워크 ID, 네트워크 식별자(network identifier))

  `호스트 주소`  
   : 네트워크에 속한 호스트를 특정하기 위해 사용(= 호스트 ID, 호스트 식별자(host identifier))

`클래스풀 주소 체계(classful addressing)`

- 클래스를 바탕으로 IP 주소를 관리하는 주소 체계  
  하나의 IP 주소에서 네트워크 주소를 표현하는 크기와 호스트를 표현하는 크기가 유동적일 수 있다!

- `IP 주소의 클래스(class)` : 네트워크의 크기에 따라 유형별로 IP 주소를 분류하는 기준

  > (이 중 D와 E 클래스는 각각 멀티캐스트를 위한 클래스로, 특수한 목적을 위해 예약된 클래스)

  첫 옥텟의 주소만 보고도 A, B, C 클래스 중 어떤 클래스에 속한 IP 주소인지를 알 수 있습니다

  - `A 클래스`: 0.0.0.0 ~ 127.255.255.255 => 8비트 중에서 앞이 "0"으로 시작

    비트 ‘0’으로 시작 / 네트워크 : 1옥텟 / 호스트 주소 : 3옥텟

  - `B 클래스`: 128.0.0.0 ~ 191.255.255.255 => 8비트 중에서 앞으 "10'으로 시작

    비트 ‘10’으로 시작 / 네트워크 : 2옥텟 / 호스트 주소 : 2옥텟

  - `C 클래스`: 192.0.0.0 ~ 223.255.255.255 => "8비트 중에서 앞이 110"으로 시작 (192 ~ 223)

    비트 ‘110’으로 시작 / 네트워크 : 3옥텟 / 호스트 주소 : 1옥텟

> NOTE **Q. 네트워크/브로드캐스트 주소와 예약 주소호스트의 주소 공간을 모두 사용할 수 있을까?**  
> A. NO!!  
> `호스트 주소가 전부 0인 IP 주소`와 `호스트 주소가 전부 1인 IP 주소`는 특정 호스트를 지칭하는 데 사용될 수 없다.
> `호스트 주소가 전부 0인 IP 주소` : 네트워크 자체를 의미하는 주소로 사용 (e.g. 172.16.0.0)  
> `호스트 주소가 전부 1인 IP 주소` : 브로드캐스트를 위한 주소로 사용 (e.g. 172.16.255.255)  
> `+` 특수한 목적을 위해 예약된 IP 주소도 있다.  
> e.g. `루프백 주소(loopback address)` : 자기 자신을 가리키는 특별한 주소(로컬호스트)

### 클래스리스 주소 체계와 서브넷 마스크

`클래스리스 주소 체계(classless addressing)`

- 클래스를 이용하지 않고(classless) `서브넷 마스크`를 이용하여 네트워크와 호스트를 구분하는 방식
- `서브넷 마스크(subnet mask)` : IP 주소상에서 네트워크 주소를 1로 표기하고, 호스트 주소를 0으로 표기한 비트열
- `서브네트워크(서브넷, subnetwork)` : IP 주소에서 네트워크 주소로 구분할 수 있는 네트워크의 부분집합  
   서브넷 마스크 = 곧 서브넷을 구분(마스크mask)하는 비트열

- `서브네팅(subnetting)` : 서브넷 마스크를 이용해 원하는 크기로 클래스를 더 잘게 쪼개어 사용

  > 서브넷 마스크 표기법 - `CIDR 표기법(Classless Inter-Domain Routing notation)`  
  > 서브넷 마스크를 10진수가 아닌 ‘IP 주소/서브넷 마스크상의 1의 개수’의 형식으로 표기  
  > e.g.  
  > `192.168.20.3/30` > `/30`  
  > = 서브넷 마스크 상에서 1이 30개  
  > = ‘11111111.11111111.11111111.11111100’  
  > = ‘255.255.255.252’

### 공인 IP 주소와 사설 IP 주소

**Q. `IP 주소는 유일하고 고유한 주소?`**  
**A.** 고유한 IP 주소도 있고, 고유하지 않은 IP 주소도 있다. 그리고 이 두 종류의 IP 주소는 함께 사용되는 경우가 많다.

` 공인 IP 주소(public IP address)`

- 전 세계에서 고유한 IP 주소로, 인터넷을 비롯한 네트워크 간 통신에서 사용되는 IP 주소
- 호스트가 속한 네트워크 밖에서 사용하는 주소로 ISP나 공인 IP 주소 할당 기관을 통해 할당받을 수 있다.

`사설 IP 주소(private IP address)`

- 사설 네트워크(외부 네트워크에 공개되지 않은)에서 사용하기 위한 IP 주소
- 일반적으로 라우터(공유기)를 통해 할당되기 때문에 공유기(라우터)를 중심으로 구성된 LAN 대부분은 사설 네트워크에 해당한다.
- IP 주소 공간 중에서 사설 IP 주소로 사용하도록 특별히 예약된 IP 주소 공간이 있다.
- 중복될 수 있다.

### IP 주소의 할당

`정적 할당`

- 직접 수작업으로 IP 주소를 부여하는 방식
- `정적 IP 주소(static IP address)` : 정적 할당을 통해 할당된 IP 주소
- `게이트웨이(gateway)` : 서로 다른 네트워크를 연결하는 하드웨어적/소프트웨어적 수단  
  `기본 게이트웨이(default gateway)`는 호스트가 속한 네트워크의 외부로 나가기 위한 첫 기본 경로  
  => 기본 게이트웨이 = 네트워크 외부와 연결된 라우터(공유기)의 주소를 의미하는 경우가 많다.

> IP 할당의 맥락에서 사용되는 ‘게이트웨이’라는 용어는 기본 게이트웨이를 의미

- `DNS 주소`는 호스트가 도메인 네임을 토대로 IP 주소를 알아내기 위해 질의하는 서버의 주소.
  `도메인 네임` :IP 주소에 대응되는 기억할 수 있는 호스트를 식별할 수 있는 문자열 e.g. ‘google.com, hanbit.co.kr, minchul.net’
  호스트가 DNS 서버에 질의하여 도메인 네임에 대응되는 IP 주소를 알아낸다.
  `DNS 서버` : <도메인 네임, IP 주소> 쌍을 저장하는 서버

`동적 할당`

- 프로토콜을 통해 자동으로 IP 주소를 부여하는 방식
- `동적 IP 주소(dynamic IP address)` : 동적 할당을 통해 할당된 IP 주소
- 대표 프로토콜 : `DHCP(Dynamic Host Configuration Protocol)`  
  : DHCP 서버와 메시지를 주고받으며 동적 IP 주소를 할당받을 수 있다.
  `DHCP 서버` : 호스트에 할당 가능한 IP 주소 목록을 관리하다가, IP 주소 할당 요청을 받았을 때 IP 주소를 할당해 주는 호스트 , 일반적으로 라우터(공유기)가 DHCP 서버 역할을 수행한다.

1. 동적 IP 주소에는 사용 가능한 기간(임대 기간)이 정해져 있다. (‘IP 주소의 임대’)  
   `임대 갱신l(ease renewal)`도 가능
2. 동적 IP 주소는 할당받을 때마다 다른 주소를 받을 수 있다.
   => 컴퓨터의 진짜 정보를 보내는 게 아니라, 공유기가 동적으로 할당

| 유형                     | 설명                                                    | 사용 예시                            |
| ------------------------ | ------------------------------------------------------- | ------------------------------------ |
| **정적 IP (Static IP)**  | 고정된 IP 주소. 변경되지 않음.                          | 서버(웹사이트 운영, 프린터, CCTV 등) |
| **동적 IP (Dynamic IP)** | DHCP 서버가 자동으로 할당. 일정 시간 후 변경될 수 있음. | 일반 가정용 컴퓨터, 스마트폰 등      |

### IP 전송 특징의 보완: ICMP

IP : 신뢰할 수 없는 프로토콜이자, 비연결형 프로토콜 => 빠른 송수신 가능
신뢰성 + 연결형 통신이 필요하다면?

1. 신뢰할 수 있는 연결형 통신을 지원하는 상위 계층의 프로토콜을 이용하기
   TCP를 통해 패킷을 송수신하면 신뢰성과 연결형 통신을 보장할 수 있다.

2. `ICMP(Internet Control Message Protocol)`

- IP 패킷의 전송 과정에 대한 피드백 메시지(이하 ICMP 메시지)를 얻기 위해 사용하는 프로토콜  
  ICMP 메시지를 통해 패킷이 상대방에게 어떻게 전송되었는지를 알려줄 수 있어 IP 전송의 결과를 엿볼 수 있다.
  e.g.  
  [네트워크 도달 불가]: 패킷의 발신지\*수신지를 모를 경우  
  [단편화가 필요하지만 DF가 1로 설정되어 단편화할 수 없음] 처리하기에 너무 큰 패킷을 전달받았는데, DF 플래그가 설정되어 있어 단편화가 불가능할 경우  
  [시간 초과(Time Exceeded)] 패킷은 멀리 떨어진 호스트끼리 통신할 때 여러 라우터를 거쳐 이동할 수 있는데, 패킷이 하나의 라우터를 거칠 때(`홉hop`)마다 `TTL(Time To Live, 패킷의 수명)`이 1씩 감소하고, TTL 필드가 0이 되면 해당 패킷은 폐기되고 전송되는 메시지.

### IP 주소와 MAC 주소의 대응: ARP

`ARP(Address Resolution Protocol)`

- IP 주소와 MAC 주소를 함께 활용하는 통신 과정에서, 동일 네트워크 내에 있는 송수신 대상의 IP 주소를 통해 MAC 주소를 알아내는 프로토콜
- 동작 과정

  1. ARP 요청

  - 브로드캐스트 메시지(네트워크 내에 있는 모든 호스트에게 보내는 메시지)
  - 알고 싶은 MAC 주소에 대응되는 IP 주소가 포함

  2. 네트워크 내 모든 호스트가 이를 수신

  - ARP 요청 메시지에 포함된 IP 주소를 확인해 자신과 관련이 없는 IP 주소일 경우에는 무시,
  - 자신의 IP 주소일 경우에는 ARP 응답 메시지(응답 메시지를 보내는 호스트의 MAC 주소가 포함) 전달

  - `ARP 테이블(ARP Table)`  
    : ARP 테이블은 < IP 주소, MAC 주소 >의 항목들로 구성된 표 형태의 정보  
    ARP 요청 메시지와 ARP 응답 메시지를 통해 알게 된 < IP 주소, MAC 주소 > 쌍은 ARP 테이블에 추가  
    ARP 테이블 항목은 일정 시간이 지나면 삭제되고, 임의로 삭제 가능

## 4. 전송 계층 - TCP와 UDP

### 포트를 통한 프로세스 식별

네트워크 통신을 통해서 전달되는 패킷을 최종적으로 송수신해야하는 대상은 호스트가 아닌 호스트의 프로세스이다.
네트워크는 IP 주소로, 호스트는 MAC 주소로, 프로세스는 `포트(port) 번호` 통해 식별할 수 있다.
‘IP 주소:포트 번호’의 조합을 통해 통해 ‘특정 호스트가 실행하는 특정 프로세스’를 식별할 수 있다.

`포트를 통한 프로세스 식별` = 전송 계층(TCP, UDP)의 주된 목적

TCP와 UDP는 모두 포트를 통해 프로세스를 식별할 수 있다.

포트 번호는 16비트(2^16)
번호의 범위에 따라 `잘 알려진 포트`, `등록된 포트`, `동적 포트`로 나뉜다.

| 구분                                 | 포트 번호 범위      | 설명                                        | 예시                                    |
| ------------------------------------ | ------------------- | ------------------------------------------- | --------------------------------------- |
| **고정 포트 (Well-Known Ports)**     | 0번부터 1023번      | 특정 서비스가 항상 사용하는 포트 번호       | HTTP: 80, HTTPS: 443, SSH: 22           |
| **등록 포트 (Registered Ports)**     | 1024번부터 49151번  | 특정 앱이나 서비스가 등록해 사용하는 포트   | Docker: 2375, MySQL: 3306               |
| **동적/임시 포트 (Ephemeral Ports)** | 49152번부터 65535번 | 클라이언트가 통신할 때 임시로 사용하는 포트 | 브라우저가 서버에 요청할 때 자동 할당됨 |

> 서버로서 동작하는 프로그램의 경우 주로 잘 알려진 포트와 등록된 포트가 할당되는 경우가 많지만, 클라이언트로서 동작하는 프로그램의 경우에는 동적 포트 번호 중에서 임의의 번호가 할당되는 경우가 많다.
> 클라이언트 프로그램이 서버에 요청할 때마다 랜덤으로 동적 포트 번호를 할당하기 때문에 다르게 할당될 수 있다.

### NAT와 NAPT

`NAT(Network Address Translation)`

- 공인 IP 주소(네트워크 외부)와 사설 IP 주소(네트워크 내부)간 변환을 위해 사용하는 기술  
   네트워크 내부의 호스트와 네트워크 외부 호스트간의 통신을 위해서는 <u>공인 IP 주소와 사설 IP 주소 간 변환</u>이 필요하다.
- 대부분의 라우터와 (가정용)공유기는 NAT 기능을 내장 => 방향에 맞추어서 IP의 변환이 이루어진다.
- 일대일로 변환 시 많은 공인 IP 주소가 필요하기 때문에 다수의 사설 IP 주소를 그보다 적은 수의 공인 IP 주소로 변환

`NAPT(Network Address Port Translation)`

- IP 주소 변환 과정에서 변환할 IP 주소의 쌍과 더불어, 포트 번호도 함께 고려하는 <u>포트 기반의 NAT</u>
  공인 IP 주소 수의 부족 문제를 개선하는 기술로도 간주되고 있습니다

### (비)신뢰성과 (비)연결형 보장

> 표현 주의! TCP는 프로토콜이므로 "TCP로" 와 같은 표현보다는 "TCP를 통해"(== TCP라는 통신 규약을 따라서)

| 항목                 | TCP (Transmission Control Protocol)    | UDP (User Datagram Protocol)         |
| -------------------- | -------------------------------------- | ------------------------------------ |
| **연결 방식**        | 연결 지향 (3-way handshake 필요)       | 비연결 지향                          |
| **신뢰성**           | 신뢰성 보장 (데이터 순서 보장, 재전송) | 신뢰성 없음 (순서 보장 X, 손실 허용) |
| **속도**             | 느림 (신뢰성 유지 위한 오버헤드)       | 빠름 (단순한 구조)                   |
| **헤더 크기**        | 20바이트 이상                          | 8바이트                              |
| **흐름 제어**        | 있음 (수신 속도에 따라 조절)           | 없음                                 |
| **혼잡 제어**        | 있음 (네트워크 상태에 따라 속도 조절)  | 없음                                 |
| **데이터 전송 방식** | 스트림 (연속적인 데이터 흐름)          | 데이터그램 (개별 패킷 전송)          |
| **패킷 순서 보장**   | 보장함                                 | 보장하지 않음                        |
| **사용 예시**        | 웹(HTTP/HTTPS), 이메일, 파일 전송 등   | 영상 스트리밍, 음성 통화, DNS 등     |
| **오버헤드**         | 큼 (많은 부가정보 포함)                | 작음 (필수 정보만 포함)              |

> 특징으로 이해하는 TCP와 UDP
> `TCP`는 신뢰할 수 있는 연결형 송수신
> => 신뢰성과 연결성을 위한 많은 정보(헤더)와 시간이 필요
> `UDP`는 신뢰할 수 없는 비연결형 송수신
> => 작업이 덜 필요하기 때문에 시간이 덜 걸린다.

<div style="font-family:monospace; font-size:10px; border:1px solid #ccc; padding:12px; background:#f9f9f9; line-height:1.8;">
  <div style="display:flex;">
    <div style="flex:1; border:1px solid #ddd; padding:6px;">
      <strong>Source Port</strong> (16bit)<br>
      <span style="color:gray;">→ 송신자 포트 번호 (어디서 왔는지)</span>
    </div>
    <div style="flex:1; border:1px solid #ddd; padding:6px;">
      <strong>Destination Port</strong> (16bit)<br>
      <span style="color:gray;">→ 수신자 포트 번호 (어디로 가는지)</span>
    </div>
  </div>
  <div style="border:1px solid #ddd; padding:6px;">
    <strong>Sequence Number</strong> (32bit)<br>
    <span style="color:gray;">→ 전송하는 데이터의 순서 지정 (정렬에 필요)</span>
  </div>
  <div style="border:1px solid #ddd; padding:6px;">
    <strong>Acknowledgment Number</strong> (32bit)<br>
    <span style="color:gray;">→ 받은 데이터에 대한 응답 번호</span>
  </div>
  <div style="display:flex;">
    <div style="flex:0.5; border:1px solid #ddd; padding:6px;">
      <strong>Data Offset</strong> (4bit)<br>
      <span style="color:gray;">→ 헤더 길이</span>
    </div>
    <div style="flex:0.5; border:1px solid #ddd; padding:6px;">
      <strong>Reserved</strong> (4bit)<br>
      <span style="color:gray;">→ 미래 확장을 위한 공간</span>
    </div>
    <div style="flex:2; border:1px solid #ddd; padding:6px;">
      <strong>Flags</strong> (8bit)<br>
      <span style="color:gray;">→ 제어 플래그 (SYN, ACK, FIN 등)</span>
    </div>
    <div style="flex:1; border:1px solid #ddd; padding:6px;">
      <strong>Window Size</strong> (16bit)<br>
      <span style="color:gray;">→ 수신 가능한 데이터 크기 (흐름 제어)</span>
    </div>
  </div>
  <div style="display:flex;">
    <div style="flex:1; border:1px solid #ddd; padding:6px;">
      <strong>Checksum</strong> (16bit)<br>
      <span style="color:gray;">→ 오류 검출용</span>
    </div>
    <div style="flex:1; border:1px solid #ddd; padding:6px;">
      <strong>Urgent Pointer</strong> (16bit)<br>
      <span style="color:gray;">→ 긴급 데이터 위치 지정 (거의 사용 안 함)</span>
    </div>
  </div>
  <div style="border:1px solid #ddd; padding:6px;">
    <strong>Options (선택)</strong><br>
    <span style="color:gray;">→ 성능 향상 기능 (예: 윈도우 크기 조정 등)</span>
  </div>
  <div style="border:1px solid #ddd; padding:6px;">
    <strong>Data (Payload)</strong><br>
    <span style="color:gray;">→ 실제 전송하려는 데이터</span>
  </div>
</div>

---

- `제어 비트(control bits, flag bits)` : 현재 세그먼트에 대한 부가 정보를 나타내는 정보
  - ACK: 세그먼트의 승인을 나타내기 위한 비트
  - SYN: 연결을 수립하기 위한 비트
  - FIN: 연결을 종료하기 위한 비트

### TCP의 연결 과정

1. `연결 수립`
   `쓰리 웨이 핸드셰이크three-way handshake` : 세 단계로 이루어진 TCP의 연결 수립 과정

e.g.

(1) [송수신 방향 A → B] SYN 세그먼트 전송
호스트 A는 SYN 비트가 1로 설정된 세그먼트(이하 SYN 세그먼트)를 호스트 B에게 전송
이때 세그먼트의 순서 번호에는 호스트 A의 순서 번호가 포함

(2) [송수신 방향 B → A] SYN + ACK 세그먼트 전송
➊에 대한 호스트 B의 응답  
호스트 B는 ACK 비트와 SYN 비트가 1로 설정된 세그먼트(이하 SYN+ACK 세그먼트)를 호스트 A에게 전송  
세그먼트의 순서 번호에는 호스트 B의 순서 번호와 ➊에서 보낸 세그먼트에 대한 확인 응답 번호가 포함

(3) [송수신 방향 A → B] ACK 세그먼트 전송
호스트 A는 ACK 비트가 1로 설정된 세그먼트(이하 ACK 세그먼트)를 호스트 B에게 전송  
세그먼트의 순서 번호에는 호스트 A의 순서 번호와 (2)에서 보낸 세그먼트에 대한 확인 응답 번호가 포함

`액티브 오픈(active open)` : 처음 연결을 시작하는 과정 (호스트 A, 주로 클라이언트)  
`패시브 오픈(passive open)` : 연결 요청을 수신한 뒤 그에 대한 연결을 수립하는 과정(호스트 B, 주로 서버)

### TCP의 세 가지 기능

1.  TCP는 재전송을 기반으로 다양한 `오류 제어`

    - 중복된 ACK 세그먼트가 도착하거나, 타임아웃이 발생했을 경우 잘못 전송된 세그먼트가 있음을 인지하고 이를 재전송하여 오류를 제어한다.
      - 중복된 ACK 세그먼트를 수신  
         TCP의 송수신은 순서 번호를 담은 세그먼트를 보내고, 그에 대한 확인 응답이 담긴 세그먼트를 받는 과정을 반복하면서 송신한 세그먼트의 일부가 전송 중 유실되어 중복으로 ACK 세그먼트를 수신하게 되는 경우
      - 타임아웃
        호스트는 세그먼트를 전송할 때마다 `RTO(Retransmission Timeout)`를 설정하고 이에 맞추어 `재전송 타이머(retransmission timer)`를 시작한다. `타임아웃(timeout)`(타이머의 카운트다운이 끝난 상황) 발생 시점까지 ACK 세그먼트를 받지 못하면 세그먼트 전송 과정에 문제가 발생했다고 간주하여 세그먼트를 재전송

    파이프라이닝 전송
    TCP의 송수신 방식은 한 번에 여러 세그먼트를 보낼 수 있는 상황에서도 확인 응답을 받기 전까지는 보낼 수 없다 = 한 번에 하나의 세그먼트만 주고받아야 한다.
    => 확인 응답을 받기 전이라도 여러 메시지를 보내는 `파이프라이닝(pipelining) 전송` 방식으로 송수신하기도 함

2.  송수신의 `흐름 제어(flow control)`

    - TCP는 수신 호스트가 한 번에 받아 처리할 수 있을 만큼만 전송한다.
    - `흐름 제어`는 송신 호스트가 수신 호스트의 처리 속도를 고려하며 송수신 속도를 균일하게 맞추는 기능
      `+` 수신 호스트가 한 번에 받을 수 있는 전송량은 <u>TCP 수신 버퍼의 크기에 의해 결정</u>된다.
      `수신 버퍼` : 수신된 세그먼트가 애플리케이션 프로세스에 의해 읽히기 전에 임시 저장되는 공간으로, 커널에 정의되어 있다.
      수신 호스트는 TCP 헤더의 윈도우(window) 필드에 명시된 `수신 윈도우(receiver window)` 크기를 통해 송신 호스트에게 한 번에 처리 가능한 양을 알려 주고, 송신 호스트는 전달받은 해당 값을 토대로 세그먼트를 전송

3.  `혼잡 제어(congestion control)`
    `혼잡` : 많은 트래픽으로 인해 패킷의 처리 속도가 느려지거나 유실될 수 있는 상황  
    e.g. 사람이 많은 카페 등에서 네트워크 속도가 느려지는 혼잡 상황
    송신 호스트가 주체적으로 얼마나 네트워크가 혼잡한지를 판단할 수 있어야 하고, 판단된 혼잡의 정도에 따라 세그먼트의 전송량을 조절할 수 있어야한다.

    송신 호스트는 중복된 ACK 세그먼트가 도착하거나 타임아웃이 발생했을 때 ‘현재 네트워크가 혼잡할 수 있다’고 판단 -> 네트워크의 혼잡 가능성을 검출한 송신 호스트는 전송할 수 있는 최대 전송량을 송신하는 것이 아니라 ‘혼잡 없이 전송할 수 있을 정도의 양’만큼만 송신
    `혼잡 윈도우(congestion window)` : 혼잡 없이 전송할 수 있을 정도의 양을 판단하는 기준
    송신 호스트는 혼잡 윈도우의 값을 넘지 않는 선에서 세그먼트를 전송

    > 수신 윈도우는 수신 호스트가 계산, 혼잡 윈도우는 송신 호스트가 계산
    > `혼잡 제어 알고리즘(congestion control algorithm)` : 혼잡 윈도우 크기를 연산하는 방법, 즉 혼잡 제어를 수행하는 일련의 과정
    > 대표 예시 : `AIMD(Additive Increase/Multiplicative Decrease)` : ‘합으로 증가, 곱으로 감소’ / AIMD는 세그먼트를 보내고, 그에 대한 응답이 오기까지 혼잡이 감지되지 않으면 혼잡 윈도우를 1씩 선형적으로 증가시키고, 혼잡이 감지되면 혼잡 윈도우를 절반으로 떨어뜨리는 동작을 반복하는 알고리즘
    > `RTT(Round Trip Time)` : 패킷을 보내고 그에 대한 응답이 수신되기까지의 시간
    > AIMD는 ‘혼잡이 감지되지 않으면 혼잡 윈도우를 RTT마다 1씩 선형적으로 증가시키고, 혼잡이 감지되면 혼잡 윈도우를 절반으로 떨어뜨리는 알고리즘’

> 흐름 제어의 주체가 수신 호스트였다면 혼잡 제어의 주체는 송신 호스트

3. TCP의 종료
   송수신 호스트가 각자 한 번씩 FIN과 ACK를 주고받으며 TCP의 연결 종료가 이루어진다.

e.g.  
➊ [송수신 방향 A → B] FIN 세그먼트
호스트 A는 FIN 비트가 1로 설정된 FIN 세그먼트를 호스트 B에게 전송

➋ [송수신 방향 B → A] ACK 세그먼트
➊에 대한 호스트 B의 응답 호스트 B는 ACK 세그먼트를 호스트 A에게 전송

➌ [송수신 방향 B → A] FIN 세그먼트
호스트 B는 FIN 세그먼트를 호스트 A에게 전송

➍ [송수신 방향 A → B] ACK 세그먼트
➌에 대한 호스트 A의 응답, 호스트 A는 ACK 세그먼트를 호스트 B에게 전송

`액티브 클로즈active close` : 먼저 연결을 종료하려는 호스트에 의해 수행되는 동작(호스트 A에 의해 액티브 클로즈가 수행)  
`패시브 클로즈passive close` : 연결 종료 요청을 받아들이는 호스트에 의해 수행되는 동작(호스트 B에 의해 패시브 클로즈 수행)

### TCP의 상태 관리

- TCP는 상태를 유지하고 관리하는 `스테이트풀 프로토콜(stateful protocol)`이다.
- `상태(state)`란 현재 어떤 통신 과정에 있는지를 나타내는 정보로, 다양한 상태를 오간다.

➊ 연결이 수립되지 않았을 때 주로 활용되는 상태 : CLOSED와 LISTEN

➋ 연결 수립 과정에서 주로 활용되는 상태 : SYN-SENT, SYN-RECEIVED, ESTABLISHED

➌ 연결 종료 과정에서 주로 활용되는 상태 : FIN-WAIT-1, CLOSE-WAIT, FINWAIT-2, LAST-ACK, TIME-WAIT

`+` CLOSING 상태
서로가 FIN 세그먼트를 보내고 받은 뒤 각자 그에 대한 ACK 세그먼트를 보냈지만, 아직 자신의 FIN 세그먼트에 대한 ACK 세그먼트를 받지 못했을 때 접어드는 상태  
e.g. 양쪽이 동시에 연결 종료를 요청하고 서로의 종료 응답을 기다릴 경우

## 면접 예상 질문

<div>
    <!-- 첫번째 질문 -->
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">IP 주소가 무엇이고, OSI 7계층 중에 어느 계층에서 사용하는지 설명해주세요.</strong></summary> 
        <p>
            <strong style="color: #999;">A.</strong>
            IP 주소는 인터넷 프로토콜(Internet Protocol) 주소의 약자로, 네트워크 상의 장치를 식별하기 위한 고유한 주소입니다. 마치 집 주소처럼, 네트워크에서 데이터의 목적지를 지정하는 데 사용됩니다. 
            IP 주소는 OSI 7계층 중 ‘3계층인 네트워크 계층(Network Layer)’에서 사용됩니다. 이 계층은 데이터를 목적지까지 전달하는 경로를 결정(라우팅)하고,  목적지 호스트를 식별하기 위해 IP 주소를 사용합니다.
        </p>
    </details>
    <!-- 두번째 질문 -->
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">TCP와 UDP의 차이점은 무엇인가요?</strong></summary> 
        <p>
            <strong style="color: #999;">A.</strong>
            TCP와 UDP는 전송 계층(OSI 4계층)의 프로토콜로, 데이터를 전송하는 방식에 따라 큰 차이점이 있습니다.
            TCP는 연결형 프로토콜로 데이터의 순서, 무결성, 신뢰성을 보장합니다. 웹(HTTP/HTTPS), 이메일(SMTP), 파일 전송(FTP) 등 정확한 전송이 중요한 서비스에 사용됩니다.
            UDP는 비연결형 프로토콜로 사전 연결 없이 데이터를 빠르게 전송합니다. 속도는 빠르지만 신뢰성은 낮습니다. 실시간 스트리밍, 온라인 게임, VoIP 등 지연보다 속도가 중요한 서비스에 사용됩니다.
        </p>
    </details>
    <!-- 세번째 질문 -->
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">TCP 송수신 중 연결은 어떻게 맺어지나요?</strong></summary> 
        <p>
            <strong style="color: #999;">A.</strong>
            TCP 연결은 3-way handshake 과정을 통해 맺어집니다. 먼저 클라이언트가 서버에 SYN 패킷을 보내 연결을 요청하고, 서버는 이를 수신한 뒤 SYN-ACK 패킷으로 응답합니다. 그 다음 클라이언트가 ACK 패킷을 보내면 연결이 성립됩니다. 이 과정을 통해 양측 모두 연결 의사를 확인하고, 초기 시퀀스 번호를 교환하여 통신을 시작하게 됩니다.
        </p>
    </details>
    <!-- 네번째 질문 -->
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">같은 공유기를 사용하는 두 컴퓨터에서 같은 포트를 사용하는 클라이언트 프로그램이 실행될 경우, 어떻게 통신이 구분되나요?</strong></summary> 
        <p>
            <strong style="color: #999;">A.</strong>
            NAPT(Network Address Port Translation)를 통해 문제없이 통신이 가능합니다. 각 컴퓨터는 서로 다른 사설 IP 주소를 가지고 있고, 공유기는 이 사설 IP와 내부 포트 번호를 자신의 공인 IP 주소 + 고유한 외부 포트 번호로 매핑하여 NAT 테이블에 기록합니다. 서버에 요청을 보낼 때는 이 공인 IP + 외부 포트 조합이 발신지로 사용되기 때문에, 같은 내부 포트를 사용하더라도 공유기 차원에서는 서로 다른 연결로 인식할 수 있습니다.
        </p>
    </details>
    <!-- 다섯번째 질문 -->
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">공유기가 내부와 외부 통신을 관리할 때 어떤 정보를 기반으로 NAT 테이블을 만드나요?</strong></summary> 
        <p>
            <strong style="color: #999;">A.</strong>
            공유기는 사설 IP 주소, 내부 포트 번호, 공인 IP, 변환된 외부 포트, 목적지 IP와 포트 등의 정보를 기반으로 NAT 테이블을 구성합니다. 이 테이블을 통해, 외부에서 응답이 도착하면 어떤 내부 장치에게 전달해야 하는지를 정확히 파악할 수 있습니다. 이러한 매핑 덕분에 다수의 장치가 동시에 동일한 외부 서버에 요청을 보내더라도 충돌 없이 응답을 받을 수 있습니다.
        </p>
    </details>
    <!-- 여섯번째 질문 -->
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">포트포워딩은 어떤 경우에 꼭 필요한가요? 소켓 통신의 경우와 비교해서 설명해주세요.</strong></summary> 
        <p>
            <strong style="color: #999;">A.</strong>
            외부에서 내부 네트워크로 먼저 접속하려고 할 때 외부에서는 공유기까지만 볼 수 있고, 공유기 뒤에 있는 컴퓨터는 직접적으로 접근할 수 없습니다. 따라서 외부에서 특정 컴퓨터로 접근하기 위해서는 공유기에 "해당 공유 IP와 포트로 통신이 오면 내가 설정한 사설 IP의 포트번호로 전달해줘"하고 설정해줘야합니다. 이러한 설정을 포트 포워딩이라고 합니다.
        </p>
    </details>
    <!-- 여섯번째 질문에서 연결되는 문제 -->
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">집에서 웹 서버를 로컬에서 실행 중인데, 외부에서 접속하려면 어떻게 해야 하나요?</strong></summary> 
        <p>
            <strong style="color: #999;">A.</strong>
            네, 내부 네트워크에서 실행 중인 웹 서버에 외부에서 접속하려면 포트 포워딩 설정이 필요합니다. 예를 들어, 제 컴퓨터의 IP가 192.168.0.5이고, 웹 서버가 3000번 포트에서 실행 중이라면, 공유기 설정 페이지에 접속해 포트 포워딩 설정을 통해 내부 장치와 포트 매핑을 정확히 지정하여야합니다.
        </p>
    </details>
    <!-- 여덟번째 질문 -->
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">WebSocket처럼 서버가 클라이언트에게 데이터를 보낼 수 있는 통신에서, 클라이언트는 사설 IP인데도 왜 포트포워딩이 필요하지 않나요?</strong></summary> 
        <p>
            <strong style="color: #999;">A.</strong>
            WebSocket은 클라이언트가 먼저 서버에 연결을 생성하면서 통신이 시작됩니다.
            이 과정에서 클라이언트의 NAT(공유기)는 서버와의 연결 정보를 NAT 테이블에 저장하게 됩니다. 이 TCP 연결이 유지되는 동안에는 서버도 해당 연결을 통해 클라이언트에게 데이터를 전송할 수 있기 때문에,별도의 포트포워딩 없이도 양방향 통신이 가능합니다. 즉, 서버가 먼저 클라이언트에 접속하는 것이 아니라,클라이언트가 먼저 연결을 열어둔 상태에서만 서버의 푸시 메시지가 가능한 구조이기 때문입니다.
        </p>
    </details>
    <!-- 아홉번째 질문 -->
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">서버에서 클라이언트에게 데이터를 "먼저" 보내는 방식과, 포트포워딩과의 관계를 설명해주세요.</strong></summary> 
        <p>
            <strong style="color: #999;">A.</strong>
            일반적으로 서버가 클라이언트에게 먼저 데이터를 보내는 것은 기존에 연결이 생성된 상태에서만 가능합니다. 예를 들어, WebSocket이나 TCP 소켓 통신에서는 클라이언트가 먼저 서버에 연결 요청을 보내고, 이로 인해 양방향 통신 가능한 TCP 연결이 생성됩니다. 이 연결을 통해 서버는 클라이언트에게 데이터를 보낼 수 있으며, 이 경우에는 포트포워딩이 필요하지 않습니다. 반면, 서버가 클라이언트에게 직접 새로운 연결을 생성해서 접근하려는 경우에는, 클라이언트가 NAT 환경에 있다면 포트포워딩이 필요합니다. 왜냐하면 외부에서 내부 네트워크로의 직접 접근은 공유기에서 어떤 장치로 보낼지 판단할 수 없기 때문입니다.
        </p>
    </details>
    <!-- 열번째 질문 -->
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">네트워크에서의 ‘캡슐화(encapsulation)’와 ‘역캡슐화(decapsulation)’에 대해 설명해주세요.</strong></summary> 
        <p>
            <strong style="color: #999;">A.</strong>
            캡슐화란 상위 계층에서 받은 데이터를 하위 계층으로 전달할 때, 각 계층이 필요한 제어 정보(헤더, 때로는 트레일러)를 붙여서 하나의 데이터 단위로 만드는 과정을 말합니다. 역캡슐화는 수신 측에서 데이터를 받을 때 각 계층이 자신에게 해당하는 헤더와 트레일러를 제거하고 원래의 데이터(페이로드)를 추출하는 과정입니다.
        </p>
    </details>
    <!-- 열한번째 질문 -->
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">패킷이란 무엇이며, 패킷 교환 네트워크의 특징은 무엇인가요?</strong></summary> 
        <p>
            <strong style="color: #999;">A.</strong>
            패킷은 네트워크에서 송수신되는 데이터 단위로, 페이로드와 헤더(때로는 트레일러)로 구성됩니다. 패킷 교환 네트워크는 데이터를 작은 패킷으로 쪼개 송수신하고, 수신지에서 재조립하는 방식으로 동작합니다.
        </p>
    </details>
    <!-- 열두번째 질문 -->
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">MAC 주소란 무엇인가요?</strong></summary> 
        <p>
            <strong style="color: #999;">A.</strong>
            MAC 주소는 네트워크 인터페이스마다 부여되는 48비트 길이의 물리적 주소로, 같은 LAN 내에서 호스트를 구분하는 데 사용됩니다.
        </p>
    </details>
    <!-- 열세번째 질문 -->
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">VLAN이란 무엇인가요?</strong></summary> 
        <p>
            <strong style="color: #999;">A.</strong>
            VLAN은 하나의 스위치에 연결된 호스트들을 논리적으로 나누어 서로 다른 네트워크처럼 구성하는 기술로, 브로드캐스트 도메인을 분리할 수 있습니다.
        </p>
    </details>
    <!-- 열네번째 질문 -->
    <details>
        <summary><strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">허브와 스위치의 차이를 설명해주세요.</strong></summary> 
        <p>
            <strong style="color: #999;">A.</strong>
            허브는 물리 계층 장비로 수신한 신호를 모든 포트로 브로드캐스트하며 반이중 통신만 지원합니다. 반면 스위치는 데이터 링크 계층 장비로, MAC 주소 학습을 통해 목적지 포트로만 전송하며 전이중 통신을 지원합니다.
        </p>
    </details>
</div>

## :질문:스터디에서 논의하고 싶은 질문

- RB 트리, 얼마나 알고 있어야할까요?

## :링크: 참고 자료

- [CS 정리 블로그](https://example.com)