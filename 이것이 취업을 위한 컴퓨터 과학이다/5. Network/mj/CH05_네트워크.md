# CH05. 네트워크

## 📌 핵심 개념 요약

- LAN, WAN, 패킷 교환
- 주소 전송 방식
- OSI 7계층, 캡슐화와 역캡슐화
- 물리 계층과 데이터 링크 계층
  - 이더넷, 유무선 통신매체, 허브와 스위치
- 네트워크 계층
  - IP(목적, 특징, 구조, 공인/사설 IP 주소, 정적/동적 할당, ARP)
- 전송 계층
  - TCP와 UDP (목적, 특징, 포트, 연결 수립, 오류/흐름/혼잡 제어, 종료, 상태관리)

## 💡 면접 예상 질문

- OSI 7계층에 대해 설명해주세요
- 캡슐화와 역캡슐화에 대해 설명해주세요
- 패킷이 무엇인가요?
- 주소 전달 방식에는 어떤게 있나요?
- MAC 주소가 무엇인가요?
- 허브와 스위치의 차이점은 무엇인가요?
- IP의 목적과 특징은 무엇인가요?
- 단편화가 무엇인가요?
- 오늘날 네트워크 환경에서 IP 단편화가 잘 발생하지 않는 이유는 무엇인가요?
- 서브넷 마스크를 사용하는 이유가 무엇인가요?
- 정적 IP 주소를 부여할 때 **필수적으로 설정해야 하는 네 가지 값**은 무엇인가요? 각각 어떻게 사용되는지 한 흐름으로 설명해주세요.
- ARP가 무엇인가요?
- 순서 번호와 확인 응답 번호가 무엇인가요?
- 파이프라이닝이 무엇인가요?
- 흐름 제어의 주체는 무엇이고, 어떻게 판단하나요?
- 혼잡 제어의 주체는 무엇이고, 어떻게 판단하나요?
- 혼잡 제어 알고리즘엔 어떤 것이 있나요?

## ❓스터디에서 논의하고 싶은 질문

-

## 🔗 참고 자료

- **[책]** 이것이 취업을 위한 컴퓨터 과학이다 with CS 기술 면접

# 1. 네트워크의 큰 그림

## 네트워크의 기본 구조

- 네트워크는 노드와 간선으로 이루어진 그래프
  - 네트워크 기기 (노드)
  - 정보를 주고받는 유무선의 통신매체 (간선)
- `네트워크 토플로지`
  - 노드와 노드 사이의 연결구조
  - 망형/ 트리형/ 링형/ 성형/ 버스형(선형)
- `호스트`
  - 네트워크의 가장자리에 위치하면서 네트워크를 통해 주고받는 정보를 최초로 송신하고 최종수신하는 노드
    - Ex) 노트북과 구글의 서버 컴퓨터가 각각 호스트로서 정보를 주고 받음 (웹 페이지를 가져달라는 요청과 응답)
- `클라이언트`(요청) ↔ `서버`(응답)
- `스위치`와 `라우터`, `공유기` (중간노드로써 호스트가 주고받는 정보들을 원하는 수신지까지 안정적으로 전송하는 역할)

---

### LAN과 WAN

> 전 세계에는 하나의 네트워크만 존재할까?
> 당연히 아니다! 네트워크는 규모에 따라 LAN과 WAN으로 나뉜다

- `LAN`
  - Local Area Network
  - 가정이나 기업처럼 비교적 가까운 거리를 연결하는 한정된 공간에서의 네트워크
  - 같은 LAN에서만 통신이 이루어지는 것은 아니고, LAN 간의 통신도 빈번하다
- `WAN`
  - Wide Area Network
  - 원거리 네트워크
  - WAN을 통해 LAN 간의 통신이 이루어짐 (인터넷을 가능하게 하는…)
  - WAN은 일반적으로 `ISP`(Internet Service Provider)라는 인터넷 서비스 업체가 구축하고 관리한다

### 패킷 교환 네트워크

> 서로 다른 네트워크에 있는 두 호스트가 파일을 주고받는 경우를 생각해보자
>
> - 네트워크를 통해 주고받는 데이터는 한 번에 송수신 되지 않고 여러 데이터로 쪼개져서 송수신된다.
>   → 송수신되는 데이터의 단위: `패킷`

- 이렇게 네트워크는 패킷 단위로 정보를 송수신, 수신지에서 재조립하는 ‘패킷 교환 네트워크’가 대부분!
- 패킷의 구성
  - 페이로드와 헤더 (+트레일러)
    - `페이로드`: 패킷에서 송수신하과 하는 데이터
    - `헤더`와 `트레일러`: 패킷의 부가정보

### 주소와 전송 방식

> 두 호스트가 패킷을 주고받을 때, 올바르게 정보를 주고 받기 위해서는 서로를 특정할 수 있는 정보, 즉 주소가 필요하다
>
> - `주소`: 패킷의 헤더에 명시되는 정보 (ex. IP주소, MAC주소)

- `전송방식`
  - 주소를 바탕으로 다양한 수신지 유형을 지정해 패킷을 보낼 수 있다.
  - `유니캐스트`: 송신지와 수신지가 일대일로 메시지를 주고받는 전송 방식
  - `브로드캐스트`: 네트워크상의 모든 호스트에게 메시지를 전송하는 전송 방식
    - 브로드캐스트 도메인: 브로드캐스트가 전송되는 범위
      - 호스트가 같은 브로드캐스트 도메인에 속해 있는 경우, 같은 LAN에 속해있다고 간주
  - `멀티캐스트`: 네트워크 내의 동일 그룹에 속한 호스트에게만 전송하는 방식
  - `애니캐스트`: 네트워크 내의 동일 그룹에 속한 호스트 중 가장 가까운 호스트에게 전송하는 방식

## 두 호스트가 패킷을 주고받는 과정

> 호스트가 서로 주고받는 정보를 이해하기 위한 규칙인
> 프로토콜과 네트워크 참조 모델의 개념, 패킷을 주고 받는 과정에 대해 알아보자

### 프로토콜

- 만약 두 호스트가 서로 다른 LAN에 속해있어서 주고받는 패킷이 네트워크 장비를 거친다고 할 때, 이 패킷을 서로 이해할 수 있어야함.
  - 호스트뿐만 아니라 패킷이 거쳐 갈 네트워크 장비 역시 패킷의 내용을 이해할 수 있어야 함 → 프로토콜이라는 규칙이 필요함!
- `프로토콜`: 네트워크에서 통신을 주고받는 노드 간의 합의된 규칙이나 방법
  - 프로토콜이 존재하는 이유에 집중할 것!
    - IP (네트워크 간의 주소를 지정)
    - ARP (IP주소와 MAC주소를 대응)
    - HTTPS (HTTP에 비해 보안상 안전)
    - TCP (UDP에 비해 신뢰성이 높음)
  - 목적과 특징이 다른 프로토콜로 구성된 패킷의 내용도 달라질 수 있다.

### 네트워크 참조 모델

- 네트워크도 주고받는 과정에서의 순서가 정해져있음!
  - 이렇게 통신이 이루어지는 단계를 계층적으로 표현한 것을 네트워크 참조 모델이라고 한다.
- `OSI모델`
  - 국제 표준화 기구에서 만든 네트워크 참조 모델
    (통신 단계를 7개의 계층으로 나눔)
        ![image.png](attachment:b686d546-f4b5-4637-88b1-75a39e267f15:image.png)

        1. **물리 계층**
            - 최하위 계층, 비트 신호를 주고 받음(0,1)
            - 유무선 통신 매체를 통해 이런 신호를 운반
        2. **데이터 링크 게층**
            - 같은 LAN에 속한 호스트끼리 올바르게 정보를 주고받기 위한 계층
            - 같은 네트워크에 속한 호스트를 식별할 수 있는 주소 (`MAC주소`)를 사용하고, 물리 계층에서 주고받는 정보 오류를 체크한다
            - 하드웨어와 밀접하게 맞닿아 있는 계층
        3. **네트워크 계층**
            - 네트워크 간 통신을 가능하게 하는 계층
            - LAN을 넘어 다른 네트워크와 통신을 주고받기 위해 필요한 계층 (`IP주소`) → `IP 프로토콜` 사용
        4. 전송 계층
            - 네트워크를 통해 송수신되는 패킷이 신뢰성있게 전송되도록 하는 계층 → `TCP/UDP 프로토콜` 사용
            - `포트`라는 정보를 통해 응용 프로그램과의 다리 역할을 수행하기도함
        5. 세션 계층
            - 응용 프로그램 간의 연결 상태를 의미하는 `세션`을 관리하기 위한 계층
            - 연결 상태를 유지하거나 새롭게 생성, 필요하다면 끊는 역할
        6. 표현 계층
            - 인코딩과 압축, 암호화같은 작업을 수행
            - 세션계층과 표현계층은 두 계층을 명확하게 구분하지 않거나 응용 계층에 포함하여 간주하는 경우가 많다.
        7. 응용 계층
            - 사용자와 가장 밀접하게 맞닿아 있어 여러 네트워크 서비스를 ㅈ공하는 계층, 중요한 프로토콜 다수 포함

                → `HTTP, HTTPS, DNS 프로토콜` 등

- `TCP/IP 모델`
  - `TCP/IP` 4계층이라고도 불린다.
    - OSI(네트워크 이론적 기술을 목적)에 비해 구현과 프로토콜에 중점을 둔 네트워크 참조 모델
    1. 네트워크 액세스 계층
       - 링크 계층, 네트워크 인터페이스 계층이라고도 불림
       - OSI모델의 데이터 링크 계층과 유사
    2. 인터넷 계층
       - OSI 모델의 네트워크 계층과 유사
    3. 전송 계층
       - OSI 모델의 전송 계층과 유사
    4. 응용계층
       - OSI 모델의 세션/표현/응용계층을 합친 것과 유사

![image.png](attachment:f98f9002-e8cc-430a-b443-4f4fb7551254:image.png)

### 캡슐화와 역캡슐화

- 패킷의 송수신 과정 중 송신과정에서는 캡슐화, 수신과정에서는 역캡슐화가 이루어진다.
  - 네트워크 계층 구조를 통한 송수신과 패킷의 구조를 생각해보자
  - 송신) 상위 계층으로부터 내려받은 패킷을 페이로드로 삼아, 각 계층에 포함된 프로토콜의 각기 다른 목적과 특징에 따라, 헤더 혹은 트레일러를 덧붙인 다음 하위계층으로 전달
    → `캡슐화`: 송신 과정에서 헤더(및 트레일러)를 추가해나가는 과정
        → `역캡슐화`: 캡슐화 과정에서 붙인 헤더(및 트레일러)를 각 계층에서 확인한 뒤 제거하는 과정

![image.png](attachment:90b4981b-30a7-41c7-9fdb-65f017c11bf7:image.png)

![image.png](attachment:71f22976-49b2-4f15-8a35-459b9e12591c:image.png)

# 2. 물리 계층과 데이터 링크 계층

> 이더넷, 이더넷 프레임, 통신 매체, 네트워크 장비

## 이더넷

- 물리 계층과 데이터 링크 계층에는 LAN 내의 호스트들이 올바르게 정보를 주고 받을 수 있게 해주는 다양한 기술이 포함되어 있음
  - `이더넷`: 통신 매체를 통해 신호를 송수신하는 방법, 데이터 링크 계층에서 주고받는 데이터(프레임) 형식 등이 정의된 기술
- 이더넷 표준
  - IEEE 802.3 국제 표준화 기술
    - 국제 표준화? 서로 다른 제조사의 네트워크 장비라 하더라도 LAN내의 모든 컴퓨터가 문제없이 호환되는 이유!
  - 기억해두면 좋을 것
    1. 오늘날의 (유선) LAN 대부분이 이더넷 표준을 따르기 때문에 대다수의 LAN장비들이 특정 이더넷 표준을 따른다
    2. 이더넷 표준이 달라지면 통신 매체를 비롯한 신호 송수신 방법, 최대 지원 속도도 달라질 수 있다.
- 이더넷 `프레임`: 이더넷 기반의 네트워크에서 주고받는 프레임
  - 프레임이 구성하는 정보 (5가지)
    ![image.png](attachment:e903c8b5-956f-4f14-b6e3-f6ca6073f1d9:image.png)
    1. 프리앰블 preamble
       - 송수신지 동기화를 위해 사용되는 8바이트(64비트) 크기의 정보
       - 프리앰블의 첫 7바이트: 10101010, 마지막 바이트: 10101011
         이 프리앰블 비트를 통해 현재의 이더넷 프레임이 수신되고 있다는 사실을 알 수 있다.
    2. 송수신지 MAC 주소
       - `MAC 주소`: 프레임에서 가장 중요한 정보, 송신지와 수신지를 특정할 수 있는 6바이트(48비트) 길이의 주소 (물리적 주소)
       - Ex) ab:cd:ab:cd:00:01
       - MAC 주소는 물리적 주소로 네트워크 인터페이스마다 하나씩 부여되는 주소
         - 네트워크 인터페이스: 네트워크를 향하는 통로, 연결 매체와의 연결 지점, 보통 NIC라는 장치가 담당
         - NIC와 네트워크…
           - NIC가 여러 개인 상황처럼 네트워크 인터페이스가 여럿이라면 한 호스트가 여러 개의 MAC주소를 가질 수 있음
    3. 타입/길이
       - 필드에 명시된 크기가 1500이하(16진수 05DC)이면 프레임 크기를 나타내고, 1536이상(16진수 0600)이면 타입을 나타냄
       - 타입: 캡슐화된 상위 계층의 정보
         - Ex) IPv4가 캡슐화된 정보 운반 → 타입:16진수 0800, ARP 프로토콜이 캡슐화된 정보 운반 → 타입: 16진수 0806
    4. 데이터
       - `페이로드`(상위 계층으로 전달하거나 전달받을 데이터가 명시)가 명시
       - 데이터 필드에 포함될 수 있는 데이터의 최대 크기가 정해져있음 (기준: 1500바이트 → 네트워크 계층 패킷(헤더+페이로드)의 최대 크기: MTU)
         (사실 더 큰 데이터를 포함할 수있는 프레임도 있음: 점보 프레임)
    5. FCS Frame Check Sequence
       - 프레임의 오류가 있는지의 여부를 확인하기 위한 필드
       - CRC (Cyclic Redundancy Check)라는 오류 검출용 값 명시
         - 송신지에서 전송할 데이터, 더불어 전송할 데이터에 대한 CRC 값을 계산하여 보내면 수신지에서는 전달받은 데이터에 대한 CRC값을 계산해 대조 (같아야 오류없음)

## 유무선 통신 매체

> 호스트가 아무리 빠르게 데이터를 처리할 수 있어도 그를 뒷받침하는 연결 매체의 성능이 뒷받침되지 않으면 아무런 효용이 없음!

### 유선 매체 - 트위스티드 페어 케이블

- 구리선을 통해 전기적으로 신호를 주고받는 통신매체
- 성능 → 카테고리를 통해 알 수 있음 (Cat)
  - 카테고리에 따라 대응되는 이더넷 표준, 표준에 따른 최대 지원 속도 다를 수 있음
  - 카테고리는 트위스티드 페어 케이블의 성능을 구분하는 일종의 등급 역할
- 노이즈(잡음), 포일로 감싸 노이즈 방지, 차폐(구리선 주변을 보호해 노이즈를 감소시키는 방식)
- 브레이크 실드로 노이즈를 감소시킨 케이블 (STP), 포일 실드로 노이즈를 감소시킨 케이블(FTP), 구리선만 있는 케이블(UTP)
  - 더 상세한 표기: []/[]TP에서 []에 U,S,F를 명시할 수 있음

### 무선 매체 - 전파와 WiFi

> 진동수 2.4GHz, 5GHz 정도는 알아볼까?

- 와이파이
  - 무선 LAN에서 가장 대중적으로 사용되는 기술
  - IEEE 802.11 표준을 따르는 무선 LAN 기술. 뒤에 붙는 알파벳으로 표준 규격을 구분 (Wi-Fi 4~7)
  - 같은 주파수 대역을 사용하는 여러 무선 네트워크가 존재할 수 있음. 즉, 같은 지역 내에 2.4GHz/5GHz 대역을 사용하는 무선 네트워크가 여러 개 존재할 수 있다는 말
    - 전파 통신을 주고받을 때 주파수 대역이 겹치면 신호의 간섭이 발생할 수 있음 → 서로 다른 무선 네트워크를 구분하기 위해 `채널`이라는 하위 주파수 대역을 세분화
  ![image.png](attachment:cf6e8f07-59cf-4edf-be3c-6519bbd202a6:image.png)
  - 2.4GHz 대역의 채널에서 1,6,11 채널의 주파수는 서로 중첩되지 않음 → 아무리 많은 통신이 이루어지더라도 신호 간섭을 ㅇ니한 성능 저하가 발생하지 않는다
  - 무선 네트워크의 성능 저하를 방지하려면 신호가 중첩되지 않는 채널을 사용하는 것이 중요!
- AP와 SSID
  - AP: 여러 무선 통신 기기를 연결해 무선 네트워크를 구성하는 장비(ex. 무선 공유기)
  - SSID: 서비스 셋(AP를 중심으로 구성된 무선 네트워크)을 식별하는 정보 (ex. 와이파이)

### 네트워크 인터페이스: NIC

- 네트워크 상에서 노드와 통신 매체가 연결되는 지점 (노드와 네트워크 사이의 통로)
- 노드가 네트워크를 통해 송수신하는 정보는? 네트워크 인터페이스를 거친다.
  - 네트워크 인터페이스마다 물리적 주소인 MAC주소가 부여되고, `NIC`(Network Interface Controller)라는 **하드웨어**가 네트워크 인터페이스의 역할을 담당
    - 요즘엔 마더보드에 내장된 NIC를 사용할 가능성이 높다
- NIC가 하는 일
  - 통신 매체의 신호를 호스트가 이해하는 프레임으로 변환하거나 호스트가 이해하는 프레임을 통신 매체의 신호로 변환하는 역할
  - MAC 주소를 토대로 잘못 전송된 패킷이 없는지 확인
- NIC 동작 방식
  - 동작하는 방식도 입출력 과정과 다르지 않다.
    - 패킷을 송신하는 동작을 출력, 수신하는 동작을 입력
  - 각각의 성능이 다르고, 지원속도가 다르며 네트워크의 속도에 큰 영향을 끼침
- 티밍과 본딩
  - 고가의 NIC를 구비하는 방법 외에도 NIC 단계의 성능 향상을 위해 사용하는 방식이 있음
    (여러 물리적인 NIC를 마치 하나의 고속 NIC처럼 구성)
  - 저성능의 여러 물리적인 입출력장치를 고성능의 논리적 입출력장치 하나로 묶어 사용한다는 점에서 컴퓨터구조에서 학습한 RAID와 유사
  - 티밍(윈도우)과 본딩(리눅스)을 통해 송수신 성능을 향상시킬 수 있고, 하나의 NIC에 문제가 발생하더라도 다른 NIC를 통해 송수신되도록 하여 안정적으로 송수신될 수 있음!

## 허브와 스위치

> 물리 계층과 데이터 링크 계층의 중간 노드

- 요즘 허브보다는 스위치를 사용하는 경우가 많음
  - 허브: 전이중/반이중 통신 → 브로드캐스트 통신의 특징을 잘 보여주는 네트워크 장비

### 물리 계층의 `허브`

![image.png](attachment:3bb4cc97-1a66-4208-ad1b-9494863edc0a:image.png)

> 물리 계층의 대표적인 네트워크 장비: `허브`

- 여러 대의 호스트를 연결하는 장치
  - 리피터 허브, 이더넷 허브(이더넷 네트워크의 허브)라고도 불림
- `포트`: 허브에서 케이블의 커넥터가 꽂히는 부분 (통신 매체를 연결하는 지점)
- 허브의 2가지 특징
  1. **전달받은 신호를 모든 포트로 내보낸다**
  2. **`반이중 모드`로 통신한다**
     - 반이중 모드: 송신 또는 수신을 번갈아가면서 수행해야하는 통신 방식
       - 동시 송수신이 불가능 (무전기 처럼!)
     - 전이중 모드: 동시 송수신이 가능한 상태
       - 데이터 링크 계층의 `스위치`는 전이중 모드 지원
  ![image.png](attachment:ea8f23fa-ec5f-4ab4-8c62-0a2a90e21d25:image.png)
- 반이중모드로 통신하면 한 호스트가 허브로 정보를 전달하면 다른 호스트는 정보를 전송할 수 없다! → 동시에 메시지를 보내면 충돌!
  - 충돌이 발생할 수 있는 영역: 콜리전(충돌) 도메인
    → 허브에 연결된 모든 호스트

### 데이터 링크 계층의 `스위치`

![image.png](attachment:9ded0ef4-d38b-4e6f-a10a-467ecafe721a:image.png)

> 허브의 한계를 보완하기 위한 네트워크 장비: 스위치
>
> 전이중모드 지원!

- 2계층에서 사용한다는 점에서 L2스위치라고도 부른다. (상위 계층에서 사용하는 L3,L4스위치도 있음)
- **허브와 다른점**
  - **전달받은 신호를 목적지 호스트가 연결된 포트로만 내보냄!**
    - `MAC주소학습` 기능이 있기 때문!
  - **전이중 모드 지원 (허브와 비교해 콜리전 도메인이 좁다)**
- 스위치의 주요 기능
  - `MAC주소 학습`
    - 프레임 헤더에는 MAC주소가 명시되는데 스위치는 데이터링크 계층에 속한 장비이므로 MAC주소를 이해할 수 있다
    - (포트, 연결된 호스트의 MAC주소)의 대응관계를 `MAC 주소 테이블`의 형태로 메모리에 저장
      ![image.png](attachment:6cdd3049-1a66-4a7a-afd0-93af8ba04e93:image.png)
  - `VLAN (가상의 LAN)`
    - 같은 위치에 연결된 모든 호스트를 하나의 네트워크로 간주하고 싶지 않을 때, 여러 논리적인 네트워크로 나누고 싶을 때 사용
    - 서로 다른 VLAN에 속해있으면 서로 다른 네트워크로 간주되고, 브로드캐스트 도메인도 겹치지 않아 서로의 브로드캐스트 메시지가 도달하지 않는다. → 서로 통신을 주고받으려면 네트워크 계층 이상의 장비가 필요하다
      ![image.png](attachment:5c3288d1-c137-4a94-8ceb-e75fb2b16925:image.png)

# 3. 네트워크 계층 - IP

> LAN을 넘어서 다른 네트워크와 통신을 주고받으려면 네트워크 계층 이상의 기술이 필요
> → 네트워크 계층의 핵심적인 프로토콜: `IP`

## IP의 목적과 특징

- 목적은 2가지!
  1. `주소 지정`: 네트워크 간의 통신 과정에서 **호스트를 특정하는 것**
  2. `단편화`: 데이터를 **여러 IP 패킷으로 올바르게 쪼개어** 보내는 것
- 특징
  1. **신뢰할 수 없는 통신**
  2. **비연결형 통신**

### 주소 지정과 단편화

1. `주소 지정`

   - IP주소를 통해 이루어지며, IP 패킷 헤더를 통해 알 수 있다
     - IP 패킷 헤더에서 주소 지정과 관련한 필드를 확인해보자
       - `송신지 IP 주소`
       - `수신지 IP 주소`
     - 하나의 IP는 총 4바이트의 크기로 구성되고 숫자당 8비트로 표현되므로
       0~~255범위의 10진수 4개로 표현됨
     - 각각의 10진수를 .으로 구분, 구분된 하나의 10진수는 옥텟
       ex) 192.168.0.1
       - 192, 168, 0, 1 → 각각 하나의 옥텟
         ![image.png](attachment:e00d4955-2ae0-433c-8118-e0275b3cc037:image.png)
   - 패킷을 올바르게 전송하기 위해서는 MAC주소와 IP주소가 모두 필요
     - MAC주소 (수신인과 발신인)
     - IP주소 (수신주소와 발신주소) → 우선적으로 활용
   - `라우터`: IP 주소를 기반으로 패킷의 최적 경로를 결정하여 목적지까지 전달
     - 공유기도 라우터의 일종

   > IPv4와 IPv6
   >
   > - `IPv4`주소는 총 32비트로 표현 → 2^32 → 약 43억개의 할당가능한 주소
   >   - 이런 IPv4 주소 고갈 문제로 등장한게 `IPv6`
   > - IPv6주소는 16바이트(128비트)로 주소를 표현 → 무한에 가까운 수
   >   - `IPv4`와 다르게 :으로 구분된 8개의 그룹의 16진수

2. `단편화`
   - MTU: Maximum Transmission Unit
     - 최대 전송 단위.
     - 전송하고자 하는 IP 패킷 (IP 헤더와 페이로드)의 크기가 MTU라는 단위보다 클 경우,
       **패킷을 MTU 이하의 여러 패킷으로 쪼개서 전송하고, 이렇게 쪼개서 전송된 패킷들은 수신지에서 재조합**
     - 일반적으로 1500바이트. 프레임을 통해 주고받을 수 있는 최대 페이로드의 크기
     ![image.png](attachment:4bf20ef9-14da-432c-9b35-2583b1c40042:image.png)
     - IP 패킷 헤더에서 **단편화 관련 필드**를 확인해보자
       1. `식별자`
          - 어떤 데이터에서 쪼개진 패킷인지를 식별하기 위해 사용되는 필드
          - 같은 정보에서 쪼개진 패킷들은 같은 식별자를 공유
       2. `플래그`

          - 3비트로 구성된 필드로, 첫 번째 비트를 제외한 나머지 2개의 비트는 각각 DF와 MF
          - 첫 번째 비트는 항상 0으로 설정되어 오늘날 사용되지 않고, DF는 ‘IP 단편화 를 수행하지 말라(Don’t Fragment)’, MF는 ‘단편화된 패킷이 더 있다(More Fragment)’는 표시를 남기기 위한 비트입니다.

          ![image.png](attachment:b5fbbd7a-7ecf-4207-927b-95fba801745d:image.png)

       3. `단편화 오프셋`
          - 특정 패킷이 초기 데이터에서 얼마나 떨어져 있는지가 명시된 필드
          - 단편화되어 전송되는 패킷을 목적지에서 재조합하기 위해 패킷의 올바른 순서를 나타내는데 사용됨

### IP의 특징- 신뢰할 수 없는 통신과 비연결형 통신

- 신뢰할 수 없는 프로토콜, 비연결형 프로토콜
  - `신뢰할 수 없는 프로토콜`: 패킷이 수신지까지 제대로 전송되었다고 보장하지 않는 프로토콜
    - **패킷이 유실되거나 목적지에 순서대로 전송되지 않더라도 이에 대한 조치를 취하지 않는 것**
    - 신뢰성이 낮은 통신, 최선형 전달이라고도 함
  - `비연결형 프로토콜`
    - 패킷을 주고받기 전에 **사전 연결 과정을 거치지 않는다**
    - 상대 호스트의 수신 가능 여부는 고려하지 않고, 수신지를 향해 패킷을 전송할 뿐
    - (`↔` 패킷을 주고받기 전에 송수신지 간의 연결을 맺는 프로토콜: `TCP`)
      - TCP는 송수신지 간의 연결 설정을 통해 패킷을 주고받을 호스트 간에 송수신 준비가 되어있는지를 확인할 수 있다.
- Cf) IP 단편화 피하기 - 경로 MTU 발견
  - IP의 본래 목적은 주소 지정과 단편화!
    - 사실 오늘날의 네트워크 환경에선 IP단편화가 잘 발생하지 않는데, 그만큼 네트워크 성능이 발전하기도 했고, IP단편화가 되도록 발생하지 않는 것이 좋다
  - `잦은 IP 단편화`
    - 네트워크에 여러 악영향
    - 단편화된 패킷들이 많아지면 전송해야할 패킷들의 헤더들이 많아지기 때문에 **불필요한 트래픽 증가와 대역폭 낭비**를 초래한다.
    - 단편화된 패킷을 **재조립하는 과정에서 발생하는 부하**도 성능저하로 이어질 수 있다.
  - IP 단편화를 피하는 방법?
    - 패킷을 주고받는 경로에 존재하는 모든 호스트의 처리 가능한 MTU크기를 고려해야한다!
    - `경로MTU`: IP 단편화없이 주고받을 수 있는 최대 크기
    - 이렇게 주고받을 수 있는 경로 MTU를 구하고 해당 크기만큼 송수신하여 IP단편화를 회피하는 기술 → 경로MTU발견

## IP주소의 구조

- IP의 주요 목적이 주소 지정인 만큼 IP 주소는 중요한 개념이겠지!
- 여기에서 다시 네트워크 계층에서 하는 일을 생각해보면, LAN간의 통신을 가능하게 하고, 이는 IP주소 기반으로 이뤄진다고 했었다.
- 하나의 IP 주소는 0~255범위의 10진수 4개로 표기되며,
  - `네트워크 주소`: 네트워크ID, 네트워크 식별자 등으로 불리며, 호스트가 속한 네트워크를 특정하기 위해 사용됨
  - `호스트 주소`: 호스트ID, 호스트 식별자 등으로 불리며, 네트워크에 속한 호스트를 특정하기 위해 사용됨
- 네트워크 주소와 호스트를 표현하는 크기는 유동적일 수 있음
  - 그럼 각각 어느정도가 적당할까?

### 클래스풀 주소 체계

- 네트워크 주소와 호스트 주소의 크기를 유동적으로 구분할 수 있는데
  - 사실 상황에 따라 적당한 정도가 다르다!
  - 이러한 고민을 해결하기 위해 생겨난 개념이 IP주소의 **`클래스`**
- `클래스`: 네트워크의 크기에 따라 유형별로 IP주소를 분류하는 기준
  - 따라서 어떤 클래스에 속한 IP주소인지를 알면, 네트워크부분과 호스트부분의 크기가 어느 정도의 크기인지 알 수 있다
  - 종류
    - A,B,C,D,E 5종류
      - A,B,C → 크기별 IP주소 분류에 사용되는 클래스
      - D,E → 멀티캐스트를 위한 클래스
    → 클래스를 바탕으로 IP주소를 관리하는 주소체계 → 클래스풀 주소 체계
- A
  - 네트워크 주소: 0으로 시작해 1옥텟
  - 호스트 주소: 3옥텟
  - IP주소표현의 가능범위: 0.0.0.0 ~ 127.255.255.255
    → 상대적으로 가장 많은 호스트를 할당할 수 있는 클래스
- B
  - 네트워크 주소: 10으로 시작해 2옥텟
  - 호스트 주소: 2옥텟
  - IP주소표현의 가능범위: 128.0.0.0 ~ 191.255.255.255
- C
  - 네트워크 주소: 110으로 시작해 3옥텟
  - 호스트 주소: 1옥텟
  - IP주소표현의 가능범위: 192.0.0.0 ~ 255.255.255.255

![image.png](attachment:116c57ae-26eb-4521-a4e9-8df9ef4e3b8e:image.png)

- 네트워크/브로드캐스트 주소
  - 호스트 주소가 전부 0인 IP주소 → 네트워크 자체를 의미하는 주소
  - 호스트 주소가 전부 1인 IP주소 → 브로드캐스트를 위한 주소
  - 이러한 주소는 호스트 주소 할당에 사용할 수 없다. (호스트 주소 공간을 모두 사용할 수 있는 것은 아님)
- 예약 주소
  - 특수한 목적을 위해 예약된 IP주소도 있음
  ![image.png](attachment:618937b0-3328-49b3-bd6f-ebdf2b7c5718:image.png)
  - 루프백 주소: 자기 자신을 가리키는 특별한 주소
    - 루프백 주소로 전송된 패킷은 자기 자신에게 되돌아오므로 자기 자신을 마치 호스트인 양 간주하여 패킷을 전송할 수 있다
    - Ex) 로컬호스트

### 클래스리스 주소 체계와 서브넷 마스크

- 클래스풀 주소 체계에서는 클래스별 네트워크 크기가 고정되어있었다.
  (A,B,C 각각 8,16,24비트)
- 이때는 고정된 크기 외에 다른 크기의 네트워크를 구성할 수 없어 IP주소가 낭비될 수 있다는 한계가 있다
  - Ex) 상대적으로 호스트 할당 주소가 적은 C클래스 주소를 다 사용했다면 어쩔 수 없이 B클래스 주소를 이용해 IP주소를 낭비할 수 있는 문제
- 해결) `클래스리스 주소 체계`
  - 클래스를 이용하지 않고, 클래스풀 주소 체계보다 더 정교하고 유동적으로 네트워크 영역을 나누는 수단
  - 그럼 어떻게 네트워크/호스트 주소 구분?? → `서브넷 마스크`
  - `서브넷 마스크`: IP주소 상에서 네트워크 주소를 1로 표기하고, 호스트 주소를 0으로 표기한 비트열. 즉, 서브넷을 구분하는 비트열
    - A,B,C 클래스의 기본 서브넷 마스크
      ![image.png](attachment:dfb84958-3c08-4678-8e50-4cc2af75c174:image.png)
    - 서브넷 마스크와 IP 주소 간에 비트 AND연산을 수행하면 IP 주소 내의 네트워크 주소를 알아낼 수 있다.
      ![image.png](attachment:3f44ce52-a011-46cc-8175-9f7ff2b9ae6d:image.png)
  - `서브네트워크`: IP주소에서 네트워크 주소로 구분할 수 있는 네트워크의 부분집합 (=서브넷)
  - `서브네팅`: 서브넷 마스크를 이용해 원하는 크기로 클래스를 더 잘게 쪼개어 사용하는 것
- Cf) CIDR표기
  - 또 다른 서브넷 마스크 표기법
  - 10진수로 직접 표기하는 방법이 아닌, IP주소/서브넷 마스크 상의 1의 개수의 형식으로 표기
  - IP주소와 서브넷마스크를 함께 표현할 수 있는 간단한 표기

## 공인 IP 주소와 사설 IP 주소

- 호스트의 IP 주소 확인하기
  - 윈도우에서 ‘ipconfig/all’을 입력하거나 맥OS, 리눅스에서 ‘ifconfig’ 명령어를 입력
  - 검색 사이트에서 검색
  - 이때 두 방식으로 확인한 IP 주소가 다른 경우가 많을 것!
    - 왜지? 고유한 IP 주소는 `공인 IP 주소`라고 하고,
      고유하지 않은 IP 주소는 `사설 IP 주소`
- `공인 IP 주소`
  - 전 세계에서 고유한 IP 주소
  - 인터넷을 비롯한 네트워크 간 통신에서 사용되는 IP 주소 (검색 사이트를 통해 확인했던)
    - 검색 사이트의 서버와 패킷을 주고받으려면, 호스트가 속한 **네트워크 밖에서 사용할 공인 IP 주소**를 사용해야 하기 때문입니다.
    - 어디에서 **할당**받을까? → ISP나 공인 IP 주소 할당 기관을 통해
- `사설 IP 주소`
  - 외부 네트워크에 공개되지 않은 네트워크(사설 네트워크)에서 사용하기 위한 IP 주소
  - 어디에서 **할당**받을까? → 일반적으로 라우터(공유기)를 통해 할당됨
    - 공유기(라우터)를 중심으로 구성된 LAN 대부분은 사설 네트워크에 해당함
  - 사설 IP 주소로 예약된 IP 주소 공간이 있다!
    - 10.0.0.0/8 (10.0.0.0 ~ 10.255.255.255 )
    - 172.16.0.0/12 (172.16.0.0 ~ 172.31.255.255 )
    - 192.168.0.0/16 (192.168.0.0 ~ 192.168.255.255 )
  - 해당 호스트가 속한 사설 네트워크상에서만 유효한 주소이므로 얼마든지 다른 네트워크상의 사설 IP 주소와 중복될 수 있다

## IP 주소의 할당

> 호스트에 IP주소를 할당하는 방법

1. 정적 할당 → 직접 수작업으로 IP주소를 부여
2. 동적 할당

---

### 정적 할당

- 정적 IP 주소 부여를 위해 필요한 값은?
  - IP 주소와 서브넷 마스크, 게이트웨이(라우터) 주소, DNS 주소 등
  - 운영 체제에 관계없이 대체적으로 유사
- `게이트웨이`: 일반적으로 서로 다른 네트워크를 연결하는 하드웨어적/소프트웨어적 수단
  - 기본 게이트웨이는 호스트가 속한 네트워크의 외부로 나가기 위한 첫 기본 경로 (출입문 역할)
  - 네트워크 외부와 연결된 라우터의 주소를 의미하는 경우가 많음
- `DNS주소` : 호스트가 도메인 네임을 토대로 IP 주소를 알아내기 위해 질의하는 서버의 주소
  - 호스트끼리 패킷을 주고받기 위해서는 IP 주소가 사용되지만, 통신을 주고받는 모든 호스트의 IP 주소를 기억하기는 어려움
  - IP 주소에 대응되는 기억할 수 있는 문자열(→`도메인 네임`)로 호스트를 식별
    - ex) ‘[google.com](http://google.com/), [hanbit.co.kr](http://hanbit.co.kr/), [minchul.net](http://minchul.net/)’ 등
  - **대응되는 IP 주소를 알아내려면 <도메인 네임, IP 주소> 쌍을 저장하는 서버에 질의**
    ![image.png](attachment:e43b6dfd-0987-4662-b805-9c541c358e5b:image.png)

### 동적 할당: DHCP

- 프로토콜을 통해 자동으로 IP주소를 부여하는 방식
- 대표적인 프로토콜: DHCP (Dynamic Host Configuration Protocol)
  - **IP 주소를 동적으로 할당받으려면 호스트는 DHCP 서버와 메시지를 주고받아야함**
    - `DHCP 서버`: 호스트에 할당 가능한 IP 주소 목록을 관리하다가, IP 주소 할당 요청을 받았 을 때 IP 주소를 할당해 주는 호스트
      - 라우터(공유기)가 DHCP 서버 역할을 수행
  > 규칙 2가지
  >
  > 1. 동적 IP 주소에는 **사용 가능한 기간(임대 기간)이 정해져 있다.**
  > 2. 동적IP 주소는 **할당받을 때마다 다른주소를 받을 수 있다.**
  - 사용 기간이 끝난 IP 주소는 DHCP 서버로 반납되고, 새롭게 IP 주소를
    할당받는 경우 다른 IP 주소를 할당받을 수 있다 (IP주소의 임대)
  - IP 주소의 임대 기간이 끝나기 전에 임대 기간을 연장할 수도 있다 (`임대 갱신`)- 자동으로 2차례, 모두 실패하면 IP주소는 DHCP 서버로 반납됨

### **IP** 전송 특징의 보완: **ICMP**

- **IP의 특징: 신뢰할 수 없는 프로토콜, 비연결형 프로토콜**
  - **장점) 성능**
- 신뢰성 높은 송수신을 하려면→ 패킷에 대한 오류 제어 수행
  연결형 송수신을 하려면 → 패킷을 주고받는 호스트 간 연결을 수립하고 연결을 관리해야함
- 더 많은 시간과 대역폭, 부하가 필요하기 때문에 성능상 불리

> 그래도 보완하자면?
>
> 1. 신뢰할 수 있는 연결형 통신을 지원하는 **상위 계층의 프로토콜 이용** (ex. TCP)
> 2. **네트워크 계층의 프로토콜로 ICMP(Internet Control Message Protocol)을 이용**

- `ICMP`
  - IP 패킷의 전송 과정에 대한 피드백 메시지(`ICMP 메시지`)를 얻기 위해 사용하는 프로토콜
  - 패킷이 상대방에게 어떻게 전송되었는지를 알 수 있음
  - 대신, IP의 신뢰성을 완전히 보장하는 것은 아니다. 전송 계층의 프로토콜이 필요하다.
  - ICMP 메시지 구성
    1. 전송 과정에서 발생한 **오류 보고**
    2. 네트워크에 대한 진단 정보 (**네트워크 상의 정보**)
    ![image.png](attachment:36b1ab1a-3709-4ddf-8255-b4b3e1b336d5:image.png)
  - `오류 보고`
    - ex)
      - 네트워크 장비(가령 라우터)가 패킷을 전달받았는데, 해당 패킷을 어떤 네트워크로 전송 해야 할지 알 수 없을 경우 → **[네트워크 도달 불가] ICMP 메시지**
      - 처리하기에 너 무 큰 패킷을 전달받았는데, DF 플래그가 설정되어 있어 단편화가 불가능할 경우 → **[단편화가 필요하지만 DF가 1로 설정되어 단편화할 수 없음]**을 나타내는 ICMP 메시지
      - IP 헤더에는 패킷의 수명을 의미하는 TTL(Time To Live) 필드가 있음
        패킷은 멀리 떨어진 호스트끼리 통신할 때 여러 라 우터를 거쳐 이동할 수 있는데, 패킷이 하나의 라우터를 거칠 때마다 TTL이 1씩 감소합니다. 이때 TTL 필드가 0이 되면 해당 패킷은 폐기 → 패킷을 송신한 호스트에게 **[시간 초과]Time Exceeded ICMP 메시지** - 패킷이 호스트 호는 라우터에 한 번 전달되는 것 : `홉` - 홉마다 TTL 1씩 감소 - TTL 필드가 존재하는 이유: 무의미한 패킷이 네트워크 상에 지속적으로 남아있는 것을 방지하기 위함
  - `네트워크 진단`
    - ICMP 메시지는 네트워크상의 간단한 문제를 진단하고 테스트하기 위해 사용되기도 함
    - ex) traeroute, ping

## IP 주소와 MAC 주소의 대응: ARP

> MAC 주소는 수신인과 발신인, IP 주소는 수신 주소와 발신 주소에 비유할 수 있다.
> 상대 호스트의 IP 주소는 알고, **MAC 주소는 모르는 상황**에 사용하는 프로토콜 → `ARP`

- `ARP` (Address Resolution Protocol)
  - IP 주소와 MAC 주소를 함께 활용 하는 통신 과정에서 동일 네트워크 내에있는 송수신 대상의 IP 주소를 통해 MAC 주소를 알아내는 프로토콜
  - 동작 과정: **ARP 요청 메시지**와 **ARP 응답 메시지**를 통해 이루어짐
    - ARP 요청은 네트워크 내에 있는 모든 호스트에게 보내는 브로드캐스트 메시지
    - **`ARP 요청 메시지` → MAC 주소에 대응되는 IP 주소가 포함**
    ![image.png](attachment:c56d3cd2-d5b3-4e57-ba01-cc0aee0ab182:image.png)
    > “이 IP 주소를 가진 호스트와 통신하고 싶은데,
    > 이 호스트의 MAC 주소가 무엇인가요?’”
  - 호스트: 자신과 관련이 없는 IP 주소일경우에는 무시하고, 자신의 IP 주소일 경우에는 ARP 응답 메시지를 전송
    - **`ARP 응답 메시지` → 응답 메시지를 보내는 호스트의 MAC 주소가 포함**
    - <IP 주소, MAC 주소> 쌍을 기억해야해! 같은 호스트에게 패킷을 보내야 할 때마다 브로드캐스트(ARP 요청) 메시지를 보내지 않기 위해서…
      → `ARP 테이블`
  - `ARP 테이블`
    - ARP 요청 메시지와 ARP 응답 메시지를 통해 알게 된 <IP 주소, MAC 주소> 쌍은 ARP 테이블에 추가됨
    - arp –a 명령어 → IP 주소와 그에 대응된 MAC 주소를 볼 수 있음

# 4. 전송 계층 - TCP와 UDP

> TCP와 UDP의 패킷 구조와 동작원리를 이해해보자.

## TCP와 UDP의 목적과 특징

> IP 주소와 MAC 주소는 패킷을 송수신하는 호스트를 특정할 수 있다. 사실 패킷의 최종 송수신 대상은 호스트가 아니라 호스트가 실행하는 프로세스이다. (ex. 하나의 호스트는 웹 브라우저, 게임, 채팅 등 다양한 프로세스를 동시에 실행할 수 있고, 네트워크를 통해 주고받는 패킷은 최종적으로 이러한 프로세스에 전달되어야한다.

그럼 네트워크 상에서 **호스트가 실행하는 프로세스는 어떻게 식별할 수 있을까? →`포트`**

>

### 목적) 포트를 통한 프로세스 식별

- 네트워크 패킷을 주고받는 프로세스에는 포트 번호가 할당된다.
- **`IP주소`와 `포트 번호`의 조합** → **특정 호스트가 실행하는 특정 프로세스**를 식별
  ![image.png](attachment:5e698c88-e989-4833-aa53-b0a20a6e2868:image.png)

<aside>
💡

포트를 통한 프로세스 식별은 전송 계층(TCP, UDP )의 주된 목적

![image.png](attachment:37b447e5-ffdd-4b39-9213-347078aa8e30:image.png)

- TCP/UDP 헤더 모두 송신지 포트 | 수신지 포트 번호를 포함하고 있다!
</aside>

- 포트 종류
  - 16비트로 표현할 수 있는 포트 번호의 총 개수는 2^16, 즉 65536개
  - 65535개의 포트번호는 3종류로 나눌 수 있다.
    | 포트 종류      | 포트 번호 범위 |
    | -------------- | -------------- |
    | 잘 알려진 포트 | 0~1023         |
    | 등록된 포트    | 1024~49151     |
    | 동적 포트      | 49152~65535    |
    - 잘 알려진 포트 번호: 대중적으로 사용되는 애플리케이션을 위한 포트 번호
      - 범용적으로 사용되는 프로토콜이 주로 사용하는 포트 번호 목록
        - ex) HTTP 프로토콜로 송수신할 경우 80번 포트를 이용하고, HTTPS 프로토콜로 송수신할 경우 443 포트를 이용
      ![image.png](attachment:fd3a31ec-6bf0-4560-b3db-79d53a48998f:image.png)
    - 등록된 포트 번호
      ![image.png](attachment:7f02b91b-e085-41a4-9223-c797ef7342fa:image.png)
    - 동적 포트 (사설포트, 임시포트)
      - 비교적 자유롭게 사용 가능한 포트 번호
        - ex) 웹 브라우저를 통해 특정 웹사이트에 접속하는 경우
- cf) NAT와 NAPT
  - `NAT`(Network Address Translation ): 공인 IP 주소와 사설 IP 주소 간 변환을 위해 사용하는 기술
    - 공인 IP 주소(네트워크 외부에서 주로 사용)와
      사설 IP 주소(네트워크 내부에서 주로 사용)
    - 네트워크 내부에서 사설 IP 주소를 사용하는 호스트가 네트워크 외부에 있는 호스트와 패킷을 주고받기 위해서는 공인 IP 주소와 사설 IP 주소 간 변환이 필요
      - 대부분의 **라우터와 (가정용)공유기**는 NAT기능을 내장하고 있음
    > 사설 네트워크에서 만들어진 패킷이 네트워크 외부로 전송될 때
    >
    > - 사설 IP주소 → 공인 IP주소 변환 (1)
    >
    > 네트워크 외부 패킷이 사설 네트워크 속 호스트에 이를 때는
    >
    > - 공인 IP주소 → 사설 IP주소 변환 (2)
    ![image.png](attachment:5e48710e-3bf0-4242-989f-90796253e601:image.png)
    - 사설 IP 주소 하나는 공인 IP 주소 하나로 일대일 대응하지 않고,
      다수의 사설 IP 주소를 그보다 적은 수의 공인 IP 주소로 변환한다!
      <aside>
      💡
      
      그렇다면 여러 개의 사설 IP 주소는
      어떻게 **고유한 주소인 공인 IP 주소 하나로 변환될까? → `포트`**
      
      </aside>
      
      > 서로 다른 사설 IP 주소가 같은 공인 IP 주소로 변환되더라도 다른 포트 번호로 변환된다면 네트워크 내부의 호스트를 특정할 수 있다!
      > 
      > - ex) 1.2.3.4’라는 동일한 공인 IP 주소로 변환되더라도 포트 번호 6200번 으로 변환되는지, 6201번으로 변환되는지에 따라 내부 IP 주소를 구분할 수 있다.
  - `NAPT` (Network Address Port Translation)
    - IP 주소 변환 과정에서 변환할 IP 주소의 쌍과 더불어, 포트 번호도 함께 고려하는 포트 기반의 NAT
    - 네트워크 내부에서 사용할 IP 주소와 네트워크 외부에서 사용할 IP 주소를
      N:1로 관리할 수 있다는 점에서, **공인 IP 주소 수의 부족 문제를 개선하는 기술**로도 간주되고 있습니다.
    ![image.png](attachment:a9364545-8e7a-456e-8dcd-9ff05b4a4a36:image.png)

### (비)신뢰성과 (비)연결형 보장

![image.png](attachment:7184ee73-8595-4612-8ddd-697cd66e62ff:image.png)

- TCP
  - 신뢰할 수 있는 통신 — 상태 관리, 흐름 제어, 오류 제어, 혼잡 제어 제공 O
  - 연결형 통신 — 연결수립, 종료 과정 O
  - 그만큼 시간과 연산이 소요되기 때문에 일반적으로 UDP에 비해 송수신 속도가 느림
- UDP
  - 신뢰할 수 없는 통신 — 상태 관리, 흐름 제어, 오류 제어, 혼잡 제어 제공X
  - 비연결형 통신 — 연결수립, 종료 과정 X

> 패킷의 유실 없는 송수신을 원한다면 → TCP
> 비교적 빠른 송수신을 원한다면 → UDP

- 헤더 비교

> TCP 헤더 필드의 수는 UDP보다 훨씬 많습니다.
> (사실상 UDP 헤더는 IP 헤더를 감싸는 일종의 껍데기와 같습니다).
> UDP 헤더에 있는 모든 필드가 TCP 헤더에 포함되어 있음

- UDP 헤더

  ![image.png](attachment:abd8fbd7-cf0d-4abd-ae32-d39a6d83e4a2:image.png)

  - `송신지 포트` | `수신지 포트`
    - 송신 프로세스가 할당된 포트 번호
    - 수신 프로세스가 할당된 포트 번호
  - `길이` | `체크섬`
    - 헤더를 포함한 UDP 패킷(UDP 데이터그램)의 바이트 크기
    - 송수신 과정에서의 데이터그램 훼손 여부를 알 수 있는 정보

- TCP 헤더
  ![image.png](attachment:aced85a4-3198-4ba4-bf19-42904692aa9d:image.png)

![image.png](attachment:25b54a7f-61f1-4eae-bc43-fad60c929f10:image.png)

- `순서 번호 필드`
  (sequence number)
  - TCP 패킷(TCP 세그먼트)의 올바른 송수신 순서를 보장하기 위해 세그먼트 첫 바이트에 매겨진 번호
  - 현재 주고받는 TCP 세그먼트가 송수신하고자 하는 데이터의 몇 번째 바이트에 해당하는지
- `확인 응답 번호 필드` (acknowledgment number)
  - 상대 호스트가 보낸 세그먼트에 대한 응답
- 일부 `제어 비트` (플래그 비트)
  > 제어 비트는 기본적으로 8비트
  - **ACK** : 세그먼트의 승인을 나타내기 위한 비트
  - **SYN**: 연결을 수립하기 위한 비트
  - **FIN**: 연결을 종료하기 위한 비트

<aside>
💡

호스트 B는 확인 응답 번호를 통해 상대 호스트 A에 보낸 패킷에 상대 호스트가 어떻게 반응했는지, 상대 호스트가 다음으로 받고자 하는 패킷이 무엇인지를 알 수 있다.
**→ `TCP`의 신뢰성 보장: `확인 응답 번호`를 통해 이루어진다**

</aside>

## TCP: 연결부터 종료까지

> UDP와 달리 송수신 이전에 **연결을 수립**하고, 송수신 이후에는 **연결을 종료**
> 송수신 전후로 ‘`상태`’라는 값을 관리

### TCP 연결 수립

> 쓰리 웨이 핸드셰이크 three-way handshake
> : 세 단계로 이루어진 TCP 연결 수립 과정
>
> ![image.png](attachment:878faabb-ef0f-422d-b3e4-be19dc36087a:image.png)
>
> ➊ [송수신 방향 **A** → **B**]: **`SYN** 세그먼트 전송`
>
> - 호스트 A는 **SYN 비트가 1로 설정된 세그먼트**(이하 SYN 세그먼트)를 호스트 B에게 전송
> - 세그먼트의 순서 번호에는 호스트 A의 순서 번호가 포함
>
> ➋ [송수신 방향 **B** → **A**] **`SYN** + **ACK** 세그먼트 전송`
>
> - 호스트 B는 **ACK 비트와 SYN 비트가 1로 설정된 세그먼트**(이하 SYN+ACK 세그먼트)를 호스트 A에게 전송
> - 세그먼트의 순서 번호에는 호스트 B의 순서 번호와 ➊에서 보낸 세그먼트에 대한 확인 응답 번호가 포함
>
> ➌ [송수신 방향 **A** → **B**] **`ACK** 세그먼트 전송`
>
> - 호스트 A는 **ACK 비트가 1로 설정된 세그먼트**(이하 ACK 세그먼트)를 호스트 B에게 전송
> - 세그먼트의 순서 번호에는 호스트 A의 순서 번호와 ➋에서 보낸 세그먼트에 대한 확인 응답 번호가 포함

- `SYN 비트`: 연결을 수립하기 위한 비트
  - SYN 비트가 설정된 패킷 을 처음으로 보내는 호스트가 곧 처음으로 연결 요청을 보내는 호스트
    - 연결을 시작하는 과정: **`액티브 오픈` (주로 클라이언트)**
    - 연 결 요청을 수신한 뒤 그에 대한 연결을 수립하는 과정: `패시브 오픈` **(주로 서버)**
  ![image.png](attachment:24986dfb-de71-4a7b-bdc4-c48fee533127:image.png)

### TCP: 오류/흐름/혼잡 제어

> 패킷의 신뢰성을 보장하기 위해 3가지 기능을 제공
>
> - 재전송을 기반으로 다양한 오류를 제어,
>   송수신의 흐름을 제어해 처리할 수 있을 만큼의 데이터를 주고받고,
>   혼잡제어를 통해 네트워크의 혼잡정도에 따라 데이터의 전송량을 조절

**1️⃣ 재전송을 통한 오류 제어**

<aside>
💡

언제 잘못 전송된 세그먼트가 있음을 인지할까?

1. 중복된 ACK 세그먼트가 도착했을 때
2. 타임아웃이 발생했을 때
</aside>

- 순서번호 담은 세그먼트 → 그에 대한 확인 응답이 담긴 세그먼트 → 다음 순서 번호를 담은 세그먼트 → 그에 대한 확인 응답이 담긴 세그먼트 반복…
- 이때 `중복된 ACK세그먼트를 수신하는 상황`
  → 송신한 세그먼트의 일부가 전송 중 유실되어 중복으로 세그먼트를 수신하는 상황
  ![image.png](attachment:1cfa4637-d6ec-4432-a745-12b0cdb56178:image.png)
- `타임아웃이 발생한 상황`
  → TCP 세그먼트를 송신하는 호스트는 모두 재전송 타이머라는 값을 유지하는데, 호스트는 세그먼트를 전송할 때마다 이 재전송 타이머를 시작한다.
  - 타임아웃: 이 타이머의 카운트다운이 끝난 상황
  - **타임아웃 발생 시점까지 ACK 세그먼트를 받지 못하면, 세그먼트를 재전송**
    ![image.png](attachment:d0e69736-8962-4869-adc6-a04c4ddd2c4d:image.png)
- 파이프라이닝 전송
  - (기본적인 TCP 송수신)’ 순서 번호를 담은 세그먼트를 보내고, 그에 대한 확인 응답을 담은 세그먼트를 받고, 다음 순서번호를 담은 세그먼트를 보내고, 그에 대한 확인 응답을 담은 세그먼트를 받고 반복…
  - `단점`
    - 한 번에 여러 세그먼트를 보낼 수 있는 상황에서도 확인응답을 받기 전까지 보낼 수 없다! **한 번에 하나의 세그먼트만 주고받아야함…**
    - `보완: 파이프라이닝`
      - 확인 응답을 받기 전이라도 여러 메시지를 보내는 방식으로 송신
        ![image.png](attachment:120b492b-e444-4174-b5dc-4d7f767b323b:image.png)

2️⃣ **흐름제어**

> **수신 호스트가 한 번에 받아 처리할 수 있을 만큼만** 전송하는 것.
> 송신 호스트가 수신 호스트의 처리 속도를 고려하며 송수신 속도를 균일하게 맞추는 기능

- **흐름제어의 주체: 수신 호스트**
    <aside>
    💡
    
    어떻게 판단할까?
    
    - 수신 호스트가 한번에 받을 수 있는 전송량은? → **TCP `수신 버퍼의 크기`**
        - 수신된 세그먼트가 애플리케이션 프로세스에 의해 읽히기 전에 임시 저장되는 공간 (커널에 정의되어있음)
    - 송신 호스트가 어떻게 알고 보내줄 수 있을까? → **TCP 헤더의 윈도우 필드의
     `수신 윈도우`**
        - 수신 호스트가 한 번에 처리할 수 있는 수신 윈도우 크기가 명시
        - RWND(Receiver WiNDow, 수신 윈도우)
    </aside>


**3️⃣ 혼잡 제어**

> 많은 트래픽으로 인해 패킷의 처리 속도가 느려지거나 유실될 수 있는 상황

- 흐름 제어의 주체가 수신 호스트였다면,
  **혼잡 제어의 주체: 송신 호스트** - 얼마나 네트워크가 혼잡한지 판단 - 판단된 혼잡도에 따라 세그먼트의 전송량 조절

<aside>
💡

어떻게 판단할까?

- 네트워크 혼잡 기준은? → 세그먼트의 전송 오류를 판단하는 기준과 같다
  - **중복된 ACK 세그먼트가 도착했을 때 | 타임아웃이 발생했을 때**
- 얼만큼을 송신할까? → **`혼잡 윈도우`** - 혼잡 없이 전송할 수 있을 정도의 양 - 크면 전송할 수 있는 세그먼트의 수가 많고, 작으면 네트워크가 혼잡한 상황임 - CWND(Congestion WiNDow, 혼잡 윈도우)
</aside>

- 송신 호스트 입장에서)
  수신 윈도우 크기는 수신 호스트가 TCP 헤더로 알려주지만,
  **혼잡 윈도우의 크기는 송신 호스트가 직접 계산하여 알아내야한다!!**
      → `혼잡 제어 알고리즘`

      - `AIMD`(Additive Increase/Multiplicative Decrease)

          > 합으로 증가, 곱으로 감소
          >
          > - 혼잡 윈도우 1씩 선형적으로 증가
          >     - 세그먼트를 보내고, 그에 대한 응답이 오기까지 혼잡이 감지되지 않을 때
          > - 혼잡 윈도우 절반으로 감소
          >     - 혼잡이 감지될 때
          - RTT: 패킷을 보내고 그에 대한 응답이 수신되기까지의 시간

              → AIMD: RTT마다 1씩 선형적으로 증가시키고, 혼잡이 감지되면 혼잡 윈도우를 절반으로 떨어뜨리는 알고리즘


### TCP의 종료

> TCP 연결 종료: 송수신 호스트가 각자 한 번씩 FIN과 ACK를 주고받음
>
> ➊ [송수신 방향 **A** → **B**] **`FIN** 세그먼트`
>
> - 호스트 A는 FIN 비트가 1로 설정된 FIN 세그먼트를 호스트 B에게 전송합니다.
>
> ➋ [송수신 방향 **B** → **A**] **`ACK** 세그먼트`
>
> - ➊에 대한 호스트 B의 응답입니다.
>   호스트 B는 ACK 세그먼트를 호스트 A에게 전송합니다.
>
> ➌ [송수신 방향 **B** → **A**] **`FIN** 세그먼트`
>
> - 호스트 B는 FIN 세그먼트를 호스트 A에게 전송합니다.
>
> ➍ [송수신 방향 **A** → **B**] **`ACK** 세그먼트`
>
> - ➌에 대한 호스트 A의 응답입니다.
>   호스트 A는 ACK 세그먼트를 호스트 B에게 전송합니다.

![image.png](attachment:5949bd25-4164-4955-bab5-cc8c6a745fa3:image.png)

- `액티브 클로즈`
  - 먼저 연결을 종료하려는 호스트에 의해 수행되는 동작
- `패시브 클로즈`
  - 연결 종료 요청을 받아들이는 호스트에 의해 수행되는 동작

## TCP의 상태 관리

> TCP의 또 다른 중요한 특징: 상태를 유지

- **TCP → 스테이트풀 프로토콜 (stateful protocol)**
  - `상태` state: 현재 어떤 통신 과정에 있는지
    - 현재 TCP 송수신 현황을 판단하고, 디버깅의 힌트로 활용할 수 있음
  ![image.png](attachment:c06e08fc-bf7a-43c5-85c6-b35b82a1ea1b:image.png)

1. 연결이 수립되지 않았을 때 주로 활용되는 상태

- `CLOSED`: 아무런 연결이 없는 상태
- `LISTEN`: 연결 대기 상태
  (쓰리 웨이 핸드셰이크의 첫 단계인 SYN 세그먼트를 대기하는 상태)

2. 연결 수립 과정에서 주로 활용되는 상태

- `SYN-SENT`: 액티브 오픈 호스트가 SYN 세그먼트를 보낸 뒤, 그에 대한 응답인 SYN + ACK 세그먼트 를 기다리는 상태(연결 요청 전송)
- `SYN-RECEIVED`: 패시브 오픈 호스트가 SYN + ACK 세그먼트를 보낸 뒤, 그에 대한 ACK 세그먼트를 기다리는 상태(연결 요청 수신)
- `ESTABLISHED`: 쓰리 웨이 핸드셰이크가 끝난 뒤 데이터를 송수신할 수 있는 상태(연결 수립)
  ![image.png](attachment:6314c873-2225-4933-842a-dcc92b9c1614:image.png)

3. 연결 종료 과정에서 주로 활용되는 상태

- `FIN-WAIT-1`: 액티브 클로즈 호스트가 FIN 세그먼트로 연결 종료 요청을 보낸 상태(연결 종료 요청 전송)
- `CLOSE-WAIT`: FIN 세그먼트를 받은 패시브 클로즈 호스트가 그에 대한 응답으로 ACK 세그먼트를 보낸 후 대기하는 상태(연결 종료 요청 승인)
- `FIN-WAIT-2`: FIN-WAIT-1 상태에서 ACK 세그먼트를 받은 상태
- `LAST-ACK`: CLOSE-WAIT 상태에서 FIN 세그먼트를 전송한 뒤 대기하는 상태
- `TIME-WAIT`: 액티브 클로즈 호스트가 마지막 ACK 세그먼트를 전송한 뒤 접어드는 상태

![image.png](attachment:40b7d194-770b-4f7a-ac77-b923c437eaa3:image.png)

- 유의할 점
  - 패시브 클로즈 호스트가 마지막 ACK 세그먼트를 수신하면 CLOSED 상태가 되는 반 면, TIME-WAIT 상태에 접어든 액티브 클로즈 호스트는 **일정 시간을 기다린 뒤 CLOSED 상태**
  - 왜 기다릴까?
    - 마지막 ACK 세그먼트가 올바르게 전송되지 않았을 수 있고, 이 경우 재전송이 필요하기 때문
- cf) `CLOSING` 상태
  - 서로가 FIN 세그먼트를 보내고 받은 뒤, 각자 그에 대한 ACK 세그먼트를 보냈지만, 아직 자신의 FIN 세그먼트에 대한 ACK 세그먼트를 받지 못했을 때
  - 다음과 같이 양쪽이 동시에 연결 종료를 요청하고 서로의 종료 응답을 기다릴 경우에 발생하는 상태
