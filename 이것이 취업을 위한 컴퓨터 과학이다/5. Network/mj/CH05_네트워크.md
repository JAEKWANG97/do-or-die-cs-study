# CH05. 네트워크

## 📌 핵심 개념 요약

- LAN, WAN, 패킷 교환
- 주소 전송 방식
- OSI 7계층, 캡슐화와 역캡슐화
- 물리 계층과 데이터 링크 계층
  - 이더넷, 유무선 통신매체, 허브와 스위치
- 네트워크 계층
  - IP(목적, 특징, 구조, 공인/사설 IP 주소, 정적/동적 할당, ARP)
- 전송 계층
  - TCP와 UDP (목적, 특징, 포트, 연결 수립, 오류/흐름/혼잡 제어, 종료, 상태관리)

## 💡 면접 예상 질문

- OSI 7계층에 대해 설명해주세요
- 캡슐화와 역캡슐화에 대해 설명해주세요
- 패킷이 무엇인가요?
- 주소 전달 방식에는 어떤게 있나요?
- MAC 주소가 무엇인가요?
- 허브와 스위치의 차이점은 무엇인가요?
- IP의 목적과 특징은 무엇인가요?
- 단편화가 무엇인가요?
- 오늘날 네트워크 환경에서 IP 단편화가 잘 발생하지 않는 이유는 무엇인가요?
- 서브넷 마스크를 사용하는 이유가 무엇인가요?
- 정적 IP 주소를 부여할 때 **필수적으로 설정해야 하는 네 가지 값**은 무엇인가요? 각각 어떻게 사용되는지 한 흐름으로 설명해주세요.
- ARP가 무엇인가요?
- 순서 번호와 확인 응답 번호가 무엇인가요?
- 파이프라이닝이 무엇인가요?
- 흐름 제어의 주체는 무엇이고, 어떻게 판단하나요?
- 혼잡 제어의 주체는 무엇이고, 어떻게 판단하나요?
- 혼잡 제어 알고리즘엔 어떤 것이 있나요?

## ❓스터디에서 논의하고 싶은 질문

-

## 🔗 참고 자료

- **[책]** 이것이 취업을 위한 컴퓨터 과학이다 with CS 기술 면접

# 1. 네트워크의 큰 그림

## 네트워크의 기본 구조

- 네트워크는 노드와 간선으로 이루어진 그래프
  - 네트워크 기기 (노드)
  - 정보를 주고받는 유무선의 통신매체 (간선)
- `네트워크 토플로지`
  - 노드와 노드 사이의 연결구조
  - 망형/ 트리형/ 링형/ 성형/ 버스형(선형)
- `호스트`
  - 네트워크의 가장자리에 위치하면서 네트워크를 통해 주고받는 정보를 최초로 송신하고 최종수신하는 노드
    - Ex) 노트북과 구글의 서버 컴퓨터가 각각 호스트로서 정보를 주고 받음 (웹 페이지를 가져달라는 요청과 응답)
- `클라이언트`(요청) ↔ `서버`(응답)
- `스위치`와 `라우터`, `공유기` (중간노드로써 호스트가 주고받는 정보들을 원하는 수신지까지 안정적으로 전송하는 역할)

---

### LAN과 WAN

> 전 세계에는 하나의 네트워크만 존재할까?
> 당연히 아니다! 네트워크는 규모에 따라 LAN과 WAN으로 나뉜다

- `LAN`
  - Local Area Network
  - 가정이나 기업처럼 비교적 가까운 거리를 연결하는 한정된 공간에서의 네트워크
  - 같은 LAN에서만 통신이 이루어지는 것은 아니고, LAN 간의 통신도 빈번하다
- `WAN`
  - Wide Area Network
  - 원거리 네트워크
  - WAN을 통해 LAN 간의 통신이 이루어짐 (인터넷을 가능하게 하는…)
  - WAN은 일반적으로 `ISP`(Internet Service Provider)라는 인터넷 서비스 업체가 구축하고 관리한다

### 패킷 교환 네트워크

> 서로 다른 네트워크에 있는 두 호스트가 파일을 주고받는 경우를 생각해보자
>
> - 네트워크를 통해 주고받는 데이터는 한 번에 송수신 되지 않고 여러 데이터로 쪼개져서 송수신된다.
>   → 송수신되는 데이터의 단위: `패킷`

- 이렇게 네트워크는 패킷 단위로 정보를 송수신, 수신지에서 재조립하는 ‘패킷 교환 네트워크’가 대부분!
- 패킷의 구성
  - 페이로드와 헤더 (+트레일러)
    - `페이로드`: 패킷에서 송수신하과 하는 데이터
    - `헤더`와 `트레일러`: 패킷의 부가정보

### 주소와 전송 방식

> 두 호스트가 패킷을 주고받을 때, 올바르게 정보를 주고 받기 위해서는 서로를 특정할 수 있는 정보, 즉 주소가 필요하다
>
> - `주소`: 패킷의 헤더에 명시되는 정보 (ex. IP주소, MAC주소)

- `전송방식`
  - 주소를 바탕으로 다양한 수신지 유형을 지정해 패킷을 보낼 수 있다.
  - `유니캐스트`: 송신지와 수신지가 일대일로 메시지를 주고받는 전송 방식
  - `브로드캐스트`: 네트워크상의 모든 호스트에게 메시지를 전송하는 전송 방식
    - 브로드캐스트 도메인: 브로드캐스트가 전송되는 범위
      - 호스트가 같은 브로드캐스트 도메인에 속해 있는 경우, 같은 LAN에 속해있다고 간주
  - `멀티캐스트`: 네트워크 내의 동일 그룹에 속한 호스트에게만 전송하는 방식
  - `애니캐스트`: 네트워크 내의 동일 그룹에 속한 호스트 중 가장 가까운 호스트에게 전송하는 방식

## 두 호스트가 패킷을 주고받는 과정

> 호스트가 서로 주고받는 정보를 이해하기 위한 규칙인
> 프로토콜과 네트워크 참조 모델의 개념, 패킷을 주고 받는 과정에 대해 알아보자

### 프로토콜

- 만약 두 호스트가 서로 다른 LAN에 속해있어서 주고받는 패킷이 네트워크 장비를 거친다고 할 때, 이 패킷을 서로 이해할 수 있어야함.
  - 호스트뿐만 아니라 패킷이 거쳐 갈 네트워크 장비 역시 패킷의 내용을 이해할 수 있어야 함 → 프로토콜이라는 규칙이 필요함!
- `프로토콜`: 네트워크에서 통신을 주고받는 노드 간의 합의된 규칙이나 방법
  - 프로토콜이 존재하는 이유에 집중할 것!
    - IP (네트워크 간의 주소를 지정)
    - ARP (IP주소와 MAC주소를 대응)
    - HTTPS (HTTP에 비해 보안상 안전)
    - TCP (UDP에 비해 신뢰성이 높음)
  - 목적과 특징이 다른 프로토콜로 구성된 패킷의 내용도 달라질 수 있다.

### 네트워크 참조 모델

- 네트워크도 주고받는 과정에서의 순서가 정해져있음!
  - 이렇게 통신이 이루어지는 단계를 계층적으로 표현한 것을 네트워크 참조 모델이라고 한다.
- `OSI모델`
  - 국제 표준화 기구에서 만든 네트워크 참조 모델
    (통신 단계를 7개의 계층으로 나눔)
        ![image.png](attachment:b686d546-f4b5-4637-88b1-75a39e267f15:image.png)

        1. **물리 계층**
            - 최하위 계층, 비트 신호를 주고 받음(0,1)
            - 유무선 통신 매체를 통해 이런 신호를 운반
        2. **데이터 링크 게층**
            - 같은 LAN에 속한 호스트끼리 올바르게 정보를 주고받기 위한 계층
            - 같은 네트워크에 속한 호스트를 식별할 수 있는 주소 (`MAC주소`)를 사용하고, 물리 계층에서 주고받는 정보 오류를 체크한다
            - 하드웨어와 밀접하게 맞닿아 있는 계층
        3. **네트워크 계층**
            - 네트워크 간 통신을 가능하게 하는 계층
            - LAN을 넘어 다른 네트워크와 통신을 주고받기 위해 필요한 계층 (`IP주소`) → `IP 프로토콜` 사용
        4. 전송 계층
            - 네트워크를 통해 송수신되는 패킷이 신뢰성있게 전송되도록 하는 계층 → `TCP/UDP 프로토콜` 사용
            - `포트`라는 정보를 통해 응용 프로그램과의 다리 역할을 수행하기도함
        5. 세션 계층
            - 응용 프로그램 간의 연결 상태를 의미하는 `세션`을 관리하기 위한 계층
            - 연결 상태를 유지하거나 새롭게 생성, 필요하다면 끊는 역할
        6. 표현 계층
            - 인코딩과 압축, 암호화같은 작업을 수행
            - 세션계층과 표현계층은 두 계층을 명확하게 구분하지 않거나 응용 계층에 포함하여 간주하는 경우가 많다.
        7. 응용 계층
            - 사용자와 가장 밀접하게 맞닿아 있어 여러 네트워크 서비스를 ㅈ공하는 계층, 중요한 프로토콜 다수 포함

                → `HTTP, HTTPS, DNS 프로토콜` 등

- `TCP/IP 모델`
  - `TCP/IP` 4계층이라고도 불린다.
    - OSI(네트워크 이론적 기술을 목적)에 비해 구현과 프로토콜에 중점을 둔 네트워크 참조 모델
    1. 네트워크 액세스 계층
       - 링크 계층, 네트워크 인터페이스 계층이라고도 불림
       - OSI모델의 데이터 링크 계층과 유사
    2. 인터넷 계층
       - OSI 모델의 네트워크 계층과 유사
    3. 전송 계층
       - OSI 모델의 전송 계층과 유사
    4. 응용계층
       - OSI 모델의 세션/표현/응용계층을 합친 것과 유사

![image.png](attachment:f98f9002-e8cc-430a-b443-4f4fb7551254:image.png)

### 캡슐화와 역캡슐화

- 패킷의 송수신 과정 중 송신과정에서는 캡슐화, 수신과정에서는 역캡슐화가 이루어진다.
  - 네트워크 계층 구조를 통한 송수신과 패킷의 구조를 생각해보자
  - 송신) 상위 계층으로부터 내려받은 패킷을 페이로드로 삼아, 각 계층에 포함된 프로토콜의 각기 다른 목적과 특징에 따라, 헤더 혹은 트레일러를 덧붙인 다음 하위계층으로 전달
    → `캡슐화`: 송신 과정에서 헤더(및 트레일러)를 추가해나가는 과정
        → `역캡슐화`: 캡슐화 과정에서 붙인 헤더(및 트레일러)를 각 계층에서 확인한 뒤 제거하는 과정

![image.png](attachment:90b4981b-30a7-41c7-9fdb-65f017c11bf7:image.png)

![image.png](attachment:71f22976-49b2-4f15-8a35-459b9e12591c:image.png)

# 2. 물리 계층과 데이터 링크 계층

> 이더넷, 이더넷 프레임, 통신 매체, 네트워크 장비

## 이더넷

- 물리 계층과 데이터 링크 계층에는 LAN 내의 호스트들이 올바르게 정보를 주고 받을 수 있게 해주는 다양한 기술이 포함되어 있음
  - `이더넷`: 통신 매체를 통해 신호를 송수신하는 방법, 데이터 링크 계층에서 주고받는 데이터(프레임) 형식 등이 정의된 기술
- 이더넷 표준
  - IEEE 802.3 국제 표준화 기술
    - 국제 표준화? 서로 다른 제조사의 네트워크 장비라 하더라도 LAN내의 모든 컴퓨터가 문제없이 호환되는 이유!
  - 기억해두면 좋을 것
    1. 오늘날의 (유선) LAN 대부분이 이더넷 표준을 따르기 때문에 대다수의 LAN장비들이 특정 이더넷 표준을 따른다
    2. 이더넷 표준이 달라지면 통신 매체를 비롯한 신호 송수신 방법, 최대 지원 속도도 달라질 수 있다.
- 이더넷 `프레임`: 이더넷 기반의 네트워크에서 주고받는 프레임
  - 프레임이 구성하는 정보 (5가지)
    ![image.png](attachment:e903c8b5-956f-4f14-b6e3-f6ca6073f1d9:image.png)
    1. 프리앰블 preamble
       - 송수신지 동기화를 위해 사용되는 8바이트(64비트) 크기의 정보
       - 프리앰블의 첫 7바이트: 10101010, 마지막 바이트: 10101011
         이 프리앰블 비트를 통해 현재의 이더넷 프레임이 수신되고 있다는 사실을 알 수 있다.
    2. 송수신지 MAC 주소
       - `MAC 주소`: 프레임에서 가장 중요한 정보, 송신지와 수신지를 특정할 수 있는 6바이트(48비트) 길이의 주소 (물리적 주소)
       - Ex) ab:cd:ab:cd:00:01
       - MAC 주소는 물리적 주소로 네트워크 인터페이스마다 하나씩 부여되는 주소
         - 네트워크 인터페이스: 네트워크를 향하는 통로, 연결 매체와의 연결 지점, 보통 NIC라는 장치가 담당
         - NIC와 네트워크…
           - NIC가 여러 개인 상황처럼 네트워크 인터페이스가 여럿이라면 한 호스트가 여러 개의 MAC주소를 가질 수 있음
    3. 타입/길이
       - 필드에 명시된 크기가 1500이하(16진수 05DC)이면 프레임 크기를 나타내고, 1536이상(16진수 0600)이면 타입을 나타냄
       - 타입: 캡슐화된 상위 계층의 정보
         - Ex) IPv4가 캡슐화된 정보 운반 → 타입:16진수 0800, ARP 프로토콜이 캡슐화된 정보 운반 → 타입: 16진수 0806
    4. 데이터
       - `페이로드`(상위 계층으로 전달하거나 전달받을 데이터가 명시)가 명시
       - 데이터 필드에 포함될 수 있는 데이터의 최대 크기가 정해져있음 (기준: 1500바이트 → 네트워크 계층 패킷(헤더+페이로드)의 최대 크기: MTU)
         (사실 더 큰 데이터를 포함할 수있는 프레임도 있음: 점보 프레임)
    5. FCS Frame Check Sequence
       - 프레임의 오류가 있는지의 여부를 확인하기 위한 필드
       - CRC (Cyclic Redundancy Check)라는 오류 검출용 값 명시
         - 송신지에서 전송할 데이터, 더불어 전송할 데이터에 대한 CRC 값을 계산하여 보내면 수신지에서는 전달받은 데이터에 대한 CRC값을 계산해 대조 (같아야 오류없음)

## 유무선 통신 매체

> 호스트가 아무리 빠르게 데이터를 처리할 수 있어도 그를 뒷받침하는 연결 매체의 성능이 뒷받침되지 않으면 아무런 효용이 없음!

### 유선 매체 - 트위스티드 페어 케이블

- 구리선을 통해 전기적으로 신호를 주고받는 통신매체
- 성능 → 카테고리를 통해 알 수 있음 (Cat)
  - 카테고리에 따라 대응되는 이더넷 표준, 표준에 따른 최대 지원 속도 다를 수 있음
  - 카테고리는 트위스티드 페어 케이블의 성능을 구분하는 일종의 등급 역할
- 노이즈(잡음), 포일로 감싸 노이즈 방지, 차폐(구리선 주변을 보호해 노이즈를 감소시키는 방식)
- 브레이크 실드로 노이즈를 감소시킨 케이블 (STP), 포일 실드로 노이즈를 감소시킨 케이블(FTP), 구리선만 있는 케이블(UTP)
  - 더 상세한 표기: []/[]TP에서 []에 U,S,F를 명시할 수 있음

### 무선 매체 - 전파와 WiFi

> 진동수 2.4GHz, 5GHz 정도는 알아볼까?

- 와이파이
  - 무선 LAN에서 가장 대중적으로 사용되는 기술
  - IEEE 802.11 표준을 따르는 무선 LAN 기술. 뒤에 붙는 알파벳으로 표준 규격을 구분 (Wi-Fi 4~7)
  - 같은 주파수 대역을 사용하는 여러 무선 네트워크가 존재할 수 있음. 즉, 같은 지역 내에 2.4GHz/5GHz 대역을 사용하는 무선 네트워크가 여러 개 존재할 수 있다는 말
    - 전파 통신을 주고받을 때 주파수 대역이 겹치면 신호의 간섭이 발생할 수 있음 → 서로 다른 무선 네트워크를 구분하기 위해 `채널`이라는 하위 주파수 대역을 세분화
  ![image.png](attachment:cf6e8f07-59cf-4edf-be3c-6519bbd202a6:image.png)
  - 2.4GHz 대역의 채널에서 1,6,11 채널의 주파수는 서로 중첩되지 않음 → 아무리 많은 통신이 이루어지더라도 신호 간섭을 ㅇ니한 성능 저하가 발생하지 않는다
  - 무선 네트워크의 성능 저하를 방지하려면 신호가 중첩되지 않는 채널을 사용하는 것이 중요!
- AP와 SSID
  - AP: 여러 무선 통신 기기를 연결해 무선 네트워크를 구성하는 장비(ex. 무선 공유기)
  - SSID: 서비스 셋(AP를 중심으로 구성된 무선 네트워크)을 식별하는 정보 (ex. 와이파이)

### 네트워크 인터페이스: NIC

- 네트워크 상에서 노드와 통신 매체가 연결되는 지점 (노드와 네트워크 사이의 통로)
- 노드가 네트워크를 통해 송수신하는 정보는? 네트워크 인터페이스를 거친다.
  - 네트워크 인터페이스마다 물리적 주소인 MAC주소가 부여되고, `NIC`(Network Interface Controller)라는 **하드웨어**가 네트워크 인터페이스의 역할을 담당
    - 요즘엔 마더보드에 내장된 NIC를 사용할 가능성이 높다
- NIC가 하는 일
  - 통신 매체의 신호를 호스트가 이해하는 프레임으로 변환하거나 호스트가 이해하는 프레임을 통신 매체의 신호로 변환하는 역할
  - MAC 주소를 토대로 잘못 전송된 패킷이 없는지 확인
- NIC 동작 방식
  - 동작하는 방식도 입출력 과정과 다르지 않다.
    - 패킷을 송신하는 동작을 출력, 수신하는 동작을 입력
  - 각각의 성능이 다르고, 지원속도가 다르며 네트워크의 속도에 큰 영향을 끼침
- 티밍과 본딩
  - 고가의 NIC를 구비하는 방법 외에도 NIC 단계의 성능 향상을 위해 사용하는 방식이 있음
    (여러 물리적인 NIC를 마치 하나의 고속 NIC처럼 구성)
  - 저성능의 여러 물리적인 입출력장치를 고성능의 논리적 입출력장치 하나로 묶어 사용한다는 점에서 컴퓨터구조에서 학습한 RAID와 유사
  - 티밍(윈도우)과 본딩(리눅스)을 통해 송수신 성능을 향상시킬 수 있고, 하나의 NIC에 문제가 발생하더라도 다른 NIC를 통해 송수신되도록 하여 안정적으로 송수신될 수 있음!

## 허브와 스위치

> 물리 계층과 데이터 링크 계층의 중간 노드

- 요즘 허브보다는 스위치를 사용하는 경우가 많음
  - 허브: 전이중/반이중 통신 → 브로드캐스트 통신의 특징을 잘 보여주는 네트워크 장비

### 물리 계층의 `허브`

![image.png](attachment:3bb4cc97-1a66-4208-ad1b-9494863edc0a:image.png)

> 물리 계층의 대표적인 네트워크 장비: `허브`

- 여러 대의 호스트를 연결하는 장치
  - 리피터 허브, 이더넷 허브(이더넷 네트워크의 허브)라고도 불림
- `포트`: 허브에서 케이블의 커넥터가 꽂히는 부분 (통신 매체를 연결하는 지점)
- 허브의 2가지 특징
  1. **전달받은 신호를 모든 포트로 내보낸다**
  2. **`반이중 모드`로 통신한다**
     - 반이중 모드: 송신 또는 수신을 번갈아가면서 수행해야하는 통신 방식
       - 동시 송수신이 불가능 (무전기 처럼!)
     - 전이중 모드: 동시 송수신이 가능한 상태
       - 데이터 링크 계층의 `스위치`는 전이중 모드 지원
  ![image.png](attachment:ea8f23fa-ec5f-4ab4-8c62-0a2a90e21d25:image.png)
- 반이중모드로 통신하면 한 호스트가 허브로 정보를 전달하면 다른 호스트는 정보를 전송할 수 없다! → 동시에 메시지를 보내면 충돌!
  - 충돌이 발생할 수 있는 영역: 콜리전(충돌) 도메인
    → 허브에 연결된 모든 호스트

### 데이터 링크 계층의 `스위치`

![image.png](attachment:9ded0ef4-d38b-4e6f-a10a-467ecafe721a:image.png)

> 허브의 한계를 보완하기 위한 네트워크 장비: 스위치
>
> 전이중모드 지원!

- 2계층에서 사용한다는 점에서 L2스위치라고도 부른다. (상위 계층에서 사용하는 L3,L4스위치도 있음)
- **허브와 다른점**
  - **전달받은 신호를 목적지 호스트가 연결된 포트로만 내보냄!**
    - `MAC주소학습` 기능이 있기 때문!
  - **전이중 모드 지원 (허브와 비교해 콜리전 도메인이 좁다)**
- 스위치의 주요 기능
  - `MAC주소 학습`
    - 프레임 헤더에는 MAC주소가 명시되는데 스위치는 데이터링크 계층에 속한 장비이므로 MAC주소를 이해할 수 있다
    - (포트, 연결된 호스트의 MAC주소)의 대응관계를 `MAC 주소 테이블`의 형태로 메모리에 저장
      ![image.png](attachment:6cdd3049-1a66-4a7a-afd0-93af8ba04e93:image.png)
  - `VLAN (가상의 LAN)`
    - 같은 위치에 연결된 모든 호스트를 하나의 네트워크로 간주하고 싶지 않을 때, 여러 논리적인 네트워크로 나누고 싶을 때 사용
    - 서로 다른 VLAN에 속해있으면 서로 다른 네트워크로 간주되고, 브로드캐스트 도메인도 겹치지 않아 서로의 브로드캐스트 메시지가 도달하지 않는다. → 서로 통신을 주고받으려면 네트워크 계층 이상의 장비가 필요하다
      ![image.png](attachment:5c3288d1-c137-4a94-8ceb-e75fb2b16925:image.png)

# 3. 네트워크 계층 - IP

> LAN을 넘어서 다른 네트워크와 통신을 주고받으려면 네트워크 계층 이상의 기술이 필요
> → 네트워크 계층의 핵심적인 프로토콜: `IP`

## IP의 목적과 특징

- 목적은 2가지!
  1. `주소 지정`: 네트워크 간의 통신 과정에서 **호스트를 특정하는 것**
  2. `단편화`: 데이터를 **여러 IP 패킷으로 올바르게 쪼개어** 보내는 것
- 특징
  1. **신뢰할 수 없는 통신**
  2. **비연결형 통신**

### 주소 지정과 단편화

1. `주소 지정`

   - IP주소를 통해 이루어지며, IP 패킷 헤더를 통해 알 수 있다
     - IP 패킷 헤더에서 주소 지정과 관련한 필드를 확인해보자
       - `송신지 IP 주소`
       - `수신지 IP 주소`
     - 하나의 IP는 총 4바이트의 크기로 구성되고 숫자당 8비트로 표현되므로
       0~~255범위의 10진수 4개로 표현됨
     - 각각의 10진수를 .으로 구분, 구분된 하나의 10진수는 옥텟
       ex) 192.168.0.1
       - 192, 168, 0, 1 → 각각 하나의 옥텟
         ![image.png](attachment:e00d4955-2ae0-433c-8118-e0275b3cc037:image.png)
   - 패킷을 올바르게 전송하기 위해서는 MAC주소와 IP주소가 모두 필요
     - MAC주소 (수신인과 발신인)
     - IP주소 (수신주소와 발신주소) → 우선적으로 활용
   - `라우터`: IP 주소를 기반으로 패킷의 최적 경로를 결정하여 목적지까지 전달
     - 공유기도 라우터의 일종

   > IPv4와 IPv6
   >
   > - `IPv4`주소는 총 32비트로 표현 → 2^32 → 약 43억개의 할당가능한 주소
   >   - 이런 IPv4 주소 고갈 문제로 등장한게 `IPv6`
   > - IPv6주소는 16바이트(128비트)로 주소를 표현 → 무한에 가까운 수
   >   - `IPv4`와 다르게 :으로 구분된 8개의 그룹의 16진수

2. `단편화`
   - MTU: Maximum Transmission Unit
     - 최대 전송 단위.
     - 전송하고자 하는 IP 패킷 (IP 헤더와 페이로드)의 크기가 MTU라는 단위보다 클 경우,
       **패킷을 MTU 이하의 여러 패킷으로 쪼개서 전송하고, 이렇게 쪼개서 전송된 패킷들은 수신지에서 재조합**
     - 일반적으로 1500바이트. 프레임을 통해 주고받을 수 있는 최대 페이로드의 크기
     ![image.png](attachment:4bf20ef9-14da-432c-9b35-2583b1c40042:image.png)
     - IP 패킷 헤더에서 **단편화 관련 필드**를 확인해보자
       1. `식별자`
          - 어떤 데이터에서 쪼개진 패킷인지를 식별하기 위해 사용되는 필드
          - 같은 정보에서 쪼개진 패킷들은 같은 식별자를 공유
       2. `플래그`

          - 3비트로 구성된 필드로, 첫 번째 비트를 제외한 나머지 2개의 비트는 각각 DF와 MF
          - 첫 번째 비트는 항상 0으로 설정되어 오늘날 사용되지 않고, DF는 ‘IP 단편화 를 수행하지 말라(Don’t Fragment)’, MF는 ‘단편화된 패킷이 더 있다(More Fragment)’는 표시를 남기기 위한 비트입니다.

          ![image.png](attachment:b5fbbd7a-7ecf-4207-927b-95fba801745d:image.png)

       3. `단편화 오프셋`
          - 특정 패킷이 초기 데이터에서 얼마나 떨어져 있는지가 명시된 필드
          - 단편화되어 전송되는 패킷을 목적지에서 재조합하기 위해 패킷의 올바른 순서를 나타내는데 사용됨

### IP의 특징- 신뢰할 수 없는 통신과 비연결형 통신

- 신뢰할 수 없는 프로토콜, 비연결형 프로토콜
  - `신뢰할 수 없는 프로토콜`: 패킷이 수신지까지 제대로 전송되었다고 보장하지 않는 프로토콜
    - **패킷이 유실되거나 목적지에 순서대로 전송되지 않더라도 이에 대한 조치를 취하지 않는 것**
    - 신뢰성이 낮은 통신, 최선형 전달이라고도 함
  - `비연결형 프로토콜`
    - 패킷을 주고받기 전에 **사전 연결 과정을 거치지 않는다**
    - 상대 호스트의 수신 가능 여부는 고려하지 않고, 수신지를 향해 패킷을 전송할 뿐
    - (`↔` 패킷을 주고받기 전에 송수신지 간의 연결을 맺는 프로토콜: `TCP`)
      - TCP는 송수신지 간의 연결 설정을 통해 패킷을 주고받을 호스트 간에 송수신 준비가 되어있는지를 확인할 수 있다.
- Cf) IP 단편화 피하기 - 경로 MTU 발견
  - IP의 본래 목적은 주소 지정과 단편화!
    - 사실 오늘날의 네트워크 환경에선 IP단편화가 잘 발생하지 않는데, 그만큼 네트워크 성능이 발전하기도 했고, IP단편화가 되도록 발생하지 않는 것이 좋다
  - `잦은 IP 단편화`
    - 네트워크에 여러 악영향
    - 단편화된 패킷들이 많아지면 전송해야할 패킷들의 헤더들이 많아지기 때문에 **불필요한 트래픽 증가와 대역폭 낭비**를 초래한다.
    - 단편화된 패킷을 **재조립하는 과정에서 발생하는 부하**도 성능저하로 이어질 수 있다.
  - IP 단편화를 피하는 방법?
    - 패킷을 주고받는 경로에 존재하는 모든 호스트의 처리 가능한 MTU크기를 고려해야한다!
    - `경로MTU`: IP 단편화없이 주고받을 수 있는 최대 크기
    - 이렇게 주고받을 수 있는 경로 MTU를 구하고 해당 크기만큼 송수신하여 IP단편화를 회피하는 기술 → 경로MTU발견

## IP주소의 구조

- IP의 주요 목적이 주소 지정인 만큼 IP 주소는 중요한 개념이겠지!
- 여기에서 다시 네트워크 계층에서 하는 일을 생각해보면, LAN간의 통신을 가능하게 하고, 이는 IP주소 기반으로 이뤄진다고 했었다.
- 하나의 IP 주소는 0~255범위의 10진수 4개로 표기되며,
  - `네트워크 주소`: 네트워크ID, 네트워크 식별자 등으로 불리며, 호스트가 속한 네트워크를 특정하기 위해 사용됨
  - `호스트 주소`: 호스트ID, 호스트 식별자 등으로 불리며, 네트워크에 속한 호스트를 특정하기 위해 사용됨
- 네트워크 주소와 호스트를 표현하는 크기는 유동적일 수 있음
  - 그럼 각각 어느정도가 적당할까?

### 클래스풀 주소 체계

- 네트워크 주소와 호스트 주소의 크기를 유동적으로 구분할 수 있는데
  - 사실 상황에 따라 적당한 정도가 다르다!
  - 이러한 고민을 해결하기 위해 생겨난 개념이 IP주소의 **`클래스`**
- `클래스`: 네트워크의 크기에 따라 유형별로 IP주소를 분류하는 기준
  - 따라서 어떤 클래스에 속한 IP주소인지를 알면, 네트워크부분과 호스트부분의 크기가 어느 정도의 크기인지 알 수 있다
  - 종류
    - A,B,C,D,E 5종류
      - A,B,C → 크기별 IP주소 분류에 사용되는 클래스
      - D,E → 멀티캐스트를 위한 클래스
    → 클래스를 바탕으로 IP주소를 관리하는 주소체계 → 클래스풀 주소 체계
- A
  - 네트워크 주소: 0으로 시작해 1옥텟
  - 호스트 주소: 3옥텟
  - IP주소표현의 가능범위: 0.0.0.0 ~ 127.255.255.255
    → 상대적으로 가장 많은 호스트를 할당할 수 있는 클래스
- B
  - 네트워크 주소: 10으로 시작해 2옥텟
  - 호스트 주소: 2옥텟
  - IP주소표현의 가능범위: 128.0.0.0 ~ 191.255.255.255
- C
  - 네트워크 주소: 110으로 시작해 3옥텟
  - 호스트 주소: 1옥텟
  - IP주소표현의 가능범위: 192.0.0.0 ~ 255.255.255.255

![image.png](attachment:116c57ae-26eb-4521-a4e9-8df9ef4e3b8e:image.png)

- 네트워크/브로드캐스트 주소
  - 호스트 주소가 전부 0인 IP주소 → 네트워크 자체를 의미하는 주소
  - 호스트 주소가 전부 1인 IP주소 → 브로드캐스트를 위한 주소
  - 이러한 주소는 호스트 주소 할당에 사용할 수 없다. (호스트 주소 공간을 모두 사용할 수 있는 것은 아님)
- 예약 주소
  - 특수한 목적을 위해 예약된 IP주소도 있음
  ![image.png](attachment:618937b0-3328-49b3-bd6f-ebdf2b7c5718:image.png)
  - 루프백 주소: 자기 자신을 가리키는 특별한 주소
    - 루프백 주소로 전송된 패킷은 자기 자신에게 되돌아오므로 자기 자신을 마치 호스트인 양 간주하여 패킷을 전송할 수 있다
    - Ex) 로컬호스트

### 클래스리스 주소 체계와 서브넷 마스크

- 클래스풀 주소 체계에서는 클래스별 네트워크 크기가 고정되어있었다.
  (A,B,C 각각 8,16,24비트)
- 이때는 고정된 크기 외에 다른 크기의 네트워크를 구성할 수 없어 IP주소가 낭비될 수 있다는 한계가 있다
  - Ex) 상대적으로 호스트 할당 주소가 적은 C클래스 주소를 다 사용했다면 어쩔 수 없이 B클래스 주소를 이용해 IP주소를 낭비할 수 있는 문제
- 해결) `클래스리스 주소 체계`
  - 클래스를 이용하지 않고, 클래스풀 주소 체계보다 더 정교하고 유동적으로 네트워크 영역을 나누는 수단
  - 그럼 어떻게 네트워크/호스트 주소 구분?? → `서브넷 마스크`
  - `서브넷 마스크`: IP주소 상에서 네트워크 주소를 1로 표기하고, 호스트 주소를 0으로 표기한 비트열. 즉, 서브넷을 구분하는 비트열
    - A,B,C 클래스의 기본 서브넷 마스크
      ![image.png](attachment:dfb84958-3c08-4678-8e50-4cc2af75c174:image.png)
    - 서브넷 마스크와 IP 주소 간에 비트 AND연산을 수행하면 IP 주소 내의 네트워크 주소를 알아낼 수 있다.
      ![image.png](attachment:3f44ce52-a011-46cc-8175-9f7ff2b9ae6d:image.png)
  - `서브네트워크`: IP주소에서 네트워크 주소로 구분할 수 있는 네트워크의 부분집합 (=서브넷)
  - `서브네팅`: 서브넷 마스크를 이용해 원하는 크기로 클래스를 더 잘게 쪼개어 사용하는 것
- Cf) CIDR표기
  - 또 다른 서브넷 마스크 표기법
  - 10진수로 직접 표기하는 방법이 아닌, IP주소/서브넷 마스크 상의 1의 개수의 형식으로 표기
  - IP주소와 서브넷마스크를 함께 표현할 수 있는 간단한 표기

## 공인 IP 주소와 사설 IP 주소

- 호스트의 IP 주소 확인하기
  - 윈도우에서 ‘ipconfig/all’을 입력하거나 맥OS, 리눅스에서 ‘ifconfig’ 명령어를 입력
  - 검색 사이트에서 검색
  - 이때 두 방식으로 확인한 IP 주소가 다른 경우가 많을 것!
    - 왜지? 고유한 IP 주소는 `공인 IP 주소`라고 하고,
      고유하지 않은 IP 주소는 `사설 IP 주소`
- `공인 IP 주소`
  - 전 세계에서 고유한 IP 주소
  - 인터넷을 비롯한 네트워크 간 통신에서 사용되는 IP 주소 (검색 사이트를 통해 확인했던)
    - 검색 사이트의 서버와 패킷을 주고받으려면, 호스트가 속한 **네트워크 밖에서 사용할 공인 IP 주소**를 사용해야 하기 때문입니다.
    - 어디에서 **할당**받을까? → ISP나 공인 IP 주소 할당 기관을 통해
- `사설 IP 주소`
  - 외부 네트워크에 공개되지 않은 네트워크(사설 네트워크)에서 사용하기 위한 IP 주소
  - 어디에서 **할당**받을까? → 일반적으로 라우터(공유기)를 통해 할당됨
    - 공유기(라우터)를 중심으로 구성된 LAN 대부분은 사설 네트워크에 해당함
  - 사설 IP 주소로 예약된 IP 주소 공간이 있다!
    - 10.0.0.0/8 (10.0.0.0 ~ 10.255.255.255 )
    - 172.16.0.0/12 (172.16.0.0 ~ 172.31.255.255 )
    - 192.168.0.0/16 (192.168.0.0 ~ 192.168.255.255 )
  - 해당 호스트가 속한 사설 네트워크상에서만 유효한 주소이므로 얼마든지 다른 네트워크상의 사설 IP 주소와 중복될 수 있다

## IP 주소의 할당

> 호스트에 IP주소를 할당하는 방법

1. 정적 할당 → 직접 수작업으로 IP주소를 부여
2. 동적 할당

---

### 정적 할당

- 정적 IP 주소 부여를 위해 필요한 값은?
  - IP 주소와 서브넷 마스크, 게이트웨이(라우터) 주소, DNS 주소 등
  - 운영 체제에 관계없이 대체적으로 유사
- `게이트웨이`: 일반적으로 서로 다른 네트워크를 연결하는 하드웨어적/소프트웨어적 수단
  - 기본 게이트웨이는 호스트가 속한 네트워크의 외부로 나가기 위한 첫 기본 경로 (출입문 역할)
  - 네트워크 외부와 연결된 라우터의 주소를 의미하는 경우가 많음
- `DNS주소` : 호스트가 도메인 네임을 토대로 IP 주소를 알아내기 위해 질의하는 서버의 주소
  - 호스트끼리 패킷을 주고받기 위해서는 IP 주소가 사용되지만, 통신을 주고받는 모든 호스트의 IP 주소를 기억하기는 어려움
  - IP 주소에 대응되는 기억할 수 있는 문자열(→`도메인 네임`)로 호스트를 식별
    - ex) ‘[google.com](http://google.com/), [hanbit.co.kr](http://hanbit.co.kr/), [minchul.net](http://minchul.net/)’ 등
  - **대응되는 IP 주소를 알아내려면 <도메인 네임, IP 주소> 쌍을 저장하는 서버에 질의**
    ![image.png](attachment:e43b6dfd-0987-4662-b805-9c541c358e5b:image.png)

### 동적 할당: DHCP

- 프로토콜을 통해 자동으로 IP주소를 부여하는 방식
- 대표적인 프로토콜: DHCP (Dynamic Host Configuration Protocol)
  - **IP 주소를 동적으로 할당받으려면 호스트는 DHCP 서버와 메시지를 주고받아야함**
    - `DHCP 서버`: 호스트에 할당 가능한 IP 주소 목록을 관리하다가, IP 주소 할당 요청을 받았 을 때 IP 주소를 할당해 주는 호스트
      - 라우터(공유기)가 DHCP 서버 역할을 수행
  > 규칙 2가지
  >
  > 1. 동적 IP 주소에는 **사용 가능한 기간(임대 기간)이 정해져 있다.**
  > 2. 동적IP 주소는 **할당받을 때마다 다른주소를 받을 수 있다.**
  - 사용 기간이 끝난 IP 주소는 DHCP 서버로 반납되고, 새롭게 IP 주소를
    할당받는 경우 다른 IP 주소를 할당받을 수 있다 (IP주소의 임대)
  - IP 주소의 임대 기간이 끝나기 전에 임대 기간을 연장할 수도 있다 (`임대 갱신`)- 자동으로 2차례, 모두 실패하면 IP주소는 DHCP 서버로 반납됨

### **IP** 전송 특징의 보완: **ICMP**

- **IP의 특징: 신뢰할 수 없는 프로토콜, 비연결형 프로토콜**
  - **장점) 성능**
- 신뢰성 높은 송수신을 하려면→ 패킷에 대한 오류 제어 수행
  연결형 송수신을 하려면 → 패킷을 주고받는 호스트 간 연결을 수립하고 연결을 관리해야함
- 더 많은 시간과 대역폭, 부하가 필요하기 때문에 성능상 불리

> 그래도 보완하자면?
>
> 1. 신뢰할 수 있는 연결형 통신을 지원하는 **상위 계층의 프로토콜 이용** (ex. TCP)
> 2. **네트워크 계층의 프로토콜로 ICMP(Internet Control Message Protocol)을 이용**

- `ICMP`
  - IP 패킷의 전송 과정에 대한 피드백 메시지(`ICMP 메시지`)를 얻기 위해 사용하는 프로토콜
  - 패킷이 상대방에게 어떻게 전송되었는지를 알 수 있음
  - 대신, IP의 신뢰성을 완전히 보장하는 것은 아니다. 전송 계층의 프로토콜이 필요하다.
  - ICMP 메시지 구성
    1. 전송 과정에서 발생한 **오류 보고**
    2. 네트워크에 대한 진단 정보 (**네트워크 상의 정보**)
    ![image.png](attachment:36b1ab1a-3709-4ddf-8255-b4b3e1b336d5:image.png)
  - `오류 보고`
    - ex)
      - 네트워크 장비(가령 라우터)가 패킷을 전달받았는데, 해당 패킷을 어떤 네트워크로 전송 해야 할지 알 수 없을 경우 → **[네트워크 도달 불가] ICMP 메시지**
      - 처리하기에 너 무 큰 패킷을 전달받았는데, DF 플래그가 설정되어 있어 단편화가 불가능할 경우 → **[단편화가 필요하지만 DF가 1로 설정되어 단편화할 수 없음]**을 나타내는 ICMP 메시지
      - IP 헤더에는 패킷의 수명을 의미하는 TTL(Time To Live) 필드가 있음
        패킷은 멀리 떨어진 호스트끼리 통신할 때 여러 라 우터를 거쳐 이동할 수 있는데, 패킷이 하나의 라우터를 거칠 때마다 TTL이 1씩 감소합니다. 이때 TTL 필드가 0이 되면 해당 패킷은 폐기 → 패킷을 송신한 호스트에게 **[시간 초과]Time Exceeded ICMP 메시지** - 패킷이 호스트 호는 라우터에 한 번 전달되는 것 : `홉` - 홉마다 TTL 1씩 감소 - TTL 필드가 존재하는 이유: 무의미한 패킷이 네트워크 상에 지속적으로 남아있는 것을 방지하기 위함
  - `네트워크 진단`
    - ICMP 메시지는 네트워크상의 간단한 문제를 진단하고 테스트하기 위해 사용되기도 함
    - ex) traeroute, ping

## IP 주소와 MAC 주소의 대응: ARP

> MAC 주소는 수신인과 발신인, IP 주소는 수신 주소와 발신 주소에 비유할 수 있다.
> 상대 호스트의 IP 주소는 알고, **MAC 주소는 모르는 상황**에 사용하는 프로토콜 → `ARP`

- `ARP` (Address Resolution Protocol)
  - IP 주소와 MAC 주소를 함께 활용 하는 통신 과정에서 동일 네트워크 내에있는 송수신 대상의 IP 주소를 통해 MAC 주소를 알아내는 프로토콜
  - 동작 과정: **ARP 요청 메시지**와 **ARP 응답 메시지**를 통해 이루어짐
    - ARP 요청은 네트워크 내에 있는 모든 호스트에게 보내는 브로드캐스트 메시지
    - **`ARP 요청 메시지` → MAC 주소에 대응되는 IP 주소가 포함**
    ![image.png](attachment:c56d3cd2-d5b3-4e57-ba01-cc0aee0ab182:image.png)
    > “이 IP 주소를 가진 호스트와 통신하고 싶은데,
    > 이 호스트의 MAC 주소가 무엇인가요?’”
  - 호스트: 자신과 관련이 없는 IP 주소일경우에는 무시하고, 자신의 IP 주소일 경우에는 ARP 응답 메시지를 전송
    - **`ARP 응답 메시지` → 응답 메시지를 보내는 호스트의 MAC 주소가 포함**
    - <IP 주소, MAC 주소> 쌍을 기억해야해! 같은 호스트에게 패킷을 보내야 할 때마다 브로드캐스트(ARP 요청) 메시지를 보내지 않기 위해서…
      → `ARP 테이블`
  - `ARP 테이블`
    - ARP 요청 메시지와 ARP 응답 메시지를 통해 알게 된 <IP 주소, MAC 주소> 쌍은 ARP 테이블에 추가됨
    - arp –a 명령어 → IP 주소와 그에 대응된 MAC 주소를 볼 수 있음

# 4. 전송 계층 - TCP와 UDP

> TCP와 UDP의 패킷 구조와 동작원리를 이해해보자.

## TCP와 UDP의 목적과 특징

> IP 주소와 MAC 주소는 패킷을 송수신하는 호스트를 특정할 수 있다. 사실 패킷의 최종 송수신 대상은 호스트가 아니라 호스트가 실행하는 프로세스이다. (ex. 하나의 호스트는 웹 브라우저, 게임, 채팅 등 다양한 프로세스를 동시에 실행할 수 있고, 네트워크를 통해 주고받는 패킷은 최종적으로 이러한 프로세스에 전달되어야한다.

그럼 네트워크 상에서 **호스트가 실행하는 프로세스는 어떻게 식별할 수 있을까? →`포트`**

>

### 목적) 포트를 통한 프로세스 식별

- 네트워크 패킷을 주고받는 프로세스에는 포트 번호가 할당된다.
- **`IP주소`와 `포트 번호`의 조합** → **특정 호스트가 실행하는 특정 프로세스**를 식별
  ![image.png](attachment:5e698c88-e989-4833-aa53-b0a20a6e2868:image.png)

<aside>
💡

포트를 통한 프로세스 식별은 전송 계층(TCP, UDP )의 주된 목적

![image.png](attachment:37b447e5-ffdd-4b39-9213-347078aa8e30:image.png)

- TCP/UDP 헤더 모두 송신지 포트 | 수신지 포트 번호를 포함하고 있다!
</aside>

- 포트 종류
  - 16비트로 표현할 수 있는 포트 번호의 총 개수는 2^16, 즉 65536개
  - 65535개의 포트번호는 3종류로 나눌 수 있다.
    | 포트 종류      | 포트 번호 범위 |
    | -------------- | -------------- |
    | 잘 알려진 포트 | 0~1023         |
    | 등록된 포트    | 1024~49151     |
    | 동적 포트      | 49152~65535    |
    - 잘 알려진 포트 번호: 대중적으로 사용되는 애플리케이션을 위한 포트 번호
      - 범용적으로 사용되는 프로토콜이 주로 사용하는 포트 번호 목록
        - ex) HTTP 프로토콜로 송수신할 경우 80번 포트를 이용하고, HTTPS 프로토콜로 송수신할 경우 443 포트를 이용
      ![image.png](attachment:fd3a31ec-6bf0-4560-b3db-79d53a48998f:image.png)
    - 등록된 포트 번호
      ![image.png](attachment:7f02b91b-e085-41a4-9223-c797ef7342fa:image.png)
    - 동적 포트 (사설포트, 임시포트)
      - 비교적 자유롭게 사용 가능한 포트 번호
        - ex) 웹 브라우저를 통해 특정 웹사이트에 접속하는 경우
- cf) NAT와 NAPT
  - `NAT`(Network Address Translation ): 공인 IP 주소와 사설 IP 주소 간 변환을 위해 사용하는 기술
    - 공인 IP 주소(네트워크 외부에서 주로 사용)와
      사설 IP 주소(네트워크 내부에서 주로 사용)
    - 네트워크 내부에서 사설 IP 주소를 사용하는 호스트가 네트워크 외부에 있는 호스트와 패킷을 주고받기 위해서는 공인 IP 주소와 사설 IP 주소 간 변환이 필요
      - 대부분의 **라우터와 (가정용)공유기**는 NAT기능을 내장하고 있음
    > 사설 네트워크에서 만들어진 패킷이 네트워크 외부로 전송될 때
    >
    > - 사설 IP주소 → 공인 IP주소 변환 (1)
    >
    > 네트워크 외부 패킷이 사설 네트워크 속 호스트에 이를 때는
    >
    > - 공인 IP주소 → 사설 IP주소 변환 (2)
    ![image.png](attachment:5e48710e-3bf0-4242-989f-90796253e601:image.png)
    - 사설 IP 주소 하나는 공인 IP 주소 하나로 일대일 대응하지 않고,
      다수의 사설 IP 주소를 그보다 적은 수의 공인 IP 주소로 변환한다!
      <aside>
      💡
      
      그렇다면 여러 개의 사설 IP 주소는
      어떻게 **고유한 주소인 공인 IP 주소 하나로 변환될까? → `포트`**
      
      </aside>
      
      > 서로 다른 사설 IP 주소가 같은 공인 IP 주소로 변환되더라도 다른 포트 번호로 변환된다면 네트워크 내부의 호스트를 특정할 수 있다!
      > 
      > - ex) 1.2.3.4’라는 동일한 공인 IP 주소로 변환되더라도 포트 번호 6200번 으로 변환되는지, 6201번으로 변환되는지에 따라 내부 IP 주소를 구분할 수 있다.
  - `NAPT` (Network Address Port Translation)
    - IP 주소 변환 과정에서 변환할 IP 주소의 쌍과 더불어, 포트 번호도 함께 고려하는 포트 기반의 NAT
    - 네트워크 내부에서 사용할 IP 주소와 네트워크 외부에서 사용할 IP 주소를
      N:1로 관리할 수 있다는 점에서, **공인 IP 주소 수의 부족 문제를 개선하는 기술**로도 간주되고 있습니다.
    ![image.png](attachment:a9364545-8e7a-456e-8dcd-9ff05b4a4a36:image.png)

### (비)신뢰성과 (비)연결형 보장

![image.png](attachment:7184ee73-8595-4612-8ddd-697cd66e62ff:image.png)

- TCP
  - 신뢰할 수 있는 통신 — 상태 관리, 흐름 제어, 오류 제어, 혼잡 제어 제공 O
  - 연결형 통신 — 연결수립, 종료 과정 O
  - 그만큼 시간과 연산이 소요되기 때문에 일반적으로 UDP에 비해 송수신 속도가 느림
- UDP
  - 신뢰할 수 없는 통신 — 상태 관리, 흐름 제어, 오류 제어, 혼잡 제어 제공X
  - 비연결형 통신 — 연결수립, 종료 과정 X

> 패킷의 유실 없는 송수신을 원한다면 → TCP
> 비교적 빠른 송수신을 원한다면 → UDP

- 헤더 비교

> TCP 헤더 필드의 수는 UDP보다 훨씬 많습니다.
> (사실상 UDP 헤더는 IP 헤더를 감싸는 일종의 껍데기와 같습니다).
> UDP 헤더에 있는 모든 필드가 TCP 헤더에 포함되어 있음

- UDP 헤더

  ![image.png](attachment:abd8fbd7-cf0d-4abd-ae32-d39a6d83e4a2:image.png)

  - `송신지 포트` | `수신지 포트`
    - 송신 프로세스가 할당된 포트 번호
    - 수신 프로세스가 할당된 포트 번호
  - `길이` | `체크섬`
    - 헤더를 포함한 UDP 패킷(UDP 데이터그램)의 바이트 크기
    - 송수신 과정에서의 데이터그램 훼손 여부를 알 수 있는 정보

- TCP 헤더
  ![image.png](attachment:aced85a4-3198-4ba4-bf19-42904692aa9d:image.png)

![image.png](attachment:25b54a7f-61f1-4eae-bc43-fad60c929f10:image.png)

- `순서 번호 필드`
  (sequence number)
  - TCP 패킷(TCP 세그먼트)의 올바른 송수신 순서를 보장하기 위해 세그먼트 첫 바이트에 매겨진 번호
  - 현재 주고받는 TCP 세그먼트가 송수신하고자 하는 데이터의 몇 번째 바이트에 해당하는지
- `확인 응답 번호 필드` (acknowledgment number)
  - 상대 호스트가 보낸 세그먼트에 대한 응답
- 일부 `제어 비트` (플래그 비트)
  > 제어 비트는 기본적으로 8비트
  - **ACK** : 세그먼트의 승인을 나타내기 위한 비트
  - **SYN**: 연결을 수립하기 위한 비트
  - **FIN**: 연결을 종료하기 위한 비트

<aside>
💡

호스트 B는 확인 응답 번호를 통해 상대 호스트 A에 보낸 패킷에 상대 호스트가 어떻게 반응했는지, 상대 호스트가 다음으로 받고자 하는 패킷이 무엇인지를 알 수 있다.
**→ `TCP`의 신뢰성 보장: `확인 응답 번호`를 통해 이루어진다**

</aside>

## TCP: 연결부터 종료까지

> UDP와 달리 송수신 이전에 **연결을 수립**하고, 송수신 이후에는 **연결을 종료**
> 송수신 전후로 ‘`상태`’라는 값을 관리

### TCP 연결 수립

> 쓰리 웨이 핸드셰이크 three-way handshake
> : 세 단계로 이루어진 TCP 연결 수립 과정
>
> ![image.png](attachment:878faabb-ef0f-422d-b3e4-be19dc36087a:image.png)
>
> ➊ [송수신 방향 **A** → **B**]: **`SYN** 세그먼트 전송`
>
> - 호스트 A는 **SYN 비트가 1로 설정된 세그먼트**(이하 SYN 세그먼트)를 호스트 B에게 전송
> - 세그먼트의 순서 번호에는 호스트 A의 순서 번호가 포함
>
> ➋ [송수신 방향 **B** → **A**] **`SYN** + **ACK** 세그먼트 전송`
>
> - 호스트 B는 **ACK 비트와 SYN 비트가 1로 설정된 세그먼트**(이하 SYN+ACK 세그먼트)를 호스트 A에게 전송
> - 세그먼트의 순서 번호에는 호스트 B의 순서 번호와 ➊에서 보낸 세그먼트에 대한 확인 응답 번호가 포함
>
> ➌ [송수신 방향 **A** → **B**] **`ACK** 세그먼트 전송`
>
> - 호스트 A는 **ACK 비트가 1로 설정된 세그먼트**(이하 ACK 세그먼트)를 호스트 B에게 전송
> - 세그먼트의 순서 번호에는 호스트 A의 순서 번호와 ➋에서 보낸 세그먼트에 대한 확인 응답 번호가 포함

- `SYN 비트`: 연결을 수립하기 위한 비트
  - SYN 비트가 설정된 패킷 을 처음으로 보내는 호스트가 곧 처음으로 연결 요청을 보내는 호스트
    - 연결을 시작하는 과정: **`액티브 오픈` (주로 클라이언트)**
    - 연 결 요청을 수신한 뒤 그에 대한 연결을 수립하는 과정: `패시브 오픈` **(주로 서버)**
  ![image.png](attachment:24986dfb-de71-4a7b-bdc4-c48fee533127:image.png)

### TCP: 오류/흐름/혼잡 제어

> 패킷의 신뢰성을 보장하기 위해 3가지 기능을 제공
>
> - 재전송을 기반으로 다양한 오류를 제어,
>   송수신의 흐름을 제어해 처리할 수 있을 만큼의 데이터를 주고받고,
>   혼잡제어를 통해 네트워크의 혼잡정도에 따라 데이터의 전송량을 조절

**1️⃣ 재전송을 통한 오류 제어**

<aside>
💡

언제 잘못 전송된 세그먼트가 있음을 인지할까?

1. 중복된 ACK 세그먼트가 도착했을 때
2. 타임아웃이 발생했을 때
</aside>

- 순서번호 담은 세그먼트 → 그에 대한 확인 응답이 담긴 세그먼트 → 다음 순서 번호를 담은 세그먼트 → 그에 대한 확인 응답이 담긴 세그먼트 반복…
- 이때 `중복된 ACK세그먼트를 수신하는 상황`
  → 송신한 세그먼트의 일부가 전송 중 유실되어 중복으로 세그먼트를 수신하는 상황
  ![image.png](attachment:1cfa4637-d6ec-4432-a745-12b0cdb56178:image.png)
- `타임아웃이 발생한 상황`
  → TCP 세그먼트를 송신하는 호스트는 모두 재전송 타이머라는 값을 유지하는데, 호스트는 세그먼트를 전송할 때마다 이 재전송 타이머를 시작한다.
  - 타임아웃: 이 타이머의 카운트다운이 끝난 상황
  - **타임아웃 발생 시점까지 ACK 세그먼트를 받지 못하면, 세그먼트를 재전송**
    ![image.png](attachment:d0e69736-8962-4869-adc6-a04c4ddd2c4d:image.png)
- 파이프라이닝 전송
  - (기본적인 TCP 송수신)’ 순서 번호를 담은 세그먼트를 보내고, 그에 대한 확인 응답을 담은 세그먼트를 받고, 다음 순서번호를 담은 세그먼트를 보내고, 그에 대한 확인 응답을 담은 세그먼트를 받고 반복…
  - `단점`
    - 한 번에 여러 세그먼트를 보낼 수 있는 상황에서도 확인응답을 받기 전까지 보낼 수 없다! **한 번에 하나의 세그먼트만 주고받아야함…**
    - `보완: 파이프라이닝`
      - 확인 응답을 받기 전이라도 여러 메시지를 보내는 방식으로 송신
        ![image.png](attachment:120b492b-e444-4174-b5dc-4d7f767b323b:image.png)

2️⃣ **흐름제어**

> **수신 호스트가 한 번에 받아 처리할 수 있을 만큼만** 전송하는 것.
> 송신 호스트가 수신 호스트의 처리 속도를 고려하며 송수신 속도를 균일하게 맞추는 기능

- **흐름제어의 주체: 수신 호스트**
    <aside>
    💡
    
    어떻게 판단할까?
    
    - 수신 호스트가 한번에 받을 수 있는 전송량은? → **TCP `수신 버퍼의 크기`**
        - 수신된 세그먼트가 애플리케이션 프로세스에 의해 읽히기 전에 임시 저장되는 공간 (커널에 정의되어있음)
    - 송신 호스트가 어떻게 알고 보내줄 수 있을까? → **TCP 헤더의 윈도우 필드의
     `수신 윈도우`**
        - 수신 호스트가 한 번에 처리할 수 있는 수신 윈도우 크기가 명시
        - RWND(Receiver WiNDow, 수신 윈도우)
    </aside>


**3️⃣ 혼잡 제어**

> 많은 트래픽으로 인해 패킷의 처리 속도가 느려지거나 유실될 수 있는 상황

- 흐름 제어의 주체가 수신 호스트였다면,
  **혼잡 제어의 주체: 송신 호스트** - 얼마나 네트워크가 혼잡한지 판단 - 판단된 혼잡도에 따라 세그먼트의 전송량 조절

<aside>
💡

어떻게 판단할까?

- 네트워크 혼잡 기준은? → 세그먼트의 전송 오류를 판단하는 기준과 같다
  - **중복된 ACK 세그먼트가 도착했을 때 | 타임아웃이 발생했을 때**
- 얼만큼을 송신할까? → **`혼잡 윈도우`** - 혼잡 없이 전송할 수 있을 정도의 양 - 크면 전송할 수 있는 세그먼트의 수가 많고, 작으면 네트워크가 혼잡한 상황임 - CWND(Congestion WiNDow, 혼잡 윈도우)
</aside>

- 송신 호스트 입장에서)
  수신 윈도우 크기는 수신 호스트가 TCP 헤더로 알려주지만,
  **혼잡 윈도우의 크기는 송신 호스트가 직접 계산하여 알아내야한다!!**
      → `혼잡 제어 알고리즘`

      - `AIMD`(Additive Increase/Multiplicative Decrease)

          > 합으로 증가, 곱으로 감소
          >
          > - 혼잡 윈도우 1씩 선형적으로 증가
          >     - 세그먼트를 보내고, 그에 대한 응답이 오기까지 혼잡이 감지되지 않을 때
          > - 혼잡 윈도우 절반으로 감소
          >     - 혼잡이 감지될 때
          - RTT: 패킷을 보내고 그에 대한 응답이 수신되기까지의 시간

              → AIMD: RTT마다 1씩 선형적으로 증가시키고, 혼잡이 감지되면 혼잡 윈도우를 절반으로 떨어뜨리는 알고리즘


### TCP의 종료

> TCP 연결 종료: 송수신 호스트가 각자 한 번씩 FIN과 ACK를 주고받음
>
> ➊ [송수신 방향 **A** → **B**] **`FIN** 세그먼트`
>
> - 호스트 A는 FIN 비트가 1로 설정된 FIN 세그먼트를 호스트 B에게 전송합니다.
>
> ➋ [송수신 방향 **B** → **A**] **`ACK** 세그먼트`
>
> - ➊에 대한 호스트 B의 응답입니다.
>   호스트 B는 ACK 세그먼트를 호스트 A에게 전송합니다.
>
> ➌ [송수신 방향 **B** → **A**] **`FIN** 세그먼트`
>
> - 호스트 B는 FIN 세그먼트를 호스트 A에게 전송합니다.
>
> ➍ [송수신 방향 **A** → **B**] **`ACK** 세그먼트`
>
> - ➌에 대한 호스트 A의 응답입니다.
>   호스트 A는 ACK 세그먼트를 호스트 B에게 전송합니다.

![image.png](attachment:5949bd25-4164-4955-bab5-cc8c6a745fa3:image.png)

- `액티브 클로즈`
  - 먼저 연결을 종료하려는 호스트에 의해 수행되는 동작
- `패시브 클로즈`
  - 연결 종료 요청을 받아들이는 호스트에 의해 수행되는 동작

## TCP의 상태 관리

> TCP의 또 다른 중요한 특징: 상태를 유지

- **TCP → 스테이트풀 프로토콜 (stateful protocol)**
  - `상태` state: 현재 어떤 통신 과정에 있는지
    - 현재 TCP 송수신 현황을 판단하고, 디버깅의 힌트로 활용할 수 있음
  ![image.png](attachment:c06e08fc-bf7a-43c5-85c6-b35b82a1ea1b:image.png)

1. 연결이 수립되지 않았을 때 주로 활용되는 상태

- `CLOSED`: 아무런 연결이 없는 상태
- `LISTEN`: 연결 대기 상태
  (쓰리 웨이 핸드셰이크의 첫 단계인 SYN 세그먼트를 대기하는 상태)

2. 연결 수립 과정에서 주로 활용되는 상태

- `SYN-SENT`: 액티브 오픈 호스트가 SYN 세그먼트를 보낸 뒤, 그에 대한 응답인 SYN + ACK 세그먼트 를 기다리는 상태(연결 요청 전송)
- `SYN-RECEIVED`: 패시브 오픈 호스트가 SYN + ACK 세그먼트를 보낸 뒤, 그에 대한 ACK 세그먼트를 기다리는 상태(연결 요청 수신)
- `ESTABLISHED`: 쓰리 웨이 핸드셰이크가 끝난 뒤 데이터를 송수신할 수 있는 상태(연결 수립)
  ![image.png](attachment:6314c873-2225-4933-842a-dcc92b9c1614:image.png)

3. 연결 종료 과정에서 주로 활용되는 상태

- `FIN-WAIT-1`: 액티브 클로즈 호스트가 FIN 세그먼트로 연결 종료 요청을 보낸 상태(연결 종료 요청 전송)
- `CLOSE-WAIT`: FIN 세그먼트를 받은 패시브 클로즈 호스트가 그에 대한 응답으로 ACK 세그먼트를 보낸 후 대기하는 상태(연결 종료 요청 승인)
- `FIN-WAIT-2`: FIN-WAIT-1 상태에서 ACK 세그먼트를 받은 상태
- `LAST-ACK`: CLOSE-WAIT 상태에서 FIN 세그먼트를 전송한 뒤 대기하는 상태
- `TIME-WAIT`: 액티브 클로즈 호스트가 마지막 ACK 세그먼트를 전송한 뒤 접어드는 상태

![image.png](attachment:40b7d194-770b-4f7a-ac77-b923c437eaa3:image.png)

- 유의할 점
  - 패시브 클로즈 호스트가 마지막 ACK 세그먼트를 수신하면 CLOSED 상태가 되는 반 면, TIME-WAIT 상태에 접어든 액티브 클로즈 호스트는 **일정 시간을 기다린 뒤 CLOSED 상태**
  - 왜 기다릴까?
    - 마지막 ACK 세그먼트가 올바르게 전송되지 않았을 수 있고, 이 경우 재전송이 필요하기 때문
- cf) `CLOSING` 상태
  - 서로가 FIN 세그먼트를 보내고 받은 뒤, 각자 그에 대한 ACK 세그먼트를 보냈지만, 아직 자신의 FIN 세그먼트에 대한 ACK 세그먼트를 받지 못했을 때
  - 다음과 같이 양쪽이 동시에 연결 종료를 요청하고 서로의 종료 응답을 기다릴 경우에 발생하는 상태

# 5. 응용 계층 - HTTP의 기초

## DNS와 URI/URL

- HTTP를 이해하려면 도메인 네임 관련 프로토콜인 DNS와 자원개념, 이를 식별하기 위한 정보인 URI에 대해 이해해야한다!

### 도메인 네임과 DNS

- IP주소는 뭐였지?
    - 네트워크 상의 호스트를 식별하기 위해 기본적으로 사용
    - 하지만, IP주소로만으로는 특정 호스트의 특징을 나타내기 어렵고, 호스트의 IP주소는 언제든 바뀔 수 있다.
    - 그래서 사용하는 것이 `도메인 네임!`
        - www.google.com과 같은 문자열 형태의 호스트 특정 정보
        - 호스트의 IP주소와 대응
- 도메인 네임과 대응하는 IP주소는 `네임서버`에서 관리된다.
도메인 네임을 관리하는 네임서버는 `DNS 서버`라고도 부른다.
    - **호스트는 네임 서버에 특정 도메인 네임을 가진 호스트의 IP 주소가 무엇인지 질의함으로써, 패킷을 주고받고자 하는 호스트의 IP주소를 얻어낼 수 있다.**
    - 이렇게 IP주소를 모르는 상태에서 도메인 네임에 대응되는 IP주소를 알아내는 과정 → 도메인 네임을 풀이한다, resolving한다고 표현한다.

### 도메인 네임의 계층적 구조

- .을 기준으로 계층적 분류
    - `3단계 도메인 < 2단계 도메인 < 최상위 도메인 < 루트 도메인`
    - 예시) www.example.com.
- 루트도메인(최상단: Root Domain) → 최상위 도메인(TLD : Top-Level Domain)
    - 도메인 네임의 마지막 부분에 .으로 표현되는 루트 도메인도 도메인 네임의 일부이지만, 생략하기 때문에 최상위 도메인을 도메인 네임의 마지막 부분으로 간주해 ‘최상위’라고 표현
- 도메인 단계는 더 늘어날 수 있지만 보통 3~5단계로 구성
- **전체 주소 도메인** (Fully-Qualified Domain Name)
    - www.example.com.처럼 도메인 네임을 모두 포함하는 도메인 네임
    - `FQDN`을 알면 호스트를 식별할 수 있다
- 서브 도메인
    - 다른 도메인이 포함된 도메인
    - Ex) mail.examle.com, www.example.com, developer.example.com은 모두 exmaple.com의 서브도메인

### 도메인 네임을 관리하는 네임 서버의 계층적 구조

- 계층적인 형태로 이뤄진 도메인을 관리하는 네임 서버 또한 계층적인 형태
- 네임 서버는 여러 개, 전 세계 여러 곳에 위치, 분산되어 관리됨

→ `도메인 네임 시스템(DNS)` - 계층적으로 분산되어 있는 도메인 네임 관리체계

![image.png](attachment:43b4717d-844a-4166-af49-8dcb9c11d20a:image.png)

- **도메인 네임에 대응되는 IP 주소를 알아내는 과정**
    - 호스트는 가장 먼저 `로컬 네임 서버`에게 도메인 네임을 질의
        - 로컬 네임 서버는 클라이언트와 맞닿아 있는 네임 서버
    - **클라이언트가 로컬 네임 서버를 찾기 위해선** 로컬 네임 서버의 주소를 알고 있어야 함
        - 그래서 ISP가 로컬 네임 서버의 주소를 자동으로 할당해줌
        - ISP에서 할당해주는 로컬 네임 서버 주소가 아닌 공개 DNS 서버를 이용할 수도 있음 (구글의 8.8.8.8, 8.8.4.4)
    - 로컬 네임 서버가 FQDN에 해당하는 IP 주소를 알고 있다면??
        - 클라이언트에게 즉시 해당 IP 주소를 반환
    - 만일 로컬 네임 서버가 IP주소를 모른다면??
        - FQDN에 대응하는 주소를 알아낼 때까지 도메인 네임의 루트 도메인을 관장하는 서버(**루트 네임 서버**), 최상위 도메인을 관장하는 서버(**TLD 네임 서버**), 그 하위 레벨의 도메인 네임을 관장하는 서버(**네임 서버**), 차례대로 **질의를 반복**
            
            > 질의 과정이 너무 많이 반복되면, 네트워크 내 트래픽이 많아지고, 리졸빙에 지나 치게 오랜 시간이 걸리기 때문에 네임 서버들이 기존에 응답받은 결과를 임시로 저장했다 가 추후 같은 질의에 활용하는 경우가 많음 → `DNS 캐시`
            > 
    - 최종적으로 클라이언트가 원하는 IP 주소를 받으면 해당 주소를 클라이언트에게 전달

cf) DNS 레코드

- 클라이언트가 IP 주소가 아니라 도메인 네임을 통해 서버와 상호작용할 수 있도록 하려면 어떻게 해야 할까요? 가장 먼저 해야 할 일은 도메인 네임을 구입하는 것입니다. 도메인 네임은 각종 DNS 서비스 업체에서 구매할 수 있으며, 해당 업체들은 많은 경우 네임 서버를 운영합니다.
- 구입한 도메인 네임이 여러분의 서버 IP 주소에 대응된다는 사실을 네임 서버에 알리지 않으면 네임 서버는 당연히 그 사실을 알 수 없습니다.
- 따라서 IP 주소에 도메인 네임을 대응 하기 위해서는 **네임 서버에 도메인 네임 관련 설정 정보를 추가**해야 합니다. 이때 추가하는 정보가 바로 DNS 자원 레코드(DNS resource record)입니다.
- DNS 레코드에는 기본적으로 이름(Record name)과 그에 대응하는 값(Value)이 있으며, 그 <이름, 값> 쌍 의 유형을 나타내는 레코드 타입(Record type)도 포함

### 자원과 URI/URL

- 자원: 네트워크 상의 메시지를 통해 주고받는 최종 대상을 의미 (ex. html파일, 이미지/동영상/텍스트 파일)
- `URI`: 웹 상에서의 자원을 식별하기 위한 정보
    - Uniform Resource Identifier
    - ‘이름’ 기반으로 하는지, ‘위치’를 기반으로 하는지에 따라 `URN`(Uniform Resource Name), `URL`(Uniform Resource Locator)로 구분한다.
- `URL`
    
    ![image.png](attachment:512119c0-f32a-4786-8e48-bc073763e3bf:image.png)
    
    1. **scheme**
        - 자원에 접근하는 방법
        - 일반적으로 사용할 프로토콜 (http, https)
    2. **authority**
        - 호스트를 특정할 수 있는 IP 주소나 도메인 네임
        - :뒤에 번호명시 가능
    3. **path**
        - 자원이 위치하고 있는 경로
    4. **query**
        - URL에 대한 매개변수 역할을 하는 문자열 (쿼리 문자열, 쿼리 파라미터)
    5. **fragment**
        - 자원의 일부분, 자원의 한 조각을 가리키기 위한 정보
        - HTML 파일과 같은 자원에서 특정 부분을 가리키는 데 사용
            
            (**a**) https://datatracker.ietf.org/doc/html/rfc3986
            (**b**) https://datatracker.ietf.org/doc/html/rfc3986#section-1.1.2
            
- cf) URL
    - 자원의 위치가 변하면 URL은 유효하지 않는 반면, URN은 자원에 고유한 이름을 붙이는 이름 기반의 식별자이기 때문에 자원의 위치와 무관하게 자원을 식별할 수 있다는 장점이 있다.

## HTTP의 특징

목적: 애플리케이션의 다양한 자원을 네트워크를 통해 송수신

1. **요청 응답 기반 프로토콜**
    - 클라이언트(요청 메시지 보내고)와 서버(응답 메시지를 보내고)가 주고받는 구조
2. **미디어 독립적 프로토콜**
    - 주고받을 자원의 특성과 무관하게 자원을 주고받는 수단(인터페이스)의 역할만 수행
    - 미디어 타입(주고받는 자원의 종류)에 특별한 제한을 두지 않고, 독립적으로 작동이 가능
        - 미디어타입 → MIME 타입(Multipurpose Internet Mail Extensions Type)라고도 부름
        - 타입/서브타입의 형식
            - 타입: 데이터 유형
            - 서브타입: 주어진 타입에 대한 세부 유형
        - ex) */*는 모든 미디어타입을 의미
3. **스테이트리스(stateless) 프로토콜**
    - 서버는 HTTP 요청을 보낸 클라이언트 관련 상태를 기억하지 않는다
        
        <aside>
        💡
        
        상태를 유지하지 않는 이유는?
        
        모든 클라이언트의 상태 정보를 유지하는 것은 서버에 큰 부담이 됩니다. 또 서버는 여러 대로 구성될 수도 있는데, 여러 대로 구성된 서버 모두가 모 든 클라이언트의 상태를 유지해야 한다면 어쩔 수 없이 모든 서버가 모든 클라이언트의 상태 정보를 공유해야 합니다. 하지만 이는 매우 번거롭고 복잡한 작업입니다.
        
        </aside>
        
    - HTTP 서버: **확장성과 견고성**
        - 상태를 유지하지 않고 모든 요청을 독립적인 요청으로 처리하기 때문에,
        - 언제든 쉽게 서버를 추가할 수 있어 **확장성**을 높이고, 서버 중 하나에 문제가 생기더라도 쉽게 다른서버로 대체 할수있어 견고성을 높임
4. **지속 연결 프로토콜**
    - **초기 HTTP (1.0 이하)**
        - 비연결형 프로토콜 → 매 요청마다 TCP 연결 수립과 종료 필요
        - **비지속 연결(non-persistent connection):** 매번 새롭게 연결 수립/종료
    - **HTTP 1.1 이상**
        - **지속 연결(persistent connection, keep-alive)** 지원
        - 하나의 TCP 연결에서 여러 요청-응답 처리 가능 → 속도 향상
        
        ![image.png](attachment:3f002608-62e1-4ee2-a396-70f557dff9c7:image.png)
        
    
    <aside>
    💡
    
    [HTTP 버전별 특징]
    
    **HTTP 1.1**
    
    - 현재까지 널리 사용됨.
    - **지속 연결(persistent connection, keep-alive)** 지원 
    → 한 TCP 연결에서 여러 요청-응답 가능.
    - **평문 기반** 메시지 전송.
    - 콘텐츠 협상, 다양한 편의 기능 추가.
    
    **HTTP 2.0**
    
    - HTTP 1.1 단점 보완.
    - **바이너리 데이터 기반 송수신**: 메시지를 평문이 아닌 바이너리 형태로 송수신.
    - **헤더 압축**: 네트워크 이용 효율 향상.
    - **서버 푸시(server push)**: 클라이언트가 요청하지 않은 자원도 미리 전송.
    - **멀티플렉싱(multiplexing)**: 여러 개의 독립적인 스트림(stream)을 바탕으로 여러 요청-응답을 병렬 처리 → HOL 블로킹 문제 완화.
        - HOL(Head-Of-Line) 블로킹: 같은 큐에 대기하며 순차적으로 처리되는 여러 패킷이 있을 때, 첫 번째 패킷의 처리 지연으로 인해 나머지 패킷들의 처리도 모두 지연되는 문제 상황
    
    **HTTP 3.0**
    
    - 최신 버전, 점차 사용 확대.
    - **UDP 기반(QUIC)** → TCP보다 빠른 송수신 → 속도개선
    </aside>
    

## **HTTP 메시지 구조**

- **| 시작 라인(start line)**, **필드 라인(header)**, **본문(body)**으로 구성됨.
- **필드 라인**은 여러 개 존재 가능, **본문**은 선택적이며 전송되는 자원이 포함됨.

### 시작 라인

- 메시지가 요청인지 응답인지 구분 (요청 라인과 상태 라인으로 구분)
    - 요청 → `요청 라인` = 메서드 (공백) 요청 대상 (공백) HTTP 버전 (줄바꿈)
    응답 → `상태 라인` = HTTP 버전 (공백) 상태 코드 (공백) 이유 구문-선택적 (줄바꿈)
    
    ![image.png](attachment:e3bbb7c1-4a98-40b8-8875-fff32201f50b:image.png)
    

### 필드 라인

- HTTP 헤더 (헤더 이름: 헤더 값)
- 예시
    
    ```python
    Content-Type: text/html
    Content-Length: 648
    ```
    

## **HTTP** 메서드와 상태 코드

![image.png](attachment:d81f2c35-184a-49eb-80d5-6d0ccf72af4d:image.png)

### HTTP 메서드

![image.png](attachment:ad5946e9-0944-4200-a0c1-d0af18707f20:image.png)

- 같은 URL이라도 메서드별 동작은 개발자가 설계 가능

| 메서드 | 용도 | 특징/예시 |
| --- | --- | --- |
| **GET** | 자원 조회 | 요청 시 메시지 본문 없음
ex. 웹 브라우저에서 페이지 조회 시 사용 |
| **HEAD** | GET과 동일하지만 헤더만을 응답받음 (응답 메시지 본문 없음) | 헤더 정보만 확인 가능 |
| **POST** | 보통 클라이언트가 서버에 새로운 자원 생성할 때 | 메시지 본문 포함
성공 시 201 Created 응답 |
| **PUT** | 기존 자원 **덮어쓰기** | 요청 본문으로 자원 전체를 대체 |
| **PATCH** | 기존 자원 **부분 수정** | 요청 본문에 해당하는 부분만 수정 |
| **DELETE** | 자원 삭제 | 특정 URL 자원 삭제 요청 |

### HTTP 상태코드

| 상태 코드 | 의미 | 대표 예시 |
| --- | --- | --- |
| **100~199** | 정보성 | Continue 등 |
| **200~299** | 성공 | 200 OK
201 Created
202 Accepted
204 No Content |
| **300~399** | 리다이렉션 | 301/308 Permanent Redirect,
302/307 Temporary Redirect, 303 See Other, 
304 Not Modified |
| **400~499** | 클라이언트 오류 | 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, 405 Method Not Allowed |
| **500~599** | 서버 오류 | 500 Internal Server Error, 502 Bad Gateway |
- **리다이렉션**:
    
    ![image.png](attachment:196b7191-9295-402e-8e70-4e1f9a125521:image.png)
    
    - 영구적(Permanent, 301/308) → 기존 URL 더 이상 필요 없음
        
        
        | 코드 | 설명 | 재요청 메서드 |
        | --- | --- | --- |
        | **301 Moved Permanently** | 자원이 **영구적으로 이동** | 원래 POST 요청도 **GET으로 바뀔 가능성 있음** → 오래된 브라우저 호환 문제 때문에 애매모호 |
        | **308 Permanent Redirect** | 자원이 **영구적으로 이동** | 원래 메서드 **그대로 유지** → POST 요청이면 재요청도 POST |
    - 일시적(Temporary, 302/303/307) → 기존 URL 여전히 유효
        
        
        | 코드 | 설명 | 재요청 메서드 |
        | --- | --- | --- |
        | **302 Found** | 자원이 **임시로 이동** | POST → GET으로 바뀔 가능성 있음 |
        | **303 See Other** | 자원이 **임시 이동, 반드시 GET 사용** | 항상 GET으로 재요청 |
        | **307 Temporary Redirect** | 자원이 **임시 이동, 메서드 유지** | POST → POST 유지 |
    - 메서드 변경 여부 확인 필요 (특히 POST 재요청 시 GET으로 변환 가능 여부)
- **401 vs 403**
    
    ![image.png](attachment:eb634b40-1270-413e-a3af-68b212ed3ec4:image.png)
    
    - 인증(Authentication) 문제 → 401
    권한(인가)(Authorization) 문제 → 403
    - 인증이란 ‘자신이 누구인지를 증명하는 작업’을 의미하고, 
    권한이란 ‘인증된 주체에게 허용된 작업’을 의미
- **500번대**: 서버 문제, 대부분 Internal Server Error, 중간 서버 문제 시 Bad Gateway
    
    ![image.png](attachment:d653ab1f-7fed-4f35-887c-4071a997bf44:image.png)
    

## HTTP 주요 헤더

> 빈번히 사용되는 HTTP 헤더의 의미를 기억해 두고, 새로운 헤더가 나올 때마다 그때 그때 정리해도 무방
> 

### 요청 메시지에서 주로 활용되는 **HTTP** 헤더

| 헤더 | 설명 | 예시 |
| --- | --- | --- |
| **Host** | 요청을 보낼 서버 호스트 정보 | Host: [www.example.com](http://www.example.com/) |
| **User-Agent** | 요청을 보낸 클라이언트 프로그램 정보(브라우저, OS, 렌더링 엔진 등) | User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/109.0 |
| **Referer** | 요청을 보낸 페이지(유입 경로) URL | Referer: [https://minchul.net](https://minchul.net/) |

### **응답 메시지에서 주로 사용하는 헤더**

| 헤더 | 설명 | 예시 |
| --- | --- | --- |
| **Server** | 응답을 보낸 서버 정보 | Server: Apache/2.4.1 (Unix) |
| **Allow** | 처리 가능한 HTTP 헤더 목록을 알리기 위해 사용
(클라이언트가 사용할 수 있는 HTTP 메서드) | Allow: GET, POST |
| **Location** | 자원의 위치(URL) 안내, 리다이렉션 시 사용 | Location: /new-resource |

### 요청·응답 메시지에서 사용하는 헤더

| 헤더 | 설명 | 예시 |
| --- | --- | --- |
| **Date** | 메시지 생성 시각 | Date: Tue, 15 Nov 1994 08:12:31 GMT |
| **Content-Length** | 메시지 본문의 길이(바이트 단위) | Content-Length: 123 |
| **Content-Type** | 메시지 본문의 미디어 타입 | Content-Type: text/html; charset=UTF-8 |
| **Content-Language** | 메시지 본문의 언어 | Content-Language: ko-KR, en-US |
| **Content-Encoding** | 본문 압축/변환 방식 | Content-Encoding: gzip, br |
| **Connection** | 연결 방식 제어 (유지/종료) | Connection: keep-alive / close |

# 6. 응용 계층 - HTTP의 응용

> 쿠키, 캐시, 콘텐츠 협상, 인증, 보안으로 대표되는 각종 HTTP 기반의 다양한 기술
> 

## 쿠키

> **쿠키**는 HTTP의 스테이트리스 특성을 보완하기 위한 대표적 수단
> 
- 서버에서 생성되어 클라이언트(주로 브라우저)에 저장되는 **<이름, 값> 쌍**의 데이터입니다.
- 쿠키는 필요 시 **만료기간, 도메인, 경로, 보안 속성** 등 추가 속성을 가질 수 있습니다.
- `쿠키 전송 과정`
    1. **서버 → 클라이언트**: 응답 메시지의 `Set-Cookie` 헤더를 통해 쿠키 전송
        
        ```
        Set-Cookie: name=minchul
        Set-Cookie: phone=100-100; Expires=Fri, 23 Aug 2024 09:00:00 GMT
        Set-Cookie: sessionID=abc123; Max-Age=2592000
        ```
        
    2. **클라이언트 → 서버**: 요청 메시지의 `Cookie` 헤더로 저장된 쿠키 전송
        
        ```
        Cookie: name=minchul; phone=100-100; sessionID=abc123
        ```
        
    - 서버가 쿠키를 전달하면, 클라이언트는 **자동으로 다음 요청 시 같은 서버에 쿠키를 포함**하여 전송합니다.
- 쿠키 추가 속성
    
    
    | 속성 | 설명 |
    | --- | --- |
    | **Domain** | 쿠키를 전송할 도메인 지정 |
    | **Path** | 쿠키를 전송할 경로 지정 |
    | **Expires** | 쿠키 만료 시각 지정 (GMT 형식) |
    | **Max-Age** | 쿠키 유효기간(초 단위) 지정 |
    | **Secure** | HTTPS에서만 쿠키 전송 가능 |
    | **HttpOnly** | JS 접근 제한, HTTP 송수신으로만 접근 가능 |

### cf) 웹 스토리지

> 로컬 스토리지와 세션 스토리지
> 

| 종류 | 설명 |
| --- | --- |
| **Local Storage** | 영구 저장, 브라우저 종료 후에도 유지 |
| **Session Storage** | 세션 유지 동안 저장, 브라우저 종료 시 삭제 |

<aside>
💡

- HTTP는 스테이트리스 → 상태 정보 필요 시 **쿠키**나 **웹 스토리지** 사용
- **쿠키**: 서버와 클라이언트가 주고받으며 상태 유지
- **웹 스토리지**: 클라이언트에서만 저장, 서버 전송 자동 X
</aside>

## 캐시

> 응답받은 자원의 **사본을 임시 저장**하여 불필요한 대역 폭 낭비와 응답 지연을 방지하는 기술
> 
- 목적
    - 서버로부터 받은 자원의 **사본을 임시 저장**하여 불필요한 대역폭 낭비와 응답 지연을 줄임.
    - 예: 10MB 이미지 파일을 한 번 다운받아 **캐시**해 두면, 다음 요청 시 서버 재전송 없이 빠르게 접근 가능.

| 구분 | 위치 | 설명 |
| --- | --- | --- |
| **개인 전용 캐시 (Private Cache)** | 클라이언트 브라우저 | 개인용, 서버 간 공유 X |
| **공용 캐시 (Public Cache)** | 클라이언트와 서버 사이 중간 서버 | 여러 사용자가 공유 가능 |

### 캐시 유효 기간

- 유효기간 설정 방법: 응답메시지의 Expires 헤더와 Cache Control 헤더의 Max- Age 값
    - `Expires` 헤더: 캐시 만료 시각 (GMT 형식)
    - `Cache-Control: max-age=<초>`: 캐시 사용 가능 시간
- 왜 설정할까?
    - 서버 원본 데이터가 변경되면 캐시 데이터와 불일치가 발생할 수 있음 
    → **캐시 신선도(cache freshness):얼마나 유사한지의 정도** 필요

### 캐시 갱신 방식

1. **날짜 기반**: `If-Modified-Since` 헤더 사용
    - 서버 응답:
        - 200 OK → 변경됨, 새 자원 전송
        - 304 Not Modified → 변경 없음, 캐시 사용 가능
        - 404 Not Found → 자원 삭제됨
2. **엔티티 태그 기반(Etag)**: `If-None-Match` 헤더 사용
    - 자원의 버전을 Etag로 식별
    - 자원이 변경되어 Etag 값도 변경되었다면) 그때만 변경된 자원으로 응답하도록 서버에게 요청
    - 서버 응답:
        - 200 OK → Etag 불일치, 새 자원 전송
        - 304 Not Modified → Etag 일치, 캐시 사용 가능
        - 404 Not Found → 자원 삭제됨

## 콘텐츠 협상(content negotiation)

- **자원(Resource)** = URI로 식별되는 것
- **표현(Representation)** = 송수신 가능한 자원의 구체적인 형태 (언어, 형식, 인코딩 등)
    - 서버와 클라이언트가 HTTP 메시지를 통해 주고받는 것은 ‘자원의 표현’
- 같은 자원도 여러 표현 가능 → 클라이언트가 원하는 표현을 선택할 수 있도록 하는 기술이 **콘텐츠 협상**
- 주요 헤더
    - `Accept` : 선호하는 **미디어 타입** (HTML, XML, JSON 등)
    - `Accept-Language` : 선호하는 **언어** (ko, en 등)
    - `Accept-Encoding` : 선호하는 **인코딩 방식** (gzip, deflate 등)
- 클라이언트가 우선순위를 반영하여 여러 표현에 대한 선호도를 서버에 알릴 수도 있음
    - `q` = Quality Value (0~1, 생략 시 1)
    - 값이 클수록 우선순위가 높음
    - ex) 한국어(ko-KR, ko), 영어(en-US, en)의 순으로 선호하며,
     HTML과 XML, 일반 텍스트의 순 으로 선호
        
        ```python
        GET /index.html HTTP/1.1
        Host: example.com
        Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
        Accept: text/html,application/xml;q=0.9,text/plain;q=0.6,*/*;q=0.5
        ```
        

## 보안: **SSL**/**TLS**와 **HTTPS**

### HTTPS

> **HTTPS = HTTP + SSL/TLS** (오늘날 주로 TLS 1.2, TLS 1.3 사용)
****목적: **암호화 + 인증**
> 
- SSL(Secure Sockets Layer)과 TLS(Transport Layer Security)
    - 모두 인증과 암호화를 수행하는 프로토콜

> 동작 과정
> 
> 1. **TCP 3-way handshake**
> 2. **TLS handshake** (암호화 키 교환 + 인증서 검증)
> 3. **암호화된 HTTP 메시지 송수신**

### **TLS 핸드셰이크**

![image.png](attachment:5d7a3a5c-f8f3-473d-a2d0-9cc4412b321a:image.png)

<aside>
💡

핵심!
1. TLS 핸드셰이크를 통해 **암호화 통신을 위한 키를 생성/교환**할 수 있다
2. **인증서 송수신과 검증**이 이루어질 수 있다는 점입니다.

</aside>

1. `ClientHello`

- 클라이언트 → 서버
- 암호화 통신을 위해 협의할 정보 제시
    - 지원되는 **TLS 버전**
    - 사용 가능한 **암호화 알고리즘(암호 스위트)**
    - 해시 함수 종류
    - 키 생성을 위한 **클라이언트 난수**

👉 **암호 스위트(Cipher Suite)**: 암호화 알고리즘 + 해시 함수의 조합

![image.png](attachment:c7026f83-a11f-49e6-b629-5c3cb20e5c62:image.png)

2. `ServerHello`

- 서버 → 클라이언트
- ClientHello에서 제시된 옵션을 **선택**하여 전달
    - 선택된 TLS 버전
    - 선택된 암호 스위트
    - 키 생성을 위한 **서버 난수**

👉 이 단계까지 오면 암호화 통신에 필요한 정보들이 확정됨.

👉 클라이언트와 서버는 난수와 선택된 알고리즘을 기반으로 **공유 키** 생성.

---

1. **인증서 교환 & 검증**

> 인증서==공개 키 인증서(public key certificate)
당신이 통신을 주고받는 상대방은 틀림없이 당신이 의도한 대상이 맞다는 사실을 입증하기 위한 정보
> 
- 서버가 **Certificate 메시지**를 통해 인증서 전송
    - 인증서는 “내가 진짜 이 도메인의 주인이다”를 증명
    - 단순 자기 주장만으론 의미 없으므로 제3의 기관인 **인증 기관**(CA: Certification Authority)이 발급
- **Certificate 메시**지: 인증서 서명 값 등의 인증서 내용이 포함
- **CertificateVerify 메시지**: 인증서가 조작되지 않았는지 검증

👉 인증서 = 신원 보증서

👉 CA = 신뢰할 수 있는 제3자

---

1.  **Finished**
- 클라이언트 ↔ 서버 서로 Finished 메시지를 교환
- 이제 협의된 공유 키 기반으로 **암호화된 데이터 송수신 시작**
- TLS 1.3에서는 Finished 메시지와 함께 Application Data(실제 암호화된 HTTP 데이터)도 전송 가능

<aside>
💡

TLS 핸드셰이크는

1. 클라이언트와 서버가 암호화 방식과 키를 협의(ClientHello/ServerHello)하고
2. 서버 신원을 인증서로 검증(Certificate, CertificateVerify)한 뒤,
3. 공유 키를 확정해 Finished 메시지를 교환함으로써 이후의 HTTP 통신을 안전하게 암호화
</aside>

# 7. 프록시와 안정적인 트래픽

## 오리진 서버와 중간 서버: 포워드 프록시와 리버스 프록시

- **오리진 서버 (Origin Server)**: 실제 자원을 생성하고 응답할 수 있는 서버 (최종 목적지).
- **중간 서버**: 클라이언트와 오리진 서버 사이에 존재, 여러 역할 수행.
    - **프록시(Forward Proxy)**
        - 클라이언트의 대리인.
        - 캐시, 암호화, 접근 제한 등을 담당.
        - 클라이언트 쪽에 가까이 위치.
    - **게이트웨이(Reverse Proxy)**
        - 오리진 서버 앞에서 요청을 대신 받고 전달.
        - 클라이언트 입장에서는 오리진 서버처럼 보임.
            - 클라이언트보다 서버 쪽에 가까이 위치.
        - 캐시 저장, 부하 분산(로드 밸런서) 기능도 수행.

![image.png](attachment:c8f3785b-7601-4cfe-8369-cb6b19b978dd:image.png)

## 고가용성: 로드 밸런싱과 스케일링

> **가용성(Availability)** = 업타임 ÷ (업타임 + 다운타임)
> 
- 업타임: 정상적인 사용 시간
- 다운타임: 정상적인 사용이 불가능한 시간
    - 원인
        - 과도한 트래픽, 소프트웨어 오류, 하드웨어 장애, 보안 공격, 자연재해 등
- 목표: **99.999% (파이브 나인스)** 이상 → 연간 다운타임 약 5.26분
- 장애를 완전히 없애는 것보다는 **문제가 발생해도 동작하도록 설계**하는 것 → **결함 감내(Fault Tolerance)**
- 대표적인 방법: **다중화(Multiplexing)** + **자동 전환(Failover)**
- cf) 헬스 체크와 하트비트
    - **헬스 체크(Health Check)**: 로드 밸런서 등이 주기적으로 서버 상태 검사 (HTTP, ICMP 활용).
    - **하트비트(Heartbeat)**: 서버 간에 주기적으로 메시지를 주고받아 정상 여부 확인.

### 로드밸런싱

> 다중화된 서버에 **트래픽을 고르게 분산**시켜 가용성 유지.
> 
> - 서버를 **다중화**(여러 대 운영)한다고 해도 트래픽이 특정 서버에 몰리면 성능 저하 발생
> - 트래픽을 **고르게 분산**해야 **고가용성(HA, High Availability)** 확보 가능 → 이를 위해 로드 밸런싱 필요
- 구현: **로드 밸런서**
    - 클라이언트와 서버 사이에서 요청을 받아 여러 서버에 분산하는 역할
    - **L4/L7 스위치, Nginx, HAProxy, Envoy 등**
- **로드밸런싱 대표 알고리즘**
    - **라운드 로빈(Round Robin)**: 서버를 차례대로 돌아가며 분배
    - **최소 연결(Least Connection)**: 현재 연결 수가 가장 적은 서버에 분배
    - **랜덤(Random)**: 임의의 서버 선택
    - **IP 해시(IP Hash)**: 클라이언트 IP 기반으로 특정 서버에 매핑
    - **응답 시간 기반**: 가장 빠른 서버 선택
    - **가중치(Weight)**: 성능이 좋은 서버에 더 많은 요청 할당

<aside>
💡

안정적이고 확장 가능한 서버 운영을 위해 프록시/게이트웨이 같은 중간 서버를 활용하고, 
서버를 다중화 + 헬스 체크 + 로드 밸런싱(가중치 포함)으로 트래픽을 분산시켜 고가용성을 달성한다.

</aside>

### 스케일링

- **스케일 업 (Scale-Up, 수직 확장)**
    - 기존 장비를 더 좋은 사양으로 교체
    - 장점: 단순, 빠름
    - 단점: 한계가 있고, 비용이 급격히 올라감
- **스케일 아웃 (Scale-Out, 수평 확장)**
    - 서버 대수를 늘려 분산 처리
    - 장점: 유연성, 장애 감내력↑
    - 단점: 구성 복잡도↑
        
        ![image.png](attachment:6d7c615e-6c61-4cdb-b238-562a839c7aeb:image.png)
        
- **오토스케일링 (Auto Scaling)**
    - 트래픽 변화에 따라 자동으로 서버 수 확장/축소
    - 클라우드 서비스에서 기본 제공 (예: AWS, GCP, Azure)
    - 장점: 경제적, 탄력적 자원 관리

### Nginx 활용 예시

> **리버스 프록시 + 로드 밸런서** 역할 수행 가능
> 
- 설정 예시:
    
    ```
    upstream backend {
        server 10.10.10.2:80 weight=1;
        server 10.10.10.3:80 weight=2;
        server 10.10.10.4:80 backup;
    }
    
    server {
        listen 80;
        server_name localhost;
    
        location / {
            proxy_pass http://backend;
        }
    }
    ```
    
    - `weight`: 가중치 (성능 좋은 서버에 더 많은 요청 분배)
    - `backup`: 다른 서버가 죽었을 때만 사용

---

### 업스트림 / 다운스트림 vs 인바운드 / 아웃바운드

![image.png](attachment:f1a0de33-7de5-42a0-a1f3-4d1f918801d3:image.png)

- **업스트림 (Upstream)**: 클라이언트 → 서버 방향 (요청)
- **다운스트림 (Downstream)**: 서버 → 클라이언트 방향 (응답)
- **인바운드 (Inbound)**: 외부 → 내부 (예: 외부 사용자가 회사 서버 접근)
- **아웃바운드 (Outbound)**: 내부 → 외부 (예: 직원이 외부 사이트 접속)

## cf) 웹 서버(Web Server) vs 웹 애플리케이션 서버(WAS)

### 1. 웹 서버 (Web Server)

- **정적 콘텐츠** 제공 (변하지 않는 데이터)
    - 예: HTML, CSS, JS, 이미지, 동영상
- 대표 소프트웨어: **Nginx, Apache HTTP Server, IIS**
- 역할: 단순히 요청받은 파일을 찾아서 그대로 응답

---

### 2. 웹 애플리케이션 서버 (WAS, Web Application Server)

- **동적 콘텐츠** 제공 (사용자, 시간, 상황에 따라 달라지는 데이터)
    - 예: “안녕하세요, 민철님”, “오늘의 기온은 36.5도입니다”
- DB 조회, 비즈니스 로직 처리, 데이터 가공 후 응답
- 대표 소프트웨어: **Tomcat, JBoss, WebSphere**
- *미들웨어(Middleware)**의 일종 → 운영체제(OS)와 애플리케이션(웹 프레임워크) 사이를 중개
    - 예: Spring Boot 실행 시 Tomcat(WAS)도 함께 실행

---

### 3. 함께 쓰는 이유

- 대부분의 웹 서비스는 **정적 + 동적 콘텐츠** 모두 필요
- 구조:
    - 정적 콘텐츠 → **웹 서버**에서 처리 (빠르고 효율적)
    - 동적 콘텐츠 → **WAS**에서 처리 (복잡한 로직 담당)
- 장점:
    - 부하 분산 가능
    - 확장성 ↑ (여러 애플리케이션 연동 가능)

## cf) 소켓 프로그래밍

### 1. 소켓의 개념

- 소켓 = **네트워크 통신의 종착점(endpoint)**
- 비유: **우체통**
    - 송신 프로세스 → 메시지를 **소켓에 씀**
    - 수신 프로세스 → 메시지를 **소켓에서 읽음**

---

### 2. 소켓과 파일의 유사성

- 소켓은 운영체제에서 **특수한 파일처럼 취급**됨
    - `write()` → 네트워크 송신
    - `read()` → 네트워크 수신
- 파일이 **파일 디스크립터**로 식별되듯, 소켓은 **소켓 디스크립터**로 식별됨
- 따라서 소켓도 IPC(프로세스 간 통신)의 수단이 됨

---

### 3. 소켓 관련 시스템 콜

- 주요 함수: `socket()`, `bind()`, `listen()`, `accept()`, `read()/recv()`, `write()/send()`
- 실제 웹 서버(Nginx, Spring, Django 등)도 내부적으로 **소켓 시스템 콜**을 반복 실행하여 요청/응답 처리

```python
import socket

# 서버 주소와 포트 지정
SERVER_HOST = '127.0.0.1'
SERVER_PORT = 8000

# 1. 소켓 생성 (IPv4, TCP)
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 2. 소켓 옵션 설정 (주소 재사용 가능)
server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

# 3. 소켓 바인딩 (IP + PORT)
server_socket.bind((SERVER_HOST, SERVER_PORT))

# 4. 연결 대기 (최대 1개 연결 대기)
server_socket.listen(1)
print('Listening on port %s ...' % SERVER_PORT)

# 5. 연결 수락
client_connection, client_address = server_socket.accept()

# 6. 요청 수신 (최대 1024바이트)
request = client_connection.recv(1024).decode()
print(request)

# 7. 응답 전송
response = 'HTTP/1.0 200 OK\n\nThis is CS!'
client_connection.sendall(response.encode())

# 8. 연결 종료
client_connection.close()
server_socket.close()

```